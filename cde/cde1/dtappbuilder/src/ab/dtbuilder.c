/*** DTB_USER_CODE_START vvv Add file header below vvv ***/
/*
 *      $XConsortium: dtbuilder.c /main/cde1_maint/4 1995/10/16 13:43:52 rcs $
 *
 * @(#)dtbuilder.c	1.117 19 May 1995 cde_app_builder/src/ab
 *
 *      RESTRICTED CONFIDENTIAL INFORMATION:
 *
 *      The information in this document is subject to special
 *      restrictions in a confidential disclosure agreement between
 *      HP, IBM, Sun, USL, SCO and Univel.  Do not distribute this
 *      document outside HP, IBM, Sun, USL, SCO, or Univel without
 *      Sun's specific written approval.  This document and all copies
 *      and derivative works thereof must be returned or destroyed at
 *      Sun's request.
 *
 *      Copyright 1993 Sun Microsystems, Inc.  All rights reserved.
 *
 */

/*** DTB_USER_CODE_END   ^^^ Add file header above ^^^ ***/

/*
 * File: dtbuilder.c
 * Contains: main() and cross-module connections
 *
 * This file was generated by dtcodegen, from project dtbuilder
 *
 * Any text may be added between the DTB_USER_CODE_START and
 * DTB_USER_CODE_END comments (even non-C code). Descriptive comments
 * are provided only as an aid.
 *
 *  ** EDIT ONLY WITHIN SECTIONS MARKED WITH DTB_USER_CODE COMMENTS.  **
 *  ** ALL OTHER MODIFICATIONS WILL BE OVERWRITTEN. DO NOT MODIFY OR  **
 *  ** DELETE THE GENERATED COMMENTS!                                 **
 */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/MwmUtil.h>
#include <Xm/Protocols.h>
#include <Dt/Help.h>
#include <Dt/HelpQuickD.h>
#include <Dt/HelpDialog.h>
#include <Dt/Session.h>
#include <nl_types.h>
#include "palette_ui.h"
#include "about_box_ui.h"
#include "brws_ui.h"
#include "proj_ui.h"
#include "cgen_win_ui.h"
#include "conn_ui.h"
#include "appfw_ui.h"
#include "color_chooser_ui.h"
#include "dnd_ed_ui.h"
#include "help_ed_ui.h"
#include "attch_ed_ui.h"
#include "revolv_ui.h"
#include "button_ui.h"
#include "choice_ui.h"
#include "combobox_ui.h"
#include "cpanel_ui.h"
#include "custdlg_ui.h"
#include "drawp_ui.h"
#include "group_ui.h"
#include "label_ui.h"
#include "list_ui.h"
#include "mainwin_ui.h"
#include "menu_ui.h"
#include "menubar_ui.h"
#include "scale_ui.h"
#include "sep_ui.h"
#include "spinbox_ui.h"
#include "termp_ui.h"
#include "textf_ui.h"
#include "textp_ui.h"
#include "cgen_props_ui.h"
#include "cgen_env_ui.h"
#include "fchooser_ui.h"
#include "message_ed_ui.h"
#include "panedwin_ed_ui.h"
#include "dtbuilder.h"
#include "dtb_utils.h"


/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All necessary header files have been included.
 ***
 *** Add include files, types, macros, externs, and user functions here.
 ***/

#include <ctype.h>
#include <signal.h>
#include <Xm/FileSB.h>
#include <Xm/Label.h>
#include <Xm/RowColumn.h>
#include <Xm/ToggleB.h>
#include <Dt/Dt.h>
#include <Dt/Term.h>
#include <Dt/xpm.h>
#include <Dt/Action.h>
#include <Dt/Dts.h>
#include "dt_envcontrol.h"
#include <ab_private/MwmUtil.h>
#include <ab_private/obj_notify.h>
#include <ab_private/trav.h>
#include <ab_private/proj.h>
#include "dtb_utils.h"
#include "ui_util.h"
#include "x_util.h"
#include "ab.h"
#include "abobj.h"
#include "abobj_set.h"
#include "ab_resources.h"
#include "ab_dnd.h"
#include "ab_bil.h"
#include <ab_private/brws.h>
#include <ab_private/pal.h>
#include <ab_private/prop.h>
#include <ab_private/attch_ed.h>
#include <ab_private/abobj_edit.h>
#include <ab_private/conn.h>
#include <Xm/XmP.h>		/* _XmInstallPixmap() */

#ifdef DEBUG	/* performance testing */

#include <sys/times.h>
typedef struct
{
    double	startSeconds;
    double	endSeconds;
    double	elapsedSeconds;
} ABTimedIntervalRec, *ABTimedInterval;

typedef struct
{
    ABTimedIntervalRec	realTime;
    ABTimedIntervalRec	CPUTime;
} ABProfiledIntervalRec, *ABProfiledInterval;

static int get_cur_times(double *realTimeOut, double *cpuTimeOut);
static int get_start_times(ABProfiledInterval);
static int get_end_times(ABProfiledInterval);
static int calc_elapsed_times(ABProfiledInterval);
static int print_startup_time(
		ABProfiledInterval	totalTime
		);
#endif /* DEBUG/performance */

#define Offset(field) XtOffsetOf(DtbAppResourceRec, field)

/*
 * Data for init proc that gets called after main window is up.
 */
typedef struct {
    Boolean     free_me;
    Widget      toplevel_widget;
    int         argc;
    String      *argv;
} ABInitProcInfoRec, *ABInitProcInfo;

/*************************************************************************
**                                                                      **
**       Private Function Declarations                                  **
**                                                                      **
**************************************************************************/

static void             init_ab_timer_proc(
                            XtPointer           clientData,
                            XtIntervalId        *intervalIdPtr
                        );

static Boolean          init_ab_work_proc(
			    XtPointer clientData
                        );

static int              init_ab(
                            ABInitProcInfo  init_info
                        );

static int 		palette_title_rename_handler(
			    ObjEvAttChangeInfo      info
			);

static int 		att_change_dirty_OCB(
			    ObjEvAttChangeInfo      info
			);

static int 		err_output_handler(
			    STRING	errmsg
			);

static int 		output_handler(
			    STRING 	msg
			);

static Widget 		create_import_rbox(
			    Widget      	parent
			);

static void 		import_change_modeCB(
			    Widget widget,
			    XtPointer clientData,
			    XtPointer callData
			);

static void 		import_formatCB(
			    Widget widget,
			    XtPointer clientData,
			    XtPointer callData
			);
static Boolean 		name_proj_work_proc( 
			    XtPointer   clientData 
			);
static void		exit_dtbuilder(int param);
static void		reloadDB(XtPointer client_data);
static int		parse_help_option(
			    int		argc, 
			    char	*argv[]
			);
static void		ab_usage(
			);

/*************************************************************************
**                                                                      **
**       Data                                                           **
**                                                                      **
**************************************************************************/

extern void     	proj_show_dialog();
extern void     	layout_show_dialog();

#ifdef DEBUG	/* performance testing */
static ABProfiledIntervalRec	startupTime;
#endif

/*
 * This routine is called when the main palette is completely painted and
 * ready to go.
 */
static int
init_ab(ABInitProcInfo init_info)
{
    char	*current_project = NULL;
    char	*shown_modules = NULL;
    char	*type = NULL;
    XrmValue	value;
    struct sigaction    exit_action;
    BOOL	reopenFailed = FALSE;


    /*
     * Set up output handlers so that errors in libraries will pop up
     * error dialogs
     *
     * All other error/warning/status messages (i.e., those sent to either
     * stdout or stderr) will not be redirected.  If the invoker cares where
     * those messages go, they should redirect them via the shell.
     */
    util_set_output_handler(output_handler);
    util_set_err_output_handler(err_output_handler);

    XrmGetResource(AB_db, AB_XRM_CUR_PROJECT, AB_XRM_CUR_PROJECT, 
			&type, &value);

    current_project = (char *)value.addr;

    XrmGetResource(AB_db, AB_XRM_SHOWN_MODULES, AB_XRM_SHOWN_MODULES, 
			&type, &value);

    shown_modules = (char *)value.addr;

    obj_add_rename_callback(att_change_dirty_OCB,NULL);
    obj_add_rename_callback(palette_title_rename_handler,NULL);
 

    /* Catch ctrl-C, hangup, quit, and terminate signals.
     * If there are unsaved edits, post a dialog asking 
     * the user whether (s)he really wants to quit dtbuilder.
     */
    exit_action.sa_handler = exit_dtbuilder;
    exit_action.sa_flags = 0;
    sigemptyset(&(exit_action.sa_mask));
    if ((sigaction(SIGINT, &exit_action, NULL) < 0) ||
	(sigaction(SIGHUP, &exit_action, NULL) < 0) ||
	(sigaction(SIGQUIT, &exit_action, NULL) < 0) ||
	(sigaction(SIGTERM, &exit_action, NULL) < 0))
    {
	return -1;
    }

    /*
     * Load file on command line
     */  
    if (current_project || init_info->argc >= 2)
    {
        BOOL    file_is_project = FALSE;
        STRING  user_file_name;
        char    file_name[MAXPATHLEN] = "";
        STRING  errmsg = NULL;
        char    errmsg_buf[MAXPATHLEN] = "";
        int     ret = 0;
  	char	*dataType = NULL;
	DTB_MODAL_ANSWER    answer = DTB_ANSWER_NONE;
 
	if (current_project)
	{
            user_file_name = current_project;
	}
	else
	{
            user_file_name = init_info->argv[1];
	}
	
        strcpy(file_name, user_file_name);
        if (!util_file_exists(file_name))
        {
            *file_name = 0;
        }
        if ((*file_name) == 0)
        {
            sprintf(file_name, "%s.bip", user_file_name);
            if (!util_file_exists(file_name))
            {
                *file_name = 0;
            }
        }
        if ((*file_name) == 0)
        {
            sprintf(file_name, "%s.bil", user_file_name);
            if (!util_file_exists(file_name))
            {
                *file_name = 0;
            }
        }
 
        if ((*file_name) == 0)
        {
            sprintf(errmsg_buf, catgets(Dtb_project_catd, 100, 2, "File not found: %s"), user_file_name);
            errmsg = errmsg_buf;
        }
        else
        {
	    dataType = (char *) DtDtsFileToDataType(file_name);

            if ( (strcmp(dataType, BIP) == 0) ||
                 (strcmp(dataType, BIX) == 0) )
            {
                file_is_project = TRUE;
                ret = ab_check_and_open_bip(file_name);
            }
            else if (strcmp(dataType, BIL) == 0)
            {
                file_is_project = FALSE;
                answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
			&dtb_palette_import_by_msg, NULL, NULL, NULL);
		switch (answer)
                {
                    case DTB_ANSWER_ACTION1:        /* Copy */
			ret = ab_check_and_import_bil(file_name, TRUE);
		    break;
 
		    case DTB_ANSWER_ACTION2:        /* Reference */
			ret = ab_check_and_import_bil(file_name, FALSE);
		    break;

                    case DTB_ANSWER_CANCEL:
			ret = -1;
                    break;
		}
                if ((ret < 0) && (answer != DTB_ANSWER_CANCEL))
                {
                    sprintf(errmsg_buf, catgets(Dtb_project_catd, 100, 1, "Could not import module %s"), file_name);
                    errmsg = errmsg_buf;
                }
            }
	    else
	    {
		STRING              fmtStr = NULL, msg = NULL;
		XmString            xm_str = NULL;

		fmtStr = XtNewString(catgets(Dtb_project_catd, 100, 103,
                	"Cannot determine file type for %s.\nDo you want to load the file as a project or a module?"));
            	msg = (STRING) util_malloc(strlen(fmtStr) + strlen(file_name) + 1);
            	sprintf(msg, fmtStr, file_name);
            	xm_str = XmStringCreateLocalized(msg);

            	answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
                	&dtb_proj_ld_as_bip_or_bil_msg, xm_str, NULL, NULL);
 
            	XtFree(fmtStr);
            	util_free(msg);
            	XmStringFree(xm_str);
 
            	switch (answer)
            	{
                    case DTB_ANSWER_ACTION1:    /* Load as Project */
                	file_is_project = TRUE;
                        ret = ab_check_and_open_bip(file_name);
                    break;
 
                    case DTB_ANSWER_ACTION2:    /*Load as Module */
			file_is_project = FALSE;
			answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
                        	&dtb_palette_import_by_msg, NULL, NULL, NULL);
			switch (answer)
			{
			    case DTB_ANSWER_ACTION1:        /* Copy */
				ret = ab_check_and_import_bil(file_name, TRUE);
				break;

			    case DTB_ANSWER_ACTION2:        /* Reference */
				ret = ab_check_and_import_bil(file_name, FALSE);
				break;
 
			    case DTB_ANSWER_CANCEL:
				ret = -1;
				break;
			}
                    break;
 
                    case DTB_ANSWER_CANCEL:
		        ret = -1;
                    break;
		}
	    }
	}
 
        /*
         * Load is done.
         */
        if (ret > 0)
        {
            /* load was successful */
            objxm_tree_configure(proj_get_project(), OBJXM_CONFIG_BUILD);
 
            if (file_is_project)
            {
                proj_show_dialog();
                proj_show_proj_dir();

	        if (shown_modules)
	        {
		    AB_TRAVERSAL	trav;
		    ABObj		proj = proj_get_project(),
				    	module;
		    char		*cur_module_name,
					*found_module_name;


                    for (trav_open(&trav, proj, AB_TRAV_MODULES);
	                    (module = trav_next(&trav)) != NULL; )
                    {
		        cur_module_name = obj_get_name(module);

		        found_module_name = strstr(shown_modules, cur_module_name);

		        if (found_module_name)
		        {
			    if (!strcmp(cur_module_name, found_module_name) ||
			        isspace(found_module_name[strlen(cur_module_name)]))
			    {
			        if( abobj_show_tree(module, TRUE) == -1 )
			        {
				    fprintf(stderr, "Failed to show module %s\n",
					    cur_module_name);
			        }
			    }
		        }
	            }
	        }
            }
        }
        else if (errmsg != NULL)	/* load failed */
        {
	    XmString	xm_buf = XmStringCreateLocalized(errmsg);
	    dtb_proj_cmdline_load_file_msg_initialize(&dtb_proj_cmdline_load_file_msg);
	    dtb_show_message(dtb_get_toplevel_widget(),
		&dtb_proj_cmdline_load_file_msg, xm_buf, NULL);
	    XmStringFree(xm_buf);
        }
    } /* argc >= 2 */
 
    /*
     * Enable the visible windows
     */
    ab_set_busy_cursor(FALSE);
       
    /*
    if ((init_info != NULL) && (init_info->free_me))
    {
        util_free(init_info);
    }
    */

#ifdef DEBUG	/* performance testing */
    get_end_times(&startupTime);
    print_startup_time(&startupTime);
#endif /* DEBUG */
    return True;
}



/*
 * This is called immediately after startup, and if we have an expose
 * events still pending, checks again in another 250ms.  When we have
 * no expose events pending (e.g., all our startup is done), we call
 * ab_init()
 */
static void
init_ab_timer_proc(
                            XtPointer           clientData,
                            XtIntervalId        *intervalIdPtr
)
{
    ABInitProcInfo      init_info = (ABInitProcInfo)clientData;
    XtAppContext        app = XtWidgetToApplicationContext(
                                        init_info->toplevel_widget);
 
    int         num_events = 0;
    num_events = x_get_num_pending_expose_events(
                        XtDisplay(init_info->toplevel_widget));
    if (num_events < 1) 
    {
        /* no expose events - we're up and running */
        init_ab(init_info);
    }
    else
    {
        XtAppAddTimeOut(app, 250, init_ab_timer_proc, (XtPointer)init_info);
    }
}


/*
 * This is added just before XtAppMainLoop is called, and all of our
 * start up work should really be done, by now.  We're going to check,
 * though
 */
static Boolean
init_ab_work_proc(XtPointer clientData)
{
    ABInitProcInfo      init_info = (ABInitProcInfo)clientData;
    XtAppAddTimeOut(XtWidgetToApplicationContext(init_info->toplevel_widget),
                        1, init_ab_timer_proc, (XtPointer)init_info);
    return True;
}     
 

static int
palette_title_rename_handler(
        ObjEvAttChangeInfo      info
)
{
    ABObj       proj = info->obj;

    if (proj != proj_get_project())
    {
        return 0;
    }

    abobj_update_proj_name(proj);
    abobj_update_palette_title(proj);

    return 0;
}


/*
 * Sets the dirty flag when an attribute changes.
 */
static int
att_change_dirty_OCB(
        ObjEvAttChangeInfo      info
)
{
    ABObj	obj = info->obj;
    if (   obj_is_salient(obj) 
	&& (obj_get_project(obj) != NULL)
	&& (info->old_name != NULL) )
    {
        abobj_set_save_needed(obj, TRUE);
    }
    return 0;
}


/* Expects an internationalized error string.
 * Posts an error message in a dialog.
 */
static int
err_output_handler(
    STRING 	errmsg
)
{
    STRING		help_text = NULL;
    STRING		help_vol = NULL;
    STRING		help_loc = NULL;
    XmString		xm_buf = NULL;
    DtbObjectHelpData	help_data = NULL;

    xm_buf = XmStringCreateLocalized(errmsg);
    dtb_proj_error_msg_initialize(&dtb_proj_error_msg);

    util_get_help_data(&help_text, &help_vol, &help_loc);
    if (!util_strempty(help_text))
    {
	help_data = (DtbObjectHelpData) util_malloc(sizeof(DtbObjectHelpDataRec));
	help_data->help_text = help_text;
	help_data->help_volume = help_vol;
	help_data->help_locationID = help_loc;
    }
    else
    {
	/* If there is no help text to display, 
	 * then remove the Help button.
	 */
	dtb_proj_error_msg.help_button = False;
    }


    if (!util_strempty(help_text))
	(void)dtb_show_modal_message(dtb_get_toplevel_widget(),
		&dtb_proj_error_msg, xm_buf, help_data, NULL);
    else
	(void)dtb_show_modal_message(dtb_get_toplevel_widget(),
		&dtb_proj_error_msg, xm_buf, NULL, NULL);

    XmStringFree(xm_buf);
    if (help_data) 
	util_free(help_data);

    dtb_proj_error_msg.help_button = True;

    ui_sync_display_of_widget(dtb_get_toplevel_widget());

    return 0;   
}
 
 
/*
 * We're just going to eat all other output
 */
static int
output_handler(STRING msg)
{
    if (debugging())
    {
        fprintf(stderr, "%s", msg);
    }
    else
    {  
	STRING			help_text = NULL;
	STRING			help_vol = NULL;
	STRING			help_loc = NULL;
	XmString                xm_buf = NULL;
	DtbObjectHelpDataRec	help_data;

	xm_buf = XmStringCreateLocalized(msg);
	dtb_proj_info_msg_initialize(&dtb_proj_info_msg);

	util_get_help_data(&help_text, &help_vol, &help_loc);
	if (!util_strempty(help_text))
	{
	    help_data.help_text = help_text ? (STRING) XtNewString(help_text) : NULL;
            help_data.help_volume = help_vol ? (STRING) XtNewString(help_vol) : NULL;
            help_data.help_locationID = help_loc ? (STRING) XtNewString(help_loc) : NULL;
	}
	else
	{
	    /* If there is no help text to display, 
	     * then remove the Help button.
	     */
	    dtb_proj_info_msg.help_button = False;
	}

        if (!util_strempty(help_text))
	{
	    dtb_show_message(dtb_get_toplevel_widget(), 
		&dtb_proj_info_msg, xm_buf, &help_data);

	    /*
	     * Free help data strings
	     */
	    if (help_data.help_text);
	        XtFree(help_data.help_text);
            if (help_data.help_volume);
                XtFree(help_data.help_volume);
            if (help_data.help_locationID);
                XtFree(help_data.help_locationID);
	}
	else
	    dtb_show_message(dtb_get_toplevel_widget(), 
		&dtb_proj_info_msg, xm_buf, NULL);

	XmStringFree(xm_buf);

        ui_sync_display_of_widget(dtb_get_toplevel_widget());
    }
 
    return 0;
}




static Boolean
ab_save_sessionCB
(
    Widget	widget,
    char	*session_file,
    char	***argv,
    int		*argc
)
{
    FILE		*fp;
    AB_TRAVERSAL	trav;
    ABObj		proj,
			module;
    char		*proj_name;
    Boolean		first = True,
			curProjWritten = False,
			shownModulesWritten = False;

    if (!(fp = util_fopen_locked(session_file, "w+")))
    {
	fprintf(stderr, "fopen of session file %s failed.\n", session_file);
        return False;
    }

    chmod(session_file, S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP);

    /*
     * Current Project
     */
    proj = proj_get_project();
    if (proj)
    {
	if (proj_name = obj_get_file(proj))
	{
	    fprintf(fp, "%s:%s",
		AB_XRM_CUR_PROJECT, proj_name);
	    curProjWritten = True;
	}
    }

    if (curProjWritten)
    {
	fprintf(fp, "\n");

        /*
         * Shown modules
         */
        for (trav_open(&trav, proj, AB_TRAV_MODULES);
	        (module = trav_next(&trav)) != NULL; )
        {
	    if (obj_has_flag(module, MappedFlag))
	    {
	        if (first)
	        {
	            fprintf(fp, "%s: %s",
			    AB_XRM_SHOWN_MODULES, obj_get_name(module));
		    first = False;
	        }
	        else
	        {
	            fprintf(fp," %s", obj_get_name(module));
	        }
		shownModulesWritten = True;
	    }
        }
    }

    fclose(fp);

    if (curProjWritten | shownModulesWritten)
	return (True);

    return(False);
}

static Boolean
ab_restore_sessionCB
(
    Widget	widget,
    char	*session_file
)
{
    XrmDatabase db;

    /***  Open the resource database file ***/

    if ((db = XrmGetFileDatabase (session_file)) == NULL)
        return (False);

    AB_db = db;

    return (True);
}


#ifdef DEBUG	/* performance testing */

static int
get_start_times(ABProfiledInterval interval)
{
    return get_cur_times(&(interval->realTime.startSeconds),
		  	 &(interval->CPUTime.startSeconds));
}


static int
get_end_times(ABProfiledInterval interval)
{
    return get_cur_times(&(interval->realTime.endSeconds),
		  	 &(interval->CPUTime.endSeconds));
}


static int
calc_elapsed_times(ABProfiledInterval interval)
{
    interval->realTime.elapsedSeconds =
	interval->realTime.endSeconds - interval->realTime.startSeconds;
    interval->CPUTime.elapsedSeconds =
	interval->CPUTime.endSeconds - interval->CPUTime.startSeconds;
    return 0;
}


static int
print_startup_time(ABProfiledInterval totalTime)
{
    /*
     * Print out statistics about load
     */
    calc_elapsed_times(totalTime);

    fprintf(stderr, "\nStartup Time (Real/CPU) seconds: ");
    fprintf(stderr, "(%lg/%lg)\n", 
	totalTime->realTime.elapsedSeconds,
	totalTime->CPUTime.elapsedSeconds);

    return 0;
}


static int
get_cur_times(double *realTimeOut, double *cpuTimeOut)
{
    static BOOL	initialized = FALSE;
    static long	ticks_per_second = 1;
    struct tms  timeInfo;
    double      realTime;
    double      cpuTime;
    if (!initialized)
    {
	initialized = TRUE;
        ticks_per_second = sysconf(_SC_CLK_TCK);
    }

    realTime = times(&timeInfo);
    cpuTime = timeInfo.tms_utime + timeInfo.tms_stime
                        + timeInfo.tms_cutime + timeInfo.tms_cstime;
    *realTimeOut  = realTime / ticks_per_second;
    *cpuTimeOut = cpuTime / ticks_per_second;

    return 0;
}

#endif /* DEBUG/performance */

static Widget
create_import_rbox(
    Widget	parent
)
{
    Arg		args[10];
    int		n;
    Widget	parent_rbox = NULL,
		format_rbox = NULL,
		method_rbox = NULL,
		rbox = NULL,
		rbox_label = NULL,
		BIL_item = NULL,
		UIL_item = NULL,
		Copy_item = NULL,
		Ref_item = NULL;
    XmString	label_xmstring = NULL;


    /****************************************************
     * Create the parent row-column which will hold the	* 
     * 'Import Format' and 'Import By' radioboxes.	*
     ****************************************************/
    parent_rbox = XtVaCreateManagedWidget("parent_rbox",
                xmRowColumnWidgetClass,
                parent,
                XmNspacing, 0,
                XmNpacking, XmPACK_COLUMN,
		XmNnumColumns, 1,
                XmNisHomogeneous, True,
		XmNentryClass, xmRowColumnWidgetClass,
                XmNentryAlignment, XmALIGNMENT_BASELINE_BOTTOM,
                XmNorientation, XmVERTICAL,
                NULL);


    /****************************************************
     * Create the 'Import Format' radiobox. 		*
     ****************************************************/
    format_rbox = XtVaCreateManagedWidget("format_rbox",
                xmRowColumnWidgetClass,
                parent_rbox,
                XmNspacing, 0,
                XmNpacking, XmPACK_TIGHT,
                XmNisHomogeneous, False,
                XmNadjustLast, True,
                XmNmarginWidth, 0,
                XmNmarginHeight, 0,
                XmNentryAlignment, XmALIGNMENT_END,
                XmNorientation, XmHORIZONTAL,
                NULL);

    label_xmstring = XmStringCreateLocalized(
			catgets(Dtb_project_catd, 100, 46,"Import Format:"));
    rbox_label = XtVaCreateManagedWidget("rbox_label",
                xmLabelWidgetClass,
                format_rbox,
                XmNlabelType, XmSTRING,
                XmNlabelString, label_xmstring,
                NULL);
    XmStringFree(label_xmstring);
    label_xmstring = NULL;

    n = 0;
    XtSetArg(args[n], XmNradioBehavior, True);  ++n;
    XtSetArg(args[n], XmNentryClass, xmToggleButtonWidgetClass); ++n;
    XtSetArg(args[n], XmNnumColumns, 1);  ++n;
    XtSetArg(args[n], XmNisHomogeneous, True);  ++n;
    XtSetArg(args[n], XmNspacing, 0);  ++n;
    XtSetArg(args[n], XmNrowColumnType, XmWORK_AREA);  ++n;
    XtSetArg(args[n], XmNpacking, XmPACK_TIGHT);  ++n;
    XtSetArg(args[n], XmNorientation, XmHORIZONTAL);  ++n;
    rbox = XmCreateRadioBox(format_rbox, "rbox", args, n);
    XtManageChild(rbox);

    label_xmstring = XmStringCreateLocalized(
			catgets(Dtb_project_catd, 100, 47,"BIL"));
    BIL_item = XtVaCreateManagedWidget("bil_item",
                xmToggleButtonWidgetClass,
                rbox,
                XmNset, True,
                XmNlabelString, label_xmstring,
                NULL);
    XtAddCallback(BIL_item, 
		XmNvalueChangedCallback, import_formatCB,
		(XtPointer) IMPORT_AS_BIL);
    XmStringFree(label_xmstring);
    label_xmstring = NULL;

    label_xmstring = XmStringCreateLocalized(
			catgets(Dtb_project_catd, 100, 48,"UIL"));
    UIL_item = XtVaCreateManagedWidget("uil_item",
                xmToggleButtonWidgetClass,
                rbox,
                XmNset, False,
                XmNlabelString, label_xmstring,
                NULL);
    XtAddCallback(UIL_item, 
		XmNvalueChangedCallback, import_formatCB,
		(XtPointer) IMPORT_AS_UIL);
    XmStringFree(label_xmstring);
    label_xmstring = NULL;


    /****************************************************
     * Create the  'Import By' radiobox.		*
     ****************************************************/
    method_rbox = XtVaCreateManagedWidget("method_rbox",
                xmRowColumnWidgetClass,
                parent_rbox,
                XmNspacing, 0,
                XmNpacking, XmPACK_TIGHT,
                XmNisHomogeneous, False,
                XmNadjustLast, True,
                XmNmarginWidth, 0,
                XmNmarginHeight, 0,
                XmNentryAlignment, XmALIGNMENT_END,
                XmNorientation, XmHORIZONTAL,
                NULL);

    /* Pass in the 'Import By:' radiobox handle to the
     * 'change format' callback, so that it can make it
     * active (if importing as BIL) or inactive (if
     * importing as UIL).
     */
    XtVaSetValues(parent_rbox,
		XmNuserData, (XtPointer) method_rbox,
		NULL);

    label_xmstring = XmStringCreateLocalized(
                        catgets(Dtb_project_catd, 100, 49,"Import By:"));
    rbox_label = XtVaCreateManagedWidget("rbox_label",
                xmLabelWidgetClass, 
                method_rbox,
                XmNlabelType, XmSTRING, 
                XmNlabelString, label_xmstring, 
                NULL); 
    XmStringFree(label_xmstring); 
    label_xmstring = NULL; 

    n = 0;
    XtSetArg(args[n], XmNnumColumns, 1);  ++n;
    XtSetArg(args[n], XmNspacing, 0);  ++n;
    XtSetArg(args[n], XmNpacking, XmPACK_TIGHT);  ++n;
    XtSetArg(args[n], XmNorientation, XmHORIZONTAL);  ++n;
    rbox = XmCreateRadioBox(method_rbox, "rbox", args, n);
    XtManageChild(rbox);

    label_xmstring = XmStringCreateLocalized(
			catgets(Dtb_project_catd, 100, 50,"Copy"));
    Copy_item = XtVaCreateManagedWidget("Copy_item",
                xmToggleButtonWidgetClass,
                rbox,
                XmNset, True,
                XmNlabelString, label_xmstring,
                NULL);
    XtAddCallback(Copy_item,
                        XmNvalueChangedCallback, import_change_modeCB,
                        (XtPointer) IMPORT_BY_COPY);
    XmStringFree(label_xmstring);
    label_xmstring = NULL;

    label_xmstring = XmStringCreateLocalized(
			catgets(Dtb_project_catd, 100, 51,"Reference"));
    Ref_item = XtVaCreateManagedWidget("Ref_item",
		xmToggleButtonWidgetClass,
                rbox,
                XmNset, False,
                XmNlabelString, label_xmstring,
                NULL);
    XtAddCallback(Ref_item,
                        XmNvalueChangedCallback, import_change_modeCB,
                        (XtPointer) IMPORT_BY_REF);
    XmStringFree(label_xmstring);
    label_xmstring = NULL;

    return (parent_rbox);
}


static void
import_change_modeCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    XmToggleButtonCallbackStruct *state =
                (XmToggleButtonCallbackStruct *)callData;
    int			ImportMode = (int) clientData;
    ChooserInfo		info = NULL;

    if (state->set)
    {
	XtVaGetValues(AB_generic_chooser,
			XmNuserData, &info,
			NULL);
	switch (ImportMode) 
	{
	    case IMPORT_BY_COPY: 
		info->ImportByCopy = TRUE;	
		break;

	    case IMPORT_BY_REF: 
		info->ImportByCopy = FALSE;	
		break;
	}
    }
}

static void
import_formatCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    XmToggleButtonCallbackStruct *state =
                (XmToggleButtonCallbackStruct *)callData;
    int         	ImportFormat = (int) clientData;
    ChooserInfo    	info = NULL;
    Widget		method_rbox = NULL;
 
    if (state->set)
    {
	XtVaGetValues(AB_generic_chooser, 
			XmNuserData, &info,
			NULL);
	XtVaGetValues(info->child, 
			XmNuserData, &method_rbox,
			NULL);
	switch (ImportFormat) 
	{
	    case IMPORT_AS_BIL: 
		info->ImportAsBil = TRUE;

		/* Set the file filter string to match
		 * on files with ".bil" extension.
		 */
		XtVaSetValues(AB_generic_chooser,
                	XtVaTypedArg, XmNpattern,
                        	XtRString, "*.bil", 
				sizeof("*.bil"), NULL);

	  	if (!XtIsSensitive(method_rbox))
		{
		    XtSetSensitive(method_rbox, True);
		}
		break;

	    case IMPORT_AS_UIL: 
		info->ImportAsBil = FALSE;

		/* Set the file filter string to match
		 * on files with ".uil" extension.
		 */
		XtVaSetValues(AB_generic_chooser,
                	XtVaTypedArg, XmNpattern,
                        	XtRString, "*.uil", 
				sizeof("*.uil"), NULL);

		/* If importing a UIL file, then set the 'Import By'
	 	 * radiobox inactive, since it does not apply. 
	 	 */
	  	if (XtIsSensitive(method_rbox))
		{
		    XtSetSensitive(method_rbox, False);
		}
		break;
	}
    }
}

/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/



/* Workaround for XPG4 API compatibility */
#if !defined(NL_CAT_LOCALE)
#define NL_CAT_LOCALE 0
#endif

/* Handle for standard message catalog for the project */
nl_catd	Dtb_project_catd = (nl_catd)-1;

/*
 * command line options...
 */
static XrmOptionDescRec optionDescList[] = {
    {"-session", "*session", XrmoptionSepArg, (XPointer)NULL}
    
    /*** DTB_USER_CODE_START vvv Add structure fields below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add structure fields above ^^^ ***/
};

/*
 * Application Resources
 */
static XtResource resources[] = {
    {"session", "Session", XtRString, sizeof(String),
        XtOffsetOf(DtbAppResourceRec, session_file), XtRImmediate, (XtPointer)NULL}
    
    /*** DTB_USER_CODE_START vvv Add structure fields below vvv ***/

    ,
    {"useSmallDragCursor", "UseSmallDragCursor", XtRBoolean, sizeof(Boolean),
        Offset(use_small_drag_cursor), XtRImmediate, (XtPointer)False},

    {"impliedApply", "ImpliedApply", XtRBoolean, sizeof(Boolean),
        Offset(implied_apply), XtRImmediate, (XtPointer)False}

    /*** DTB_USER_CODE_END   ^^^ Add structure fields above ^^^ ***/
};

DtbAppResourceRec	dtb_app_resource_rec;


/*
 * main for application dtbuilder
 */
int 
main(
    int argc,
    char **argv
)
{
    Widget		toplevel = (Widget)NULL;
    XtAppContext	app = (XtAppContext)NULL;
    String		*fallback_resources = (String*)NULL;
    ArgList		init_args = (ArgList)NULL;
    Cardinal		num_init_args = (Cardinal)0;
    ArgList		get_resources_args = (ArgList)NULL;
    Cardinal		num_get_resources_args = (Cardinal)0;
    Atom		save_yourself_atom = (Atom)NULL;
    XtLanguageProc	language_proc = (XtLanguageProc)NULL;
    XtPointer		language_proc_client_data = (XtPointer)NULL;
    
    
    /**************************************************************************
     *** DTB_USER_CODE_START
     ***
     ***  No initialization has been done.
     ***
     *** Add local variables and code.
     ***/

    Widget      	main_widget = (Widget) NULL,
			layout_menu = (Widget) NULL;
    ABInitProcInfo      init_proc_info = NULL;
    int			status = 0;
    Pixmap		xpm_pixmap = NULL;
    Pixmap		pixmap = NULL;
    int			num_mouse_buttons = 0;
    Display		*theDisplay = NULL;

#ifdef __osf__
/* Added here just in case */
    svc_init();
#endif

#ifdef DEBUG	/* performance testing */
    get_start_times(&startupTime);
#endif /* DEBUG */

    /*
     * Initialize common functionality
     *
     * Do this first!! Other function calls may depend on this.
     */  
    util_init(&argc, &argv);
    parse_help_option(argc, argv);
    if (!debugging())
    {
        util_set_verbosity(0);  /* if we're not debugging, disable output */
    }


    /*
    ** This next routine must be called so that the DtTerm widgets can
    ** work around a motif problem in keyboard traversal.  See the DtTerm
    ** widget documentation for more details.
    */
    (void) DtTermInitialize();

    /* 
    ** Set up CDE environment variables.  This is required for CDE components
    ** that must be able to handle variations in CDE environment variables
    ** across various hardware platforms.  It is not a public part of CDE.
    */
    _DtEnvControl(DT_ENV_SET); 

    /*** DTB_USER_CODE_END
     ***
     *** End of user code section
     ***
     **************************************************************************/
    

    /* NULL language_proc installs the default Xt language procedure */
    XtSetLanguageProc((XtAppContext)NULL,
        language_proc, language_proc_client_data);
    
    toplevel = XtAppInitialize(&app, "Dtbuilder",
        optionDescList, XtNumber(optionDescList),
        &argc, argv, fallback_resources,
        init_args, num_init_args);

    /*
     * Get display and verify initialization was successful.
     */
    if (toplevel == NULL)
    {
        fprintf(stderr, "Could not open display.\n");
        exit(1);
    }
    
    /*
     * Open the standard message catalog for the project.
     */
    Dtb_project_catd = catopen(DTB_PROJECT_CATALOG, NL_CAT_LOCALE);
    if (Dtb_project_catd == (nl_catd)-1)
    {
        fprintf(stderr, "WARNING: Could not open message catalog: %s. Messages will be defaults.\n",
            DTB_PROJECT_CATALOG);
    }
    
    /*
     * Save the toplevel widget so it can be fetched later as needed.
     */
    dtb_save_toplevel_widget(toplevel);
    
    /*
     * Save the command used to invoke the application.
     */
    dtb_save_command(argv[0]);
    
    XtGetApplicationResources(toplevel, (XtPointer)&dtb_app_resource_rec,
        resources, XtNumber(resources),
        get_resources_args, num_get_resources_args);
    
    /**************************************************************************
     *** DTB_USER_CODE_START
     ***
     ***      A connection to the X server has been established, and all
     *** initialization has been done.
     ***
     ***  Add extra initialization code after this comment.
     ***/

    AB_toplevel = dtb_get_toplevel_widget();
    theDisplay = XtDisplay(toplevel);
    DtAppInitialize(app, theDisplay,
                dtb_get_toplevel_widget(), argv[0], "Dtbuilder");

    /* Load the data types database. Necessary for DnD. */
    DtDbLoad();
    DtDbReloadNotify(reloadDB, (XtPointer) NULL);

    /* Set icon pixmap, if there is one */
    /* status = _DtXpmCreatePixmapFromData(theDisplay,
        DefaultRootWindow(theDisplay),
        ab_pm, &xpm_pixmap, (Pixmap *)NULL, (XpmAttributes *)NULL); */
    if(status == XpmSuccess)
    {  
        XtVaSetValues(dtb_get_toplevel_widget(), XmNiconPixmap, xpm_pixmap, NULL);
    }

    /* 
     * Setup Palette to be "leader" window so that when it is
     * iconified, all other windows get brought down; when it
     * is re-opened, all windows will be restored to their 
     * original state at the time dtbuilder was iconified.
     */
    ab_register_window(AB_toplevel, AB_WIN_LEADER, WindowUp, 
		NULL, AB_WPOS_UNSPECIFIED, palP_exit_dtbuilderCB, NULL);

    /* 
     * Determine if Button2 should be used for Transfer 
     */
    XtVaGetValues((Widget)XmGetXmDisplay(theDisplay),
                "enableBtn1Transfer",   &AB_btn1_transfer,
                NULL);

    /*
     * Determine which button should be used to invoke PopupMenus
     * by querying the display for number of mouse buttons.
     * NOTE: we are basically punting here on 1 button mice.
     */
    num_mouse_buttons = XGetPointerMapping(
				theDisplay, (unsigned char *)NULL, 0);
    AB_BMenu = (num_mouse_buttons > 2? Button3 : Button2);

    /*** DTB_USER_CODE_END
     ***
     *** End of user code section
     ***
     **************************************************************************/
    

    if (dtb_app_resource_rec.session_file)
    {
        dtb_set_client_session_restoreCB((DtbClientSessionRestoreCB)Session_restoreCB);
        (void)dtb_session_restore(toplevel, dtb_app_resource_rec.session_file);
    }
    
    /*
     * Initialize all global variables.
     */
    dtbPaletteAbPaletteMainInfo_clear(&dtb_palette_ab_palette_main);
    dtb_palette_exit_msg_initialize(&dtb_palette_exit_msg);
    dtb_palette_chld_or_layr_msg_initialize(&dtb_palette_chld_or_layr_msg);
    dtb_palette_layered_pane_msg_initialize(&dtb_palette_layered_pane_msg);
    dtb_palette_layr_pw_msg_initialize(&dtb_palette_layr_pw_msg);
    dtb_palette_chld_layr_pw_msg_initialize(&dtb_palette_chld_layr_pw_msg);
    dtb_palette_info_msg_initialize(&dtb_palette_info_msg);
    dtb_palette_open_ro_proj_msg_initialize(&dtb_palette_open_ro_proj_msg);
    dtb_palette_import_ro_msg_initialize(&dtb_palette_import_ro_msg);
    dtb_palette_empty_proj_msg_initialize(&dtb_palette_empty_proj_msg);
    dtb_palette_error_msg_initialize(&dtb_palette_error_msg);
    dtb_palette_import_by_msg_initialize(&dtb_palette_import_by_msg);
    dtb_palette_drop_err_msg_initialize(&dtb_palette_drop_err_msg);
    dtb_palette_wrn_msg_initialize(&dtb_palette_wrn_msg);
    dtb_palette_prevent_close_msg_initialize(&dtb_palette_prevent_close_msg);
    dtb_palette_child_of_group_msg_initialize(&dtb_palette_child_of_group_msg);
    dtbAboutBoxDialogInfo_clear(&dtb_about_box_dialog);
    dtbAboutBoxDialog2Info_clear(&dtb_about_box_dialog2);
    dtbBrwsFindDlgInfo_clear(&dtb_brws_find_dlg);
    dtbBrwsMainwindowInfo_clear(&dtb_brws_mainwindow);
    dtbProjProjMainInfo_clear(&dtb_proj_proj_main);
    dtb_proj_vrfy_mod_name_msg_initialize(&dtb_proj_vrfy_mod_name_msg);
    dtb_proj_vrfy_proj_name_msg_initialize(&dtb_proj_vrfy_proj_name_msg);
    dtb_proj_vrfy_c_ident_msg_initialize(&dtb_proj_vrfy_c_ident_msg);
    dtb_proj_no_name_msg_initialize(&dtb_proj_no_name_msg);
    dtb_proj_brws_mod_msg_initialize(&dtb_proj_brws_mod_msg);
    dtb_proj_create_proj_msg_initialize(&dtb_proj_create_proj_msg);
    dtb_proj_close_proj_msg_initialize(&dtb_proj_close_proj_msg);
    dtb_proj_no_mem_msg_initialize(&dtb_proj_no_mem_msg);
    dtb_proj_error_msg_initialize(&dtb_proj_error_msg);
    dtb_proj_wrn_msg_initialize(&dtb_proj_wrn_msg);
    dtb_proj_overwrite_msg_initialize(&dtb_proj_overwrite_msg);
    dtb_proj_save_proj_as_msg_initialize(&dtb_proj_save_proj_as_msg);
    dtb_proj_save_as_mod_msg_initialize(&dtb_proj_save_as_mod_msg);
    dtb_proj_open_proj_warn_msg_initialize(&dtb_proj_open_proj_warn_msg);
    dtb_proj_cmdline_load_file_msg_initialize(&dtb_proj_cmdline_load_file_msg);
    dtb_proj_bix_save_msg_initialize(&dtb_proj_bix_save_msg);
    dtb_proj_unique_name_msg_initialize(&dtb_proj_unique_name_msg);
    dtb_proj_info_msg_initialize(&dtb_proj_info_msg);
    dtb_proj_del_mod_msg_initialize(&dtb_proj_del_mod_msg);
    dtb_proj_ld_as_bip_or_bil_msg_initialize(&dtb_proj_ld_as_bip_or_bil_msg);
    dtbCgenWinMainwindowInfo_clear(&dtb_cgen_win_mainwindow);
    dtb_cgen_win_query_save_or_abort_msg_initialize(&dtb_cgen_win_query_save_or_abort_msg);
    dtb_cgen_win_query_save_or_gen_old_msg_initialize(&dtb_cgen_win_query_save_or_gen_old_msg);
    dtb_cgen_win_modify_path_msg_initialize(&dtb_cgen_win_modify_path_msg);
    dtb_cgen_win_no_makefile_msg_initialize(&dtb_cgen_win_no_makefile_msg);
    dtb_cgen_win_wrong_makefile_msg_initialize(&dtb_cgen_win_wrong_makefile_msg);
    dtb_cgen_win_no_exe_msg_initialize(&dtb_cgen_win_no_exe_msg);
    dtbConnConnDialogInfo_clear(&dtb_conn_conn_dialog);
    dtb_conn_no_func_msg_initialize(&dtb_conn_no_func_msg);
    dtbConnExecCodeDialogInfo_clear(&dtb_conn_exec_code_dialog);
    dtbAppfwDialogInfo_clear(&dtb_appfw_dialog);
    dtb_appfw_appfw_pending_msg_initialize(&dtb_appfw_appfw_pending_msg);
    dtbColorChooserDialogInfo_clear(&dtb_color_chooser_dialog);
    dtb_color_chooser_message_initialize(&dtb_color_chooser_message);
    dtbDndEdDialogInfo_clear(&dtb_dnd_ed_dialog);
    dtbHelpEdHelpEditorInfo_clear(&dtb_help_ed_help_editor);
    dtb_help_ed_wrn_msg_initialize(&dtb_help_ed_wrn_msg);
    dtbAttchEdAttchEdDialogInfo_clear(&dtb_attch_ed_attch_ed_dialog);
    dtb_attch_ed_wrn_msg_initialize(&dtb_attch_ed_wrn_msg);
    dtb_attch_ed_grp_member_wrn_initialize(&dtb_attch_ed_grp_member_wrn);
    dtbRevolvPropDialogInfo_clear(&dtb_revolv_prop_dialog);
    dtb_revolv_prop_pend_msg_initialize(&dtb_revolv_prop_pend_msg);
    dtb_revolv_wrn_msg_initialize(&dtb_revolv_wrn_msg);
    dtbButtonPropDialogInfo_clear(&dtb_button_prop_dialog);
    dtbChoicePropDialogInfo_clear(&dtb_choice_prop_dialog);
    dtbComboboxPropDialogInfo_clear(&dtb_combobox_prop_dialog);
    dtbCpanelPropDialogInfo_clear(&dtb_cpanel_prop_dialog);
    dtbCustdlgPropDialogInfo_clear(&dtb_custdlg_prop_dialog);
    dtb_custdlg_remove_bpanel_msg_initialize(&dtb_custdlg_remove_bpanel_msg);
    dtb_custdlg_remove_footer_msg_initialize(&dtb_custdlg_remove_footer_msg);
    dtbDrawpPropDialogInfo_clear(&dtb_drawp_prop_dialog);
    dtbGroupPropDialogInfo_clear(&dtb_group_prop_dialog);
    dtbLabelPropDialogInfo_clear(&dtb_label_prop_dialog);
    dtbListPropDialogInfo_clear(&dtb_list_prop_dialog);
    dtbMainwinPropDialogInfo_clear(&dtb_mainwin_prop_dialog);
    dtb_mainwin_remove_mbar_msg_initialize(&dtb_mainwin_remove_mbar_msg);
    dtb_mainwin_remove_tbar_msg_initialize(&dtb_mainwin_remove_tbar_msg);
    dtb_mainwin_remove_footer_msg_initialize(&dtb_mainwin_remove_footer_msg);
    dtbMenuPropDialogInfo_clear(&dtb_menu_prop_dialog);
    dtbMenubarPropDialogInfo_clear(&dtb_menubar_prop_dialog);
    dtbScalePropDialogInfo_clear(&dtb_scale_prop_dialog);
    dtbSepPropDialogInfo_clear(&dtb_sep_prop_dialog);
    dtbSpinboxPropDialogInfo_clear(&dtb_spinbox_prop_dialog);
    dtb_spinbox_chg_type_msg_initialize(&dtb_spinbox_chg_type_msg);
    dtbTermpPropDialogInfo_clear(&dtb_termp_prop_dialog);
    dtbTextfPropDialogInfo_clear(&dtb_textf_prop_dialog);
    dtbTextpPropDialogInfo_clear(&dtb_textp_prop_dialog);
    dtbCgenPropsCgenPropsDlgInfo_clear(&dtb_cgen_props_cgen_props_dlg);
    dtb_cgen_props_no_sel_mod_msg_initialize(&dtb_cgen_props_no_sel_mod_msg);
    dtbCgenEnvDialogInfo_clear(&dtb_cgen_env_dialog);
    dtbFchooserPropDialogInfo_clear(&dtb_fchooser_prop_dialog);
    dtbMessageEdDialogInfo_clear(&dtb_message_ed_dialog);
    dtb_message_ed_act1_def_btn_msg_initialize(&dtb_message_ed_act1_def_btn_msg);
    dtb_message_ed_act2_def_btn_msg_initialize(&dtb_message_ed_act2_def_btn_msg);
    dtb_message_ed_cancel_def_btn_msg_initialize(&dtb_message_ed_cancel_def_btn_msg);
    dtb_message_ed_act1_lbl_msg_initialize(&dtb_message_ed_act1_lbl_msg);
    dtb_message_ed_act2_lbl_msg_initialize(&dtb_message_ed_act2_lbl_msg);
    dtb_message_ed_act3_def_btn_msg_initialize(&dtb_message_ed_act3_def_btn_msg);
    dtb_message_ed_act3_lbl_msg_initialize(&dtb_message_ed_act3_lbl_msg);
    dtb_message_ed_wrn_msg_initialize(&dtb_message_ed_wrn_msg);
    dtb_message_ed_no_btns_msg_initialize(&dtb_message_ed_no_btns_msg);
    dtbPanedwinEdDialogInfo_clear(&dtb_panedwin_ed_dialog);
    dtb_panedwin_ed_pw_east_attach_msg_initialize(&dtb_panedwin_ed_pw_east_attach_msg);
    dtb_panedwin_ed_pw_west_attach_msg_initialize(&dtb_panedwin_ed_pw_west_attach_msg);
    
    /*
     * Set up the application's root (primary) window.
     */
    dtb_palette_ab_palette_main.ab_palette_main = toplevel;
    XtVaSetValues(dtb_palette_ab_palette_main.ab_palette_main,
        XmNallowShellResize, True,
        XmNtitle, catgets(Dtb_project_catd, 6, 1, "Application Builder"),
        XmNiconName, catgets(Dtb_project_catd, 6, 135, "dtbuilder"),
        XmNinitialState, NormalState,
        XmNmwmDecorations, MWM_DECOR_ALL | MWM_DECOR_RESIZEH,
        XmNmwmFunctions, MWM_FUNC_ALL | MWM_FUNC_RESIZE,
        NULL);
    
    dtb_palette_ab_palette_main_initialize(&(dtb_palette_ab_palette_main), dtb_get_toplevel_widget());
    
    
    save_yourself_atom = XmInternAtom(XtDisplay(toplevel),
    	"WM_SAVE_YOURSELF", False);
    dtb_set_client_session_saveCB((DtbClientSessionSaveCB)Session_saveCB);
    
    XmAddWMProtocolCallback(toplevel, save_yourself_atom,
    	dtb_session_save, (XtPointer)NULL);
    
    
    /**************************************************************************
     *** DTB_USER_CODE_START
     ***
     ***      All initially-mapped widgets have been created, but not
     *** realized. Set resources on widgets, or perform other operations
     *** that must be completed before the toplevel widget is
     *** realized.
     ***/

    /*** DTB_USER_CODE_END
     ***
     *** End of user code section
     ***
     **************************************************************************/
    

    XtRealizeWidget(toplevel);

    
    /**************************************************************************
     *** DTB_USER_CODE_START
     ***
     ***      All automatic initialization is complete. Add any additional
     *** code that should be executed before the Xt main loop is entered.
     ***/

    /* Load bitmaps for drag cursor */
    x_load_cursor_bitmaps(dtb_get_toplevel_widget());

 
    /* Set up "Actions" for manipulating ui objects */
    abobj_register_build_actions(app);
 
    /* Set up "Actions" for browser */
    brws_register_actions(app);
 
    /* Set up "Actions" for project window */
    proj_register_actions(app);
 
    /* Register Menu Palette Obj */
    pal_register_item_info(NULL, ab_menu_palitem, (int)AB_NO_SUBTYPE, 
		NULL, NULL);
 
    /* Register Group Palette Obj */
    pal_register_item_info(NULL, ab_group_palitem, (int)AB_CONT_GROUP, 
		"Group", NULL);
 
    /* Register Paned Window Palette Obj */
    pal_register_item_info(NULL, ab_panedwin_palitem, (int)AB_CONT_PANED, 
		NULL, NULL);

    pal_register_item_info(NULL, ab_button_palitem, (int)AB_BUT_DRAWN, 
		"Drawn Button", NULL);

    /* Register All Editable objects which are not Palette Items */
    pal_register_editable_obj(AB_TYPE_PROJECT, (int)AB_NO_SUBTYPE,
                "Application", NULL);
    pal_register_editable_obj(AB_TYPE_LAYERS, (int)AB_NO_SUBTYPE,
                "Layers", NULL);
    pal_register_editable_obj(AB_TYPE_MESSAGE, (int)AB_NO_SUBTYPE,
                "Message", NULL);
    pal_register_editable_obj(AB_TYPE_ITEM, AB_ITEM_FOR_CHOICE,
                "Choice Item", NULL);
    pal_register_editable_obj(AB_TYPE_ITEM, AB_ITEM_FOR_MENU,
                "Menu Item", NULL);
    pal_register_editable_obj(AB_TYPE_ITEM, AB_ITEM_FOR_MENUBAR,
                "Menubar Item", NULL);
 
    /* Initialize ObjXm */
    objxm_init(dtb_get_toplevel_widget());
    objxm_set_cvt_filename_to_pixmap_callback(ab_cvt_image_file_to_pixmap);
    objxm_set_post_instantiate_callback(ab_post_instantiate);
 
    /* Initialize project */
    proj_init();
 
    /* Initialize browser */
    brws_init();
 
    /* Initialize Props */
    prop_init(dtb_get_toplevel_widget());
 
    /* Initialize Attachments editor */
    attch_ed_init();
 
    /* Initialize connections notify callback */
    conn_init();
 
    /* Initialize edit notify callback */
    abobj_edit_init();

    /* Initialize strings */
    abobj_strings_init();

    /*
     * Initialize layout menu
     */
    XtDestroyWidget(dtb_palette_ab_palette_main.palette_menubar_Layout_item_layout_pulldown_items.Item1_item);
    XtVaGetValues(dtb_palette_ab_palette_main.palette_menubar_items.Layout_item,
    			XmNsubMenuId, &layout_menu,
    			NULL);
    abobj_build_layout_menu(layout_menu);

    pixmap = XmGetPixmapByDepth(XtScreen(dtb_get_toplevel_widget()),
        "50_foreground", BlackPixelOfScreen(XtScreen(dtb_get_toplevel_widget())),
        WhitePixelOfScreen(XtScreen(dtb_get_toplevel_widget())),
        DefaultDepthOfScreen(XtScreen(dtb_get_toplevel_widget())));
    _XmInstallPixmap(pixmap, XtScreen(dtb_get_toplevel_widget()),
        "_XmScrollBarUnavailableStipple",
        BlackPixelOfScreen(XtScreen(dtb_get_toplevel_widget())),
        WhitePixelOfScreen(XtScreen(dtb_get_toplevel_widget())));
 
    main_widget = dtb_palette_ab_palette_main.ab_palette_main_mainwin;
    ab_dnd_register_drop_file(main_widget);

    ab_palette_set_active(TRUE);

    /*
     * Set up to have init_ab() called when our primary window is up
     */
    init_proc_info = (ABInitProcInfo)XtMalloc(sizeof(ABInitProcInfoRec));
    if (init_proc_info == NULL)
    {
	dtb_proj_no_mem_msg_initialize(&dtb_proj_no_mem_msg);	
	(void)dtb_show_modal_message(dtb_get_toplevel_widget(),
			&dtb_proj_no_mem_msg, NULL, NULL, NULL);
        exit(1);
    }
    init_proc_info->free_me = True;     /* dynamically allocated */
    init_proc_info->toplevel_widget = NULL;
    init_proc_info->argc = argc;
    init_proc_info->argv = (String *)argv;
    init_proc_info->toplevel_widget = dtb_get_toplevel_widget();
    ab_set_busy_cursor(TRUE);
    XtAppAddWorkProc(app, init_ab_work_proc, (XtPointer)init_proc_info);

    /*** DTB_USER_CODE_END
     ***
     *** End of user code section
     ***
     **************************************************************************/
    

    /*
     * Enter event loop
     */
    XtAppMainLoop(app);
    return 0;
}

void 
palette_help_pulldown_About_Application_Builder_item_CB1(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    DtbAboutBoxDialogInfo	instance = (DtbAboutBoxDialogInfo)clientData;
    
    if (!(instance->initialized))
    {
        dtb_about_box_dialog_initialize(instance, dtb_palette_ab_palette_main.ab_palette_main);
    }
    XtManageChild(instance->dialog_shellform);
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
brws_help_pulldown_About_Application_Builder_item_CB1(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    DtbAboutBoxDialogInfo	instance = (DtbAboutBoxDialogInfo)clientData;
    
    if (!(instance->initialized))
    {
        dtb_about_box_dialog_initialize(instance, dtb_palette_ab_palette_main.ab_palette_main);
    }
    XtManageChild(instance->dialog_shellform);
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_proj_help_menu_About_Application_Builder_item_CB1(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    DtbAboutBoxDialogInfo	instance = (DtbAboutBoxDialogInfo)clientData;
    
    if (!(instance->initialized))
    {
        dtb_about_box_dialog_initialize(instance, dtb_palette_ab_palette_main.ab_palette_main);
    }
    XtManageChild(instance->dialog_shellform);
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


Boolean
Session_saveCB(Widget widget, String session_file, char ***argv, int *argc)
{
    Boolean		ret_value = False;
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    FILE		*fp;
    AB_TRAVERSAL	trav;
    ABObj		proj,
			module;
    char		*proj_name;
    Boolean		first = True,
			curProjWritten = False,
			shownModulesWritten = False;
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*
     * Save application state in either session file and/or
     * command line vector.
     * 
     * Session File:
     *     Open the file "session_file"
     *     Write application state information into it
     *     Close the file
     *     Set "ret_value" to True
     *     (Setting "ret_value" to True is important if you are using
     *     session files! Do not set it to True if you are not using
     *     session files.)
     * 
     * Command line vector:
     *     Allocate an argv vector
     *     Fill it up with the appropriate strings
     *     Return the argv vector in "argv" i.e.
     *     	*argv = my_new_argv;
     *     Return the size of the vector in argc
     */
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    if (!(fp = util_fopen_locked(session_file, "w+")))
    {
	fprintf(stderr, "fopen of session file %s failed.\n", session_file);
        return False;
    }

    chmod(session_file, S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP);

    /*
     * Current Project
     */
    proj = proj_get_project();
    if (proj)
    {
	if (proj_name = obj_get_file(proj))
	{
	    fprintf(fp, "%s:%s",
		AB_XRM_CUR_PROJECT, proj_name);
	    curProjWritten = True;
	}
    }

    if (curProjWritten)
    {
	fprintf(fp, "\n");

        /*
         * Shown modules
         */
        for (trav_open(&trav, proj, AB_TRAV_MODULES);
	        (module = trav_next(&trav)) != NULL; )
        {
	    if (obj_has_flag(module, MappedFlag))
	    {
	        if (first)
	        {
	            fprintf(fp, "%s: %s",
			    AB_XRM_SHOWN_MODULES, obj_get_name(module));
		    first = False;
	        }
	        else
	        {
	            fprintf(fp," %s", obj_get_name(module));
	        }
		shownModulesWritten = True;
	    }
        }
    }

    fclose(fp);

    if (curProjWritten | shownModulesWritten)
	ret_value = True;
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
    
    return ret_value;
}


Boolean
Session_restoreCB(Widget widget, char *session_file)
{
    Boolean		ret_value = False;
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    XrmDatabase		db;
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*
     * Restore application state via session file.
     * Use contents of "session file" to bring the application
     * to the desired state.
     * Set "ret_value" to True to indicate success.
     */
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    if ((db = XrmGetFileDatabase (session_file)) != NULL)
    {
	ret_value = True;
        AB_db = db;
    }

    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
    
    return ret_value;
}

void 
cgen_win_help_pulldown_About_Application_Builder_item_CB1(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    DtbAboutBoxDialogInfo	instance = (DtbAboutBoxDialogInfo)clientData;
    
    if (!(instance->initialized))
    {
        dtb_about_box_dialog_initialize(instance, dtb_palette_ab_palette_main.ab_palette_main);
    }
    XtManageChild(instance->dialog_shellform);
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_show_new_proj_dlgCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DTB_MODAL_ANSWER    answer = DTB_ANSWER_NONE;
    ABObj               project = proj_get_project();
    XtAppContext        app;

    app = XtDisplayToApplicationContext(XtDisplay(widget));
    if (proj_check_unsaved_edits(project))
    {
        dtb_proj_create_proj_msg_initialize(&dtb_proj_create_proj_msg);
        answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
                        &dtb_proj_create_proj_msg, NULL, NULL, NULL);
        switch (answer)
        {
            case DTB_ANSWER_ACTION1:
		/* Close out the old project (= destroying
		 * the old project + creating a new default
		 * project named "Untitled"). Then popup the
		 * "Name Project" dialog.
		 */
                proj_destroy_project(project);

		/* Register the workproc that will popup 
		 * the "Name Project" dialog. 
		 */
		XtAppAddWorkProc(app, name_proj_work_proc,
			(XtPointer) NULL);
                break;

            case DTB_ANSWER_NONE:
            case DTB_ANSWER_CANCEL:
                break;
        }
    }                   /* End check unsaved edits */
    else
    {
	proj_destroy_project(project);
	XtAppAddWorkProc(app, name_proj_work_proc,
			(XtPointer) NULL);
    }

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_show_open_chooserCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    ChooserInfo         info = NULL;
    DTB_MODAL_ANSWER    answer = DTB_ANSWER_NONE;
    ABObj		project = proj_get_project();
    static		DtbObjectHelpDataRec chooser_help_data = {
	"",
	"AppBuilder",
	"ABFileSelDialog",
    };
    char		*tmp_txt;
    XmString		ok_label;
    char		*title;

    XtCallbackRec ok_callback[] = {
        {(XtCallbackProc)proj_open_proj_okCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };
    XtCallbackRec cancel_callback[] = {
        {(XtCallbackProc)proj_cancelCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };
    XtCallbackRec popdown_callback[] = {
        {(XtCallbackProc)proj_unmap_chooserCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };
    XtCallbackRec help_callback[] = {
        {(XtCallbackProc)dtb_help_dispatch, (XtPointer) &chooser_help_data},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };

    /* Before loading in the new project, check if
     * there are unsaved edits in the existing project.
     * If so, post a warning and allow the user to
     * cancel the operation.
     */  
    if (proj_check_unsaved_edits(project))
    {
        dtb_proj_open_proj_warn_msg_initialize(
                &dtb_proj_open_proj_warn_msg);
        answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
                &dtb_proj_open_proj_warn_msg,
                NULL, NULL, NULL);

        switch (answer) 
	{
	    case DTB_ANSWER_ACTION1:
		/* Go ahead and destroy the old project. */
		proj_destroy_project(project);
		break;

	    case DTB_ANSWER_CANCEL:
		return;
	}
    }

    /* Create the file chooser if it hasn't already
     * been created by anyone else, then set the
     * appropriate resources.
     */
    if (AB_generic_chooser == NULL)
    {
        AB_generic_chooser = XmCreateFileSelectionDialog(
                widget,
                "AB_generic_chooser",
                (ArgList) NULL,
                (Cardinal) 0);

	info = (ChooserInfo) calloc(sizeof(ChooserInfoRec), 1);
	XtVaSetValues(AB_generic_chooser, 
			XmNuserData, (XtPointer) info, 
			NULL);

	/* Set up help info for shared chooser */
	tmp_txt = catgets(Dtb_project_catd,110,1,"Use the File Selection Dialog to specify which file should be used for saving and loading modules or projects");
	chooser_help_data.help_text = XtMalloc(strlen(tmp_txt)+1);
	strcpy(chooser_help_data.help_text,tmp_txt);
    }
    else if (XtIsManaged(AB_generic_chooser))
    {
	ui_win_front(AB_generic_chooser);
	return;
    }

    XtVaGetValues(AB_generic_chooser,
			XmNuserData, &info,
			NULL);
    info->child = (Widget) NULL;
    info->chooser_type = AB_OPEN_PROJ_CHOOSER;

    ok_label = XmStringCreateLocalized(catgets(Dtb_project_catd, 100, 233, "Open"));
    XtVaSetValues(AB_generic_chooser,
                XmNautoUnmanage, FALSE,
                XtVaTypedArg, XmNpattern,
                        XtRString, "*.bi[px]",
                        sizeof("*.bi[px]"),
                XmNokLabelString, ok_label,
		XmNokCallback, &ok_callback,
                XmNcancelCallback, &cancel_callback,
                XmNhelpCallback, &help_callback,
                NULL);
    XmStringFree(ok_label);

    title = XtNewString(catgets(Dtb_project_catd, 100, 234, "Open Project"));
    XtVaSetValues(XtParent(AB_generic_chooser),
                XmNtitle, title,
		XmNpopdownCallback, &popdown_callback,
                NULL);
    XtFree(title);

    XtManageChild(AB_generic_chooser);
    ui_win_front(AB_generic_chooser);

    /* Set File and Project Organizer Project and Module menu 
     * items inactive, until this file chooser is dismissed.
     */ 
    pal_set_File_menu(AB_OPEN_PROJ_CHOOSER, FALSE); 
    proj_set_menus(AB_OPEN_PROJ_CHOOSER, FALSE);
 

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_save_projCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    proj_save_needed(NULL);

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_show_save_proj_as_chooserCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    proj_show_save_proj_as_chooser(widget, NULL);

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_show_new_module_dlgCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    proj_show_name_dlg(NULL, dtb_get_toplevel_widget());

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_close_projCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DTB_MODAL_ANSWER    answer = DTB_ANSWER_NONE;
    ABObj		project = proj_get_project();

    if (proj_check_unsaved_edits(project))
    {
        dtb_proj_close_proj_msg_initialize(&dtb_proj_close_proj_msg);
        answer = dtb_show_modal_message(dtb_get_toplevel_widget(),
                        &dtb_proj_close_proj_msg, NULL, NULL, NULL);
        switch (answer)
        {
            case DTB_ANSWER_ACTION1:
		/* Set the mouse pointer to the stopwatch */
		ab_set_busy_cursor(TRUE);
		ui_sync_display_of_widget(AB_toplevel);

		/* Go ahead and destroy the old project
		 * and create a new default project named
		 * "Untitled".
		 */
		proj_destroy_project(project);

		/* Reset the mouse pointer. */
		ab_set_busy_cursor(FALSE);
                break;

            case DTB_ANSWER_NONE:
            case DTB_ANSWER_CANCEL:
                break;
        }
    }
    else
    {
	ab_set_busy_cursor(TRUE);
	ui_sync_display_of_widget(AB_toplevel);
	proj_destroy_project(project);
	ab_set_busy_cursor(FALSE);
    }

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}

void 
proj_show_import_chooserCB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    Widget                      import_rbox = NULL;
    ChooserInfo            	info = NULL;
    XmString			ok_label;
    char			*title;

    XtCallbackRec ok_callback[] = {
        {(XtCallbackProc)proj_import_okCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };
    XtCallbackRec cancel_callback[] = {
        {(XtCallbackProc)proj_cancelCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };
    XtCallbackRec popdown_callback[] = {
        {(XtCallbackProc)proj_unmap_chooserCB, (XtPointer) NULL},
        {(XtCallbackProc) NULL, (XtPointer) NULL}
    };

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/

    /* Create the file chooser if it hasn't already
     * been created by anyone else, then set the
     * appropriate resources.
     */
    if (AB_generic_chooser == NULL)
    {  
        AB_generic_chooser = XmCreateFileSelectionDialog(
                widget,
                "AB_generic_chooser",
                (ArgList) NULL,
                (Cardinal) 0);
 
        info = (ChooserInfo)calloc(sizeof(ChooserInfoRec), 1);
        XtVaSetValues(AB_generic_chooser,
                        XmNuserData, (XtPointer) info,
                        NULL);
    }
    else if (XtIsManaged(AB_generic_chooser))
    {
        ui_win_front(AB_generic_chooser);
        return;
    }

    XtVaGetValues(AB_generic_chooser,
                        XmNuserData, &info,
                        NULL);

    /* Create the Import by Reference/Copy exclusive choice */
    import_rbox = create_import_rbox(AB_generic_chooser);
 
    info->child = import_rbox;
    info->chooser_type = AB_IMPORT_CHOOSER;
    info->ImportAsBil = TRUE;
    info->ImportByCopy = TRUE;
 
    ok_label = XmStringCreateLocalized(catgets(Dtb_project_catd, 100, 235, "Import"));
    XtVaSetValues(AB_generic_chooser,
                XmNautoUnmanage, FALSE,
                XtVaTypedArg, XmNpattern,
                        XtRString, "*.bil",
                        sizeof("*.bil"),
                XmNokLabelString, ok_label,
                XmNokCallback, &ok_callback,
                XmNcancelCallback, &cancel_callback,
                NULL);  
    XmStringFree(ok_label);
 
    title = XtNewString(catgets(Dtb_project_catd, 100, 236, "Import File"));
    XtVaSetValues(XtParent(AB_generic_chooser),
                XmNtitle, title,
                XmNpopdownCallback, &popdown_callback,
                NULL);
    XtFree(title);
 
    XtManageChild(AB_generic_chooser);
    ui_win_front(AB_generic_chooser);
 
    /* Set File and Project Organizer Project and Module menu
     * items inactive, until this file chooser is dismissed.
     */
    pal_set_File_menu(AB_IMPORT_CHOOSER, FALSE);
    proj_set_menus(AB_IMPORT_CHOOSER, FALSE);

    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}



/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All automatically-generated data and functions have been defined.
 ***
 *** Add new functions here, or at the top of the file.
 ***/

static Boolean
name_proj_work_proc(
    XtPointer	clientData
)
{
    proj_name_proj();
    return True;
}

static void
exit_dtbuilder(int param)
{
    struct sigaction	exit_action;
    struct sigaction	ign_action;
    param = param;		/* avoid warning */

    ign_action.sa_handler = SIG_IGN;
    ign_action.sa_flags = 0;
    sigemptyset(&(ign_action.sa_mask));
    
    /* While we're in the signal handler, ignore
     * the following signals.  We don't want them
     * to queue up and then cause the "Unsaved
     * edits" dialog to be posted repeatedly, after
     * exiting the signal handler.
     */
    sigaction(SIGINT, &ign_action, &exit_action);
    sigaction(SIGHUP, &ign_action, &exit_action);
    sigaction(SIGQUIT, &ign_action, &exit_action);
    sigaction(SIGTERM, &ign_action, &exit_action);

    ab_exit_dtbuilder();

    /* Re-install the old signal handler (this function)
     * after the user has responded to the "unsaved edits"
     * dialog.
     */
    sigaction(SIGINT, &exit_action, NULL);
    sigaction(SIGHUP, &exit_action, NULL);
    sigaction(SIGQUIT, &exit_action, NULL);
    sigaction(SIGTERM, &exit_action, NULL);
}

static void
reloadDB(
    XtPointer clientData
)
{

   /* Read in the new databases */
   DtDbLoad();
}

static int
parse_help_option(
    int		argc, 
    char	*argv[]
)
{
    int                 iReturn = 0;
    int                 argCount = 0;

    for (argCount = 1; argCount < argc; ++argCount)
    {
        char               *arg = argv[argCount];
        if (*arg == '-')
        {
	    if ((strcmp(arg, "-help") == 0) || 
	        (strcmp(arg, "-h") == 0))
            {
                ab_usage();
            }
        }                       /* ! flag arg */
    } /* for argCount */


    return iReturn;
}

/*
 * Print usage message
 */
static void
ab_usage(
)
{
    char *program_name_string = util_get_program_name();

    fprintf(stderr,"\n");
    fprintf(stderr,
       catgets(Dtb_project_catd, 100, 269,
"Usage: %s [options] [project-file | module-file]\n\n"), 
	program_name_string);

    fprintf(stderr, catgets(Dtb_project_catd, 100, 270,
"Options:\n"));
    fprintf(stderr, catgets(Dtb_project_catd, 100, 271,
"  -help (-h)        Print out this help message\n"));

    exit(1);
    return;
}


/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/


