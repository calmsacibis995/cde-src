/* $XConsortium: pathcanon.c /main/cde1_maint/1 1995/07/18 00:03:09 drk $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*        THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF        *
*                    AT&T BELL LABORATORIES                    *
*         AND IS NOT TO BE DISCLOSED OR USED EXCEPT IN         *
*            ACCORDANCE WITH APPLICABLE AGREEMENTS             *
*                                                              *
*          Copyright (c) 1994 AT&T Bell Laboratories           *
*              Unpublished & Not for Publication               *
*                     All Rights Reserved                      *
*                                                              *
*       The copyright notice above does not evidence any       *
*      actual or intended publication of such source code      *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                   advsoft@research.att.com                   *
*                 Randy Hackbarth 908-582-5245                 *
*                  Dave Belanger 908-582-7427                  *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#line 1

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif

#line 22
#include <ast.h>
#include <ls.h>
#include <fs3d.h>
#include <errno.h>

#ifndef errno
extern __MANGLE__ int		errno;
#endif

char*
pathcanon __PARAM__((char* path, int flags), (path, flags)) __OTORP__(char* path; int flags;)
#line 33
{
	register char*	p;
	register char*	r;
	register char*	s;
	register char*	t;
	register int	dots;
	int		loop;
	int		oerrno;
#if defined(FS_3D)
	long		visits = 0;
#endif

	oerrno = errno;
	dots = loop = 0;
	p = r = s = t = path;
	for (;;) switch (*t++ = *s++)
	{
	case '.':
		dots++;
		break;
	case 0:
		s--;
		/*FALLTHROUGH*/
	case '/':
		while (*s == '/') s++;
		switch (dots)
		{
		case 1:
			t -= 2;
			break;
		case 2:
			if ((flags & (PATH_DOTDOT|PATH_EXISTS)) == PATH_DOTDOT)
			{
				struct stat	st;

				*(t - 2) = 0;
				if (stat(path, &st))
				{
					strcpy(path, s);
					return(0);
				}
				*(t - 2) = '.';
			}
#if PRESERVE_TRAILING_SLASH
			if (t - 5 < r) r = t;
#else
			if (t - 5 < r)
			{
				if (t - 4 == r) t = r + 1;
				else r = t;
			}
#endif
			else for (t -= 5; t > r && *(t - 1) != '/'; t--);
			break;
		case 3:
#if defined(FS_3D)
			{
				char*		x;
				char*		o;
				int		c;

				o = t;
				if ((t -= 5) <= path) t = path + 1;
				c = *t;
				*t = 0;
				if (x = pathnext(path, s - (*s != 0), &visits))
				{
					r = path;
					if (t == r + 1) x = r;
					s = t = x;
				}
				else
				{
					*t = c;
					t = o;
				}
			}
#else
			r = t;
#endif
			break;
		default:
			if ((flags & PATH_PHYSICAL) && loop < 32 && (t - 1) > path)
			{
				int	c;
				char	buf[PATH_MAX];

				c = *(t - 1);
				*(t - 1) = 0;
				dots = getsymlink(path, buf, sizeof(buf));
				*(t - 1) = c;
				if (dots > 0)
				{
					loop++;
					strcpy(buf + dots, s - (*s != 0));
					if (*buf == '/') p = r = path;
					s = t = p;
					strcpy(p, buf);
				}
				else if (dots < 0 && errno == ENOENT)
				{
					if (flags & PATH_EXISTS)
					{
						strcpy(path, s);
						return(0);
					}
					flags &= ~(PATH_PHYSICAL|PATH_DOTDOT);
				}
				dots = 4;
			}
			break;
		}
		if (dots >= 4 && (flags & PATH_EXISTS) && (t > path + 1 || t > path && *(t - 1) && *(t - 1) != '/'))
		{
			struct stat	st;

			*(t - 1) = 0;
			if (stat(path, &st))
			{
				strcpy(path, s);
				return(0);
			}
			if (*s) *(t - 1) = '/';
		}
		if (!*s)
		{
			if (t > path && !*(t - 1)) t--;
			if (t == path) *t++ = '.';
#if DONT_PRESERVE_TRAILING_SLASH
			else if (t > path + 1 && *(t - 1) == '/') t--;
#else
			else if ((s <= path || *(s - 1) != '/') && t > path + 1 && *(t - 1) == '/') t--;
#endif
			*t = 0;
			errno = oerrno;
			return(t);
		}
		dots = 0;
		p = t;
		break;
	default:
		dots = 4;
		break;
	}
}
