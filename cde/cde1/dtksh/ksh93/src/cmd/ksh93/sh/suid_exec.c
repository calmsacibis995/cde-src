/* $XConsortium: suid_exec.c /main/cde1_maint/3 1995/10/14 00:15:26 montyb $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*        THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF        *
*                    AT&T BELL LABORATORIES                    *
*         AND IS NOT TO BE DISCLOSED OR USED EXCEPT IN         *
*            ACCORDANCE WITH APPLICABLE AGREEMENTS             *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*              Unpublished & Not for Publication               *
*                     All Rights Reserved                      *
*                                                              *
*       The copyright notice above does not evidence any       *
*      actual or intended publication of such source code      *
*                                                              *
*               This software was created by the               *
*           Advanced Software Technology Department            *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                    {research,attmail}!dgk                    *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include	<ast.h>
#include	"FEATURE/externs"
#include	<ls.h>
#include	<sig.h>
#include	<error.h>

#define SPECIAL		04100	/* setuid execute only by owner */
#define FDIN		10	/* must be same as /dev/fd below */
#define FDSYNC		11	/* used on sys5 to synchronize cleanup */
#define FDVERIFY	12	/* used to validate /tmp process */
#define BLKSIZE		sizeof(char*)*1024
#define THISPROG	SUIDEXECPATH
#define DEFSHELL	"/bin/sh"

static void error_exit __PROTO__((const char*));
static int in_dir __PROTO__((const char*, const char*));
static int endsh __PROTO__((const char*));
#ifndef _lib_setreuid
    static int mycopy __PROTO__((int, int));
    static void maketemp __PROTO__((char*));
#endif /* _lib_setreuid */

static const char version[]	= "\n@(#)suid_exec 12/28/93\n";
static const char badopen[]	= "cannot open";
static const char badexec[]	= "cannot exec";
static const char devfd[]	= "/dev/fd/10";	/* must match FDIN above */
static char tmpname[]		= "/tmp/SUIDXXXXXX";
static char **arglist;

static char *shell;
static char *command;
static uid_t ruserid;
static uid_t euserid;
static gid_t rgroupid;
static gid_t egroupid;
static struct stat statb;

main __PARAM__((int argc,char *argv[]), (argc, argv)) __OTORP__(int argc;char *argv[];){
	register int m,n;
	register char *p;
	struct stat statx;
	int mode;
	uid_t effuid;
	gid_t effgid;
	NOT_USED(argc);
	arglist = argv;
	if((command = argv[1]) == 0)
		error_exit(badexec);
	ruserid = getuid();
	euserid = geteuid();
	rgroupid = getgid();
	egroupid = getegid();
	p = argv[0];
#ifndef _lib_setreuid
	maketemp(tmpname);
	if(strcmp(p,tmpname)==0)
	{
		/* At this point, the presumption is that we are the
		 * version of THISPROG copied into /tmp, with the owner,
		 * group, and setuid/gid bits correctly set.  This copy of
		 * the program is executable by anyone, so we must be careful
		 * not to allow just any invocation of it to succeed, since
		 * it is setuid/gid.  Validate the proper execution by
		 * examining the FDVERIFY file descriptor -- if it is owned
		 * by root and is mode SPECIAL, then this is proof that it was
		 * passed by a program with superuser privileges -- hence we
		 * can presume legitimacy.  Otherwise, bail out, as we suspect
		 * an impostor.
		 */
		if(fstat(FDVERIFY,&statb) < 0 || statb.st_uid != 0 ||
		    (statb.st_mode & ~S_IFMT) != SPECIAL || close(FDVERIFY)<0)
			error_exit(badexec);
		/* This enables the grandchild to clean up /tmp file */
		close(FDSYNC);
		/* Make sure that this is a valid invocation of the clone.
		 * Perhaps unnecessary, given FDVERIFY, but what the heck...
		 */
		if(stat(tmpname,&statb) < 0 || statb.st_nlink != 1 ||
		    !S_ISREG(statb.st_mode))
			error_exit(badexec);
		if(ruserid != euserid &&
		  ((statb.st_mode & S_ISUID) == 0 || statb.st_uid != euserid))
			error_exit(badexec);
		goto exec;
	}
	/* Make sure that this is the real setuid program, not the clone.
	 * It is possible by clever hacking to get past this point in the
	 * clone, but it doesn't do the hacker any good that I can see.
	 */
	if(euserid)
		error_exit(badexec);
#endif /* _lib_setreuid */
	/* Open the script for reading first and then validate it.  This
	 * prevents someone from pulling a switcheroo while we are validating.
	 */
	n = open(p,0);
	if(n == FDIN)
	{
		n = dup(n);
		close(FDIN);
	}
	if(n < 0)
		error_exit(badopen);
	/* validate execution rights to this script */
	if(fstat(FDIN,&statb) < 0 || (statb.st_mode & ~S_IFMT) != SPECIAL)
		euserid = ruserid;
	else
		euserid = statb.st_uid;
	/* do it the easy way if you can */
	if(euserid == ruserid && egroupid == rgroupid)
	{
		if(access(p,X_OK) < 0)
			error_exit(badexec);
	}
	else
	{
		/* have to check access on each component */
		while(*p++)
		{
			if(*p == '/' || *p == 0)
			{
				m = *p;
				*p = 0;
				if(eaccess(argv[0],X_OK) < 0)
					error_exit(badexec);
				*p = m;
			}
		}
		p = argv[0];
	}
	if(fstat(n, &statb) < 0 || !S_ISREG(statb.st_mode))
		error_exit(badopen);
	if(stat(p, &statx) < 0 ||
	  statb.st_ino != statx.st_ino || statb.st_dev != statx.st_dev)
		error_exit(badexec);
	if(stat(THISPROG, &statx) < 0 ||
	  (statb.st_ino == statx.st_ino && statb.st_dev == statx.st_dev))
		error_exit(badexec);
	close(FDIN);
	if(fcntl(n,F_DUPFD,FDIN) != FDIN)
		error_exit(badexec);
	close(n);

	/* compute the desired new effective user and group id */
	effuid = euserid;
	effgid = egroupid;
	mode = 0;
	if(statb.st_mode & S_ISUID)
		effuid = statb.st_uid;
	if(statb.st_mode & S_ISGID)
		effgid = statb.st_gid;

	/* see if group needs setting */
	if(effgid != egroupid)
		if(effgid != rgroupid || setgid(rgroupid) < 0)
			mode = S_ISGID;
		
	/* now see if the uid needs setting */
	if(mode)
	{
		if(effuid != ruserid)
			mode |= S_ISUID;
	}
	else if(effuid)
	{
		if(effuid != ruserid || setuid(ruserid) < 0)
			mode = S_ISUID;
	}
		
	if(mode)
		setids(mode, effuid, effgid);
exec:
	/* only use SHELL if file is in trusted directory and ends in sh */
	shell = getenv("SHELL");
	if(shell == 0 || !endsh(shell) || (
                !in_dir(CDE_INSTALLATION_TOP"/bin",shell) &&
		!in_dir("/bin",shell) &&
		!in_dir("/usr/bin",shell) &&
		!in_dir("/usr/lbin",shell) &&
		!in_dir("/usr/local/bin",shell)))
			shell = DEFSHELL;
	argv[0] = command;
	argv[1] = (char*)devfd;
	execv(shell,argv);
	error_exit(badexec);
}

/*
 * return true of shell ends in sh
 */

static int endsh __PARAM__((register const char *shell), (shell)) __OTORP__(register const char *shell;){
	while(*shell)
		shell++;
	if(*--shell != 'h' || *--shell != 's')
		return(0);
	return(1);
}


/*
 * return true of shell is in <dir> directory
 */

static int in_dir __PARAM__((register const char *dir,register const char *shell), (dir, shell)) __OTORP__(register const char *dir;register const char *shell;){
	while(*dir)
	{
		if(*dir++ != *shell++)
			return(0);
	}
	/* return true if next character is a '/' */
	return(*shell=='/');
}

static void error_exit __PARAM__((const char *message), (message)) __OTORP__(const char *message;){
	sfprintf(sfstdout,"%s: %s\n",command,message);
	exit(126);
}


/*
 * This version of access checks against effective uid and effective gid
 */

eaccess __PARAM__((register const char *name, register int mode), (name, mode)) __OTORP__(register const char *name; register int mode;){	
	struct stat statb;
	if (stat(name, &statb) == 0)
	{
		if(euserid == 0)
		{
			if(!S_ISREG(statb.st_mode) || mode != 1)
				return(0);
		    	/* root needs execute permission for someone */
			mode = (S_IXUSR|S_IXGRP|S_IXOTH);
		}
		else if(euserid == statb.st_uid)
			mode <<= 6;
		else if(egroupid == statb.st_gid)
			mode <<= 3;
#ifdef _lib_getgroups
		/* on some systems you can be in several groups */
		else
		{
			static int maxgroups;
			gid_t *groups; 
			register int n;
			if(maxgroups==0)
			{
				/* first time */
				if((maxgroups=getgroups(0,groups)) < 0)
				{
					/* pre-POSIX system */
					maxgroups=NGROUPS_MAX;
				}
			}
			groups = (gid_t*)malloc((maxgroups+1)*sizeof(gid_t));
			n = getgroups(maxgroups,groups);
			while(--n >= 0)
			{
				if(groups[n] == statb.st_gid)
				{
					mode <<= 3;
					break;
				}
			}
		}
#endif /* _lib_getgroups */
		if(statb.st_mode & mode)
			return(0);
	}
	return(-1);
}

#ifdef _lib_setreuid
setids __PARAM__((int mode,int owner,int group), (mode, owner, group)) __OTORP__(int mode;int owner;int group;){
	if(mode & S_ISGID)
		setregid(rgroupid,group);

	/* set effective uid even if S_ISUID is not set.  This is because
	 * we are *really* executing EUID root at this point.  Even if S_ISUID
	 * is not set, the value for owner that is passsed should be correct.
	 */
	setreuid(ruserid,owner);
}

#else
/*
 * This version of setids creats a /tmp file and copies itself into it.
 * The "clone" file is made executable with appropriate suid/sgid bits.
 * Finally, the clone is exec'ed.  This file is unlinked by a grandchild
 * of this program, who waits around until the text is free.
 */

setids __PARAM__((int mode,uid_t owner,gid_t group), (mode, owner, group)) __OTORP__(int mode;uid_t owner;gid_t group;){
	register int n,m;
	int pv[2];

	/*
	 * Create a token to pass to the new program for validation.
	 * This token can only be procured by someone running with an
	 * effective userid of root, and hence gives the clone a way to
	 * certify that it was really invoked by THISPROG.  Someone who
	 * is already root could spoof us, but why would they want to?
	 *
	 * Since we are root here, we must be careful:  What if someone
	 * linked a valuable file to tmpname?
	 */
	unlink(tmpname);	/* should normally fail */
#ifdef O_EXCL
	if((n = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, SPECIAL)) < 0 ||
		unlink(tmpname) < 0)
#else
	if((n = creat(tmpname, SPECIAL)) < 0 || unlink(tmpname) < 0)
#endif
		error_exit(badexec);
	if(n != FDVERIFY)
	{
		close(FDVERIFY);
		if(fcntl(n,F_DUPFD,FDVERIFY) != FDVERIFY)
			error_exit(badexec);
	}
	mode |= S_IEXEC|(S_IEXEC>>3)|(S_IEXEC>>6);
	/* create a pipe for synchronization */
	if(pipe(pv) < 0)
		error_exit(badexec);
	if((n=fork()) == 0)
	{	/* child */
		close(FDVERIFY);
		close(pv[1]);
		if((n=fork()) == 0)
		{	/* grandchild -- cleans up clone file */
			signal(SIGHUP, SIG_IGN);
			signal(SIGINT, SIG_IGN);
			signal(SIGQUIT, SIG_IGN);
			signal(SIGTERM, SIG_IGN);
			read(pv[0],pv,1); /* wait for clone to close pipe */
			while(unlink(tmpname) < 0 && errno == ETXTBSY)
				sleep(1);
			exit(0);
	    	}
		else if(n == -1)
			exit(1);
		else
		{
			/* Create a set[ug]id file that will become the clone. 
			 * To make this atomic, without need for chown(), the
			 * child takes on desired user and group.  The only
			 * downsize of this that I can see is that it may
			 * screw up some per- * user accounting.
			 */
			if((m = open(THISPROG, O_RDONLY)) < 0)
				exit(1);
			if((mode & S_ISGID) && setgid(group) < 0)
				exit(1);
			if((mode & S_ISUID) && owner && setuid(owner) < 0)
				exit(1);
#ifdef O_EXCL
			if((n = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, mode)) < 0)
#else
			unlink(tmpname);
			if((n = creat(tmpname, mode)) < 0)
#endif /* O_EXCL */
				exit(1);
			/* populate the clone */
			m = mycopy(m,n);
			if(chmod(tmpname,mode) <0)
				exit(1);
			exit(m);
		}
	}
	else if(n == -1)
		error_exit(badexec);
	else
	{
		arglist[0] = (char*)tmpname;
		close(pv[0]);
		/* move write end of pipe into FDSYNC */
		if(pv[1] != FDSYNC)
		{
			close(FDSYNC);
			if(fcntl(pv[1],F_DUPFD,FDSYNC) != FDSYNC)
				error_exit(badexec);
		}
		/* wait for child to die */
		while((m = wait(0)) != n)
			if(m == -1 && errno != EINTR)
				break;
		/* Kill any setuid status at this point.  That way, if the
		 * clone is not setuid, we won't exec it as root.  Also, don't
		 * neglect to consider that someone could have switched the
		 * clone file on us.
		 */
		if(setuid(ruserid) < 0)
			error_exit(badexec);
		execv(tmpname,arglist);
		error_exit(badexec);
	}
}

/*
 * create a unique name into the <template>
 */

static void maketemp __PARAM__((char *template), (template)) __OTORP__(char *template;){
	register char *cp = template;
	register pid_t n = getpid();
	/* skip to end of string */
	while(*++cp);
	/* convert process id to string */
	while(n > 0)
	{
		*--cp = (n%10) + '0';
		n /= 10;
	}
	
}

/*
 *  copy THISPROG into the open file number <fdo> and close <fdo>
 */

static int mycopy __PARAM__((int fdi, int fdo), (fdi, fdo)) __OTORP__(int fdi; int fdo;){
	char buffer[BLKSIZE];
	register int n;

	while((n = read(fdi,buffer,BLKSIZE)) > 0)
		if(write(fdo,buffer,n) != n)
			break;
	close(fdi);
	close(fdo);
	return n;
}

#endif /* _lib_setreuid */


