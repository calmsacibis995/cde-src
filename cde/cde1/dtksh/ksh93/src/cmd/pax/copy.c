/* $XConsortium: copy.c /main/cde1_maint/3 1995/10/14 00:21:06 montyb $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*         THIS IS PROPRIETARY SOURCE CODE LICENSED BY          *
*                          AT&T CORP.                          *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*                     All Rights Reserved                      *
*                                                              *
*           This software is licensed by AT&T Corp.            *
*       under the terms and conditions of the license in       *
*       http://www.research.att.com/orgs/ssr/book/reuse        *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                     gsf@research.att.com                     *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#include "pax.h"

/*
 * copy files in from archive
 */

void
copyin __PARAM__((register Archive_t* ap), (ap)) __OTORP__(register Archive_t* ap;){
	register File_t*	f = &ap->file;

	deltabase(ap);
	while (getprologue(ap))
	{
		while (getheader(ap, f))
		{
			if (selectfile(ap, f)) filein(ap, f);
			else fileskip(ap, f);
			gettrailer(ap, f);
		}
		getepilogue(ap);
	}
	deltaverify(ap);
}

/*
 * copy a single file out to the archive
 * called by ftwalk()
 */

int
copyout __PARAM__((register Ftw_t* ftw), (ftw)) __OTORP__(register Ftw_t* ftw;){
	register Archive_t*	ap = state.out;
	register File_t*	f = &ap->file;

	if (getfile(ap, f, ftw))
	{
		if (selectfile(ap, f) && (!state.verify || verify(ap, f)))
		{
			f->fd = openin(ap, f);
			deltaout(NiL, ap, f);
		}
		else ftw->status = FTW_SKIP;
	}
	return(0);
}

/*
 * fileout() record support
 */

static void
recordout __PARAM__((Archive_t* ap, File_t* f, Sfio_t* fp), (ap, f, fp)) __OTORP__(Archive_t* ap; File_t* f; Sfio_t* fp;){
	register int	c;
	register char*	p;
	register char*	recdat;
	register char*	blkdat;
	char*		rec;
	char*		blk;
	int		span;

	int		count = 0;
	int		partial = 0;
	int		truncated = 0;

	static char	span_out[] = "0132";
	static char*	pardat;

	if (!fp) error(3, "cannot handle record output from buffer");
	ap->record = f;
	f->record.blocks = 0;
	span = 0;
	blk = state.tmp.buffer;

	/*
	 * file loop
	 */

	for (;;)
	{
		p = blk;
		switch (state.record.format)
		{
		case 'V':
			p += 4;
			break;
		}
		blkdat = p;

		/*
		 * block loop
		 */

		for (;;)
		{
			rec = p;
			switch (state.record.format)
			{
			case 'D':
			case 'V':
				p += 4;
				break;
			case 'S':
				p += 5;
				break;
			}
			recdat = p;

			/*
			 * check for partial record from previous block
			 */

			if (partial)
			{
				memcpy(recdat, pardat, partial);
				p += partial;
				partial = 0;
			}

			/*
			 * record loop
			 */

			span &= 01;
			span <<= 1;
			for (;;)
			{
				if (p >= &rec[state.record.size] && state.record.size)
				{
					if (state.record.line)
					{
						truncated++;
						while ((c = sfgetc(fp)) != EOF && c != '\n');
					}
					break;
				}
				else if (p >= &blk[state.blocksize])
				{
					if (state.record.format == 'S' || state.record.format == 'V')
					{
						if (p > recdat)
						{
							span |= 01;
							break;
						}
					}
					else if (partial = p - recdat)
					{
						/*
						 * save partial record for next block
						 */

						if (!pardat && !(pardat = newof(0, char, state.blocksize, 0)))
							error(3, "out of space [record pushback buffer]");
						memcpy(pardat, recdat, partial);
					}
					p = rec;
					goto eob;
				}
				else if ((c = sfgetc(fp)) == EOF)
				{
					if (p == recdat)
					{
						if (rec == blkdat) goto eof;
						p = rec;
						goto eob;
					}
					break;
				}
				else if (c == '\n' && state.record.line) break;
				else *p++ = c;
			}
			switch (state.record.format)
			{
			case 'D':
				c = recdat[0];
				sfsprintf(rec, 4, "%04d", p - rec);
				recdat[0] = c;
				break;
			case 'F':
				if (c != EOF || state.record.pad)
				{
					memset(p, ' ', state.record.size - (p - rec));
					p = rec + state.record.size;
				}
				break;
			case 'S':
				c = recdat[0];
				sfsprintf(rec, 4, "%c%04d", span_out[span], p - rec);
				recdat[0] = c;
				break;
			case 'U':
				if (p == recdat) *p++ = ' ';
				break;
			case 'V':
				rec[0] = ((p - rec) >> 8) & 0xff;
				rec[1] = (p - rec) & 0xff;
				rec[2] = span;
				rec[3] = 0;
				break;
			}
			if (state.record.charset && ap->format == IBMAR) mematoe(recdat, recdat, p - recdat);
			count++;
			if (p >= &blk[state.blocksize] || state.record.format == 'U') break;
		}
	eob:
		switch (state.record.format)
		{
		case 'D':
		case 'S':
			if (state.record.pad)
			{
				memset(p, '^', state.blocksize - (p - blk));
				p = blk + state.blocksize;
			}
			break;
		case 'V':
			blk[0] = ((p - blk) >> 8) & 0xff;
			blk[1] = (p - blk) & 0xff;
			blk[2] = 0;
			blk[3] = 0;
			break;
		}
		bwrite(ap, blk, p - blk);
		f->record.blocks++;
	}
 eof:
	ap->record = 0;
	if (truncated) error(1, "%s: %d out of %d record%s truncated", f->name, truncated, count, count == 1 ? "" : "s");
}

/*
 * low level for copyout()
 * if rfd<0 && st_size>0 then input from bread()
 */

void
fileout __PARAM__((register Archive_t* ap, register File_t* f), (ap, f)) __OTORP__(register Archive_t* ap; register File_t* f;){
	register int	n;
	register long	c;
	int		err;
	Buffer_t*	bp;
	Sfio_t*		rfp;

	if (f->delta.op == DELTA_verify)
	{
		ap->selected--;
		if (f->fd >= 0) close(f->fd);
	}
	else
	{
		putheader(ap, f);
		switch (ap->format)
		{
		case ALAR:
		case IBMAR:
			if (ap->io.blocked)
			{
				if (f->st->st_size > 0)
				{
					if (state.record.format == 'F' && !state.record.line)
					{
						/*
						 * this is faster than recordout()
						 */

						ap->record = f;
						err = 0;
						c = f->st->st_size;
						while (c > 0)
						{
							n = c > state.record.size ? state.record.size : c;

							/*
							 * NOTE: we expect that all but the last
							 *	 read returns state.record.size
							 *	 if not the the intermediate short
							 *	 reads are filled with 0's
							 */

							if (!err)
							{
								if (f->fd >= 0) n = read(f->fd, state.tmp.buffer, n);
								else if (bp = getbuffer(f->fd))
								{
									memcpy(ap->io.next, bp->next, n);
									bp->next += n;
								}
								else if (bread(f->ap, state.tmp.buffer, 0L, (long)n, 1) <= 0) n = -1;
							}
							if (n <= 0)
							{
								if (n) error(ERROR_SYSTEM|2, "%s: read error", f->path);
								else error(2, "%s: file size changed", f->path);
								memzero(state.tmp.buffer, state.record.size);
								err = 1;
							}
							else
							{
								c -= n;
								if (n < state.record.size && (c > 0 || state.record.pad))
								{
									memzero(state.tmp.buffer + n, state.record.size - n);
									n = state.record.size;
								}
								bwrite(ap, state.tmp.buffer, n);
							}
						}
						ap->record = 0;
						if (f->fd >= 0) close(f->fd);
					}
					else if (f->fd < 0) recordout(ap, f, NiL);
					else if (!(rfp = sfnew(NiL, NiL, SF_UNBOUND, f->fd, SF_READ)))
					{
						error(1, "%s: cannot read", f->path);
						close(f->fd);
					}
					else
					{
						recordout(ap, f, rfp);
						sfclose(rfp);
					}
				}
				break;
			}
			/*FALLTHROUGH*/
		default:
			err = 0;
			c = f->st->st_size;
			while (c > 0)
			{
				n = c > state.buffersize ? state.buffersize : c;
				if (!err)
				{
					if (f->fd >= 0) n = read(f->fd, ap->io.next, n);
					else if (bp = getbuffer(f->fd))
					{
						memcpy(ap->io.next, bp->next, n);
						bp->next += n;
					}
					else if (bread(f->ap, ap->io.next, 0L, (long)n, 1) <= 0) n = -1;
				}
				if (n <= 0)
				{
					if (n) error(ERROR_SYSTEM|2, "%s: read error", f->path);
					else error(2, "%s: file size changed", f->path);
					memzero(ap->io.next, state.buffersize);
					err = 1;
				}
				else
				{
					c -= n;
					bput(ap, n);
				}
			}
			if (f->fd >= 0) close(f->fd);
			break;
		}
		puttrailer(ap, f);
	}
	if (state.acctime && f->type != X_IFLNK)
		settime(f->name, f->st->st_atime, f->st->st_mtime);
}

/*
 * filein() record support
 */

static void
recordin __PARAM__((register Archive_t* ap, register File_t* f, int wfd), (ap, f, wfd)) __OTORP__(register Archive_t* ap; register File_t* f; int wfd;){
	register long			n;
	register long			size;
	int				c;
	int				i;
	int				j;
	int				k;
	int				nl;
	long				m;
	Sfio_t*				wfp;

	if (wfd < 0) wfp = 0;
	else if (!(wfp = sfnew(NiL, NiL, SF_UNBOUND, wfd, SF_WRITE)))
		error(1, "%s: cannot write", f->name);
	ap->io.empty = 0;
	nl = state.record.line;
	size = 0;
	for (;;)
	{
		if (ap->io.blocked) n = bread(ap, state.tmp.buffer, 0L, (long)state.buffersize, 0);
		else if ((m = f->st->st_size - size) <= 0) n = 0;
		else if (wfp) 
		{
			if (m > state.buffersize) m = state.buffersize;
			n = bread(ap, state.tmp.buffer, 0L, m, 1);
		}
		else n = bread(ap, NiL, 0L, m, 1);
		if (n < 0) break;
		if (n == 0)
		{
			k = 1;
			ap->sum--;
			while (getlabel(ap, f))
			{
				if (strneq(alar_header, "EOV1", 4)) k = 0;
				else if (!strneq(alar_header, "EOF", 3) && !strneq(alar_header, "EOV", 3) && !strneq(alar_header, "UTL", 3) && ++n >= 16 && !state.keepgoing)
					error(3, "%s: %s: %d invalid %s end of file/volume labels detected", ap->name, f->name, n, format[ap->format].name);
			}
			if (n) error(1, "%s: %s: %d invalid %s end of file/volume labels detected", ap->name, f->name, n, format[ap->format].name);
			if (k)
			{
				ap->sum++;
				break;
			}
			f->record.section++;
			f->id = strcpy(state.tmp.buffer, f->id);
			f->name = strcpy(state.tmp.buffer + ALAR_NAMESIZE + 1, f->name);
			for (;;)
			{
				newio(ap, 0, 0);
				if (getprologue(ap))
				{
					File_t		v;
					struct stat	st;

					v.st = &st;
					if (getheader(ap, &v))
					{
						if (streq(f->id, v.id) && streq(f->name, v.name) && f->record.section == v.record.section)
						{
							f->id = v.id;
							f->name = v.name;
							break;
						}
						error(1, "volume containing %s id %s section %d required", f->name, f->id, f->record.section);
					}
					ap->volume--;
				}
				ap->part--;
			}
			ap->sum++;
			continue;
		}
		if (f->record.format == 'V')
		{
			if ((k = ((unsigned char*)state.tmp.buffer)[0] << 8 | ((unsigned char*)state.tmp.buffer)[1]) != n)
				error(3, "%s: invalid %s V format block descriptor [%d!=%d]", f->name, format[ap->format].name, k, n);
			i = 4;
		}
		else i = 0;
		while (i < n)
		{
			i += state.record.offset;
			if (state.tmp.buffer[i] == '^') switch (f->record.format)
			{
			case 'F':
				if (ap->format == IBMAR) break;
				for (j = i; j < n && state.tmp.buffer[j] == '^'; j++);
				if (j < n) break;
				/*FALLTHROUGH*/
			case 'D':
			case 'S':
				i = n;
				continue;
			}

			/*
			 * get record size
			 */

			switch (f->record.format)
			{
			case 'D':
				if (sscanf(&state.tmp.buffer[i], "%4d", &k) != 1) k = -1;
				j = i + 4;
				break;
			case 'F':
				if (i + state.record.size > n) k = n - i;
				else if (state.record.line || state.record.offset) k = state.record.size;
				else k = n;
				j = i;
				break;
			case 'S':
				switch (state.tmp.buffer[i])
				{
				case '0':
				case '3':
					nl = 1;
					break;
				default:
					nl = 0;
					break;
				}
				if (sscanf(&state.tmp.buffer[i + 1], "%4d", &k) != 1) k = -1;
				j = i + 5;
				break;
			case 'U':
				k = n;
				j = i;
				break;
			case 'V':
				nl = !(state.tmp.buffer[i + 2] & 01);
				k = ((unsigned char*)state.tmp.buffer)[i] << 8 | ((unsigned char*)state.tmp.buffer)[i + 1];
				j = i + 4;
				break;
			}
			if (k < 0)
			{
				error(2, "invalid %s %c record size", format[ap->format].name, f->record.format);
				break;
			}
			m = i += k;
			if (state.record.charset && ap->format == IBMAR) memetoa(&state.tmp.buffer[j], &state.tmp.buffer[j], m - j);
			if (state.record.line) switch (f->record.format)
			{
			case 'F':
			case 'U':
				while (--m >= j && state.tmp.buffer[m] == ' ');
				m++;
				break;
			}
			k = m - j + nl;
			size += k;
			if (wfp)
			{
				if (nl)
				{
					c = state.tmp.buffer[m];
					state.tmp.buffer[m] = '\n';
				}
				if (sfwrite(wfp, &state.tmp.buffer[j], k) != k)
				{
					error(ERROR_SYSTEM|1, "%s: write error", f->name);
					break;
				}
				if (nl) state.tmp.buffer[m] = c;
			}
		}
	}
	if (f->st->st_size && f->st->st_size != size)
		error(1, "%s: header size %ld does not match data size %ld", f->name, f->st->st_size, size);
	f->st->st_size = size;
	if (wfp)
	{
		sfclose(wfp);
		setfile(ap, f);
	}
	if (n < 0) error(ERROR_SYSTEM|3, "%s: %s: archive read error", ap->name, f->name);
}

#if SAVESET

/*
 * filein() saveset support
 */

static void
savesetin __PARAM__((register Archive_t* ap, register File_t* f, int wfd), (ap, f, wfd)) __OTORP__(register Archive_t* ap; register File_t* f; int wfd;){
	register long		c;
	int			i;
	int			j;
	int			k;
	Sfio_t*			wfp;

	if (wfd < 0) wfp = 0;
	else if (!(wfp = sfnew(NiL, NiL, SF_UNBOUND, wfd, SF_WRITE)))
		error(1, "%s: cannot write", f->name);
	j = 0;
	k = 0;
	c = 0;
	while (getsaveset(ap, f, 0))
	{
		/*
		 * this part transcribed from vmsbackup
		 */

		i = 0;
		if (wfp) while ((c + i) < f->st->st_size && i < state.saveset.lastsize) switch (state.saveset.recfmt)
		{
		case 1:	/* fixed length		*/
			if (j <= 0) j = state.saveset.reclen;
			sfputc(wfp, state.saveset.bp[i]);
			i++;
			j--;
			break;
		case 2:	/* variable length	*/
		case 3:	/* with fixed control	*/
			if (j <= 0)
			{
				j = k = swapget(1, &state.saveset.bp[i], 2);
				i += 2;
				if (state.saveset.recfmt == 3)
				{
					i += state.saveset.recvfc;
					j -= state.saveset.recvfc;
				}
			}
			else
			{
				if (j == k && state.saveset.recatt == 1)
				{
					if (state.saveset.bp[i] == '0') state.saveset.bp[i] = '\n';
					else if (state.saveset.bp[i] == '1') state.saveset.bp[i] = '\f';
				}
				sfputc(wfp, state.saveset.bp[i]);
				i++;
				j--;
			}
			if (j <= 0)
			{
				sfputc(wfp, '\n');
				if (i & 1) i++;
			}
			break;
		case 4:	/* seq stream		*/
		case 5:	/* seq LF stream	*/
			if (j <= 0) j = 512;
			if (state.saveset.bp[i] == '\n') j = 0;
			else j--;
			sfputc(wfp, state.saveset.bp[i]);
			i++;
			break;
		case 6:	/* seq CR stream	*/
			if (state.saveset.bp[i] == '\r') state.saveset.bp[i] = '\n';
			sfputc(wfp, state.saveset.bp[i]);
			i++;
			break;
		default:
			error(state.keepgoing ? 1 : 3, "%s: invalid %s format data record format=%d", f->name, format[ap->format].name, state.saveset.recfmt);
			goto next;
		}
	next:
		c += i;
	}
	if (wfp)
	{
		sfclose(wfp);
		setfile(ap, f);
	}
}

#endif

/*
 * low level for copyin()
 */

void
filein __PARAM__((register Archive_t* ap, register File_t* f), (ap, f)) __OTORP__(register Archive_t* ap; register File_t* f;){
	register long	c;
	register int	n;
	register char*	s;
	int		dfd;
	int		wfd;
	long		checksum;
	struct stat	st;

	if (f->skip) goto skip;
	else if (state.list)
	{
		listentry(f);
		goto skip;
	}
	else switch (f->delta.op)
	{
	case DELTA_create:
		if (f->delta.base)
			error(3, "%s: base archive mismatch [%s#%d]", f->name, __FILE__, __LINE__);
		if (ap->delta->format != COMPRESS && ap->delta->format != DELTA) goto regular;
		if ((wfd = openout(ap, f)) < 0) goto skip;
		else paxdelta(NiL, ap, f, DELTA_TAR|DELTA_FD|DELTA_FREE|DELTA_OUTPUT|DELTA_COUNT, wfd, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap, f->st->st_size, 0);
		break;
	case DELTA_update:
		if (!f->delta.base || (unsigned long)f->delta.base->mtime >= (unsigned long)f->st->st_mtime)
			error(3, "%s: base archive mismatch [%s#%d]", f->name, __FILE__, __LINE__);
		c = f->st->st_size;
		if ((wfd = openout(ap, f)) < 0)
			goto skip;
		if (state.ordered)
		{
			if (f->delta.base->expand < 0)
				paxdelta(NiL, ap, f, DELTA_SRC|DELTA_BIO|DELTA_SIZE, ap->delta->base, f->delta.base->size, DELTA_TAR|DELTA_FD|DELTA_FREE|DELTA_OUTPUT|DELTA_COUNT, wfd, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap, c, 0);
			else if (!paxdelta(NiL, ap, f, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap->delta->base, f->delta.base->size, DELTA_TAR|DELTA_TEMP|DELTA_OUTPUT, &dfd, 0))
				paxdelta(NiL, ap, f, DELTA_SRC|DELTA_FD|DELTA_SIZE|DELTA_FREE, dfd, f->delta.base->expand, DELTA_TAR|DELTA_FD|DELTA_FREE|DELTA_OUTPUT|DELTA_COUNT, wfd, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap, c, 0);
		}
		else if (f->delta.base->expand < 0)
			paxdelta(NiL, ap, f, DELTA_SRC|DELTA_FD|DELTA_OFFSET|DELTA_SIZE, ap->delta->base->io.fd, f->delta.base->offset, f->delta.base->size, DELTA_TAR|DELTA_FD|DELTA_FREE|DELTA_OUTPUT|DELTA_COUNT, wfd, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap, c, 0);
		else if (!paxdelta(NiL, ap, f, DELTA_DEL|DELTA_FD|DELTA_OFFSET|DELTA_SIZE, ap->delta->base->io.fd, f->delta.base->offset, f->delta.base->size, DELTA_TAR|DELTA_TEMP|DELTA_OUTPUT, &dfd, 0))
			paxdelta(NiL, ap, f, DELTA_SRC|DELTA_FD|DELTA_SIZE|DELTA_FREE, dfd, f->delta.base->expand, DELTA_TAR|DELTA_FD|DELTA_FREE|DELTA_OUTPUT|DELTA_COUNT, wfd, DELTA_DEL|DELTA_BIO|DELTA_SIZE, ap, c, 0);
		break;
	case DELTA_verify:
		if (!f->delta.base || f->delta.base->mtime != f->st->st_mtime)
			error(3, "%s: base archive mismatch [%s#%d]", f->name, __FILE__, __LINE__);
		if ((*state.statf)(f->name, &st))
			error(2, "%s: not copied from base archive", f->name);
		else if (st.st_size != f->delta.base->size || state.modtime && st.st_mtime != f->st->st_mtime)
			error(1, "%s: changed from base archive", f->name);
		break;
	case DELTA_delete:
		if (!f->delta.base)
			error(3, "%s: base archive mismatch [%s#%d]", f->name, __FILE__, __LINE__);
		/*FALLTHROUGH*/
	default:
	regular:
		wfd = openout(ap, f);
		switch (ap->format)
		{
		case ALAR:
		case IBMAR:
			recordin(ap, f, wfd);
			break;
#if SAVESET
		case SAVESET:
			savesetin(ap, f, wfd);
			break;
#endif
		default:
			if (wfd >= 0)
			{
				checksum = 0;
				holeinit(wfd);
				for (c = f->st->st_size; c > 0; c -= n)
				{
					n = (c > state.buffersize) ? state.buffersize : c;
					if (!(s = bget(ap, n)))
					{
						error(ERROR_SYSTEM|2, "%s: read error", f->name);
						break;
					}
					if (holewrite(wfd, s, n) != n)
					{
						error(ERROR_SYSTEM|2, "%s: write error", f->name);
						break;
					}
					if (ap->format == ASCHK) checksum = asc_checksum(s, n, checksum);
				}
				holedone(wfd);
				close(wfd);
				setfile(ap, f);
				if (ap->format == ASCHK && checksum != f->checksum)
					error(1, "%s: %s checksum error (0x%08x != 0x%08x)", f->name, format[ap->format].name, checksum, f->checksum);
			}
			else goto skip;
			break;
		}
	}
	listentry(f);
	return;
 skip:
	fileskip(ap, f);
}

/*
 * skip over archive member f file data
 */

void
fileskip __PARAM__((register Archive_t* ap, register File_t* f), (ap, f)) __OTORP__(register Archive_t* ap; register File_t* f;){
	switch (ap->format)
	{
	case ALAR:
	case IBMAR:
		recordin(ap, f, -1);
		break;
#if SAVESET
	case SAVESET:
		savesetin(ap, f, -1);
		break;
#endif
	default:
		if (bread(ap, NiL, 0L, f->st->st_size, 1) < 0)
			error(ERROR_SYSTEM|2, "%s: skip error", f->name);
		break;
	}
}

/*
 * single file copyin() and copyout() smashed together
 * called by ftwalk()
 */

int
copyinout __PARAM__((Ftw_t* ftw), (ftw)) __OTORP__(Ftw_t* ftw;){
	register long		c;
	register long		n;
	register int		rfd;
	register int		wfd;
	register File_t*	f = &state.out->file;

	static char		path[PATH_MAX];

	if (getfile(state.out, f, ftw) && selectfile(state.out, f))
	{
		strcpy(path, state.pwd);
		strcpy(path + state.pwdlen, f->name + (*f->name == '/'));
		f->name = path;
		if ((wfd = openout(state.out, f)) >= 0)
		{
			if ((rfd = openin(state.out, f)) >= 0)
			{
				holeinit(wfd);
				for (c = f->st->st_size; c > 0; c -= n)
				{
					if ((n = read(rfd, state.tmp.buffer, (c > state.buffersize) ? state.buffersize : c)) <= 0)
					{
						error(ERROR_SYSTEM|2, "%s: read error", f->name);
						break;
					}
					if (holewrite(wfd, state.tmp.buffer, n) != n)
					{
						error(ERROR_SYSTEM|2, "%s: write error", f->name);
						break;
					}
					state.out->io.count += n;
				}
				holedone(wfd);
				close(rfd);
				setfile(state.out, f);
				listentry(f);
			}
			close(wfd);
		}
		else if (wfd != -1) listentry(f);
	}
	return(0);
}

/*
 * compare ft1 and ft2 for ftwalk() sort
 */

int
cmpftw __PARAM__((Ftw_t* ft1, Ftw_t* ft2), (ft1, ft2)) __OTORP__(Ftw_t* ft1; Ftw_t* ft2;){
	return(strcoll(ft1->name, ft2->name));
}


/*
 * copy files out using copyfile
 */

typedef int (*Ftw_cmp_t) __PROTO__((Ftw_t*, Ftw_t*));

void
copy __PARAM__((register Archive_t* ap, register int (*copyfile)(Ftw_t*)), (ap, copyfile)) __OTORP__(register Archive_t* ap; register int (*copyfile)();){
	register char*	s;
	register int	n;

	if (ap)
	{
		deltabase(ap);
		putprologue(ap);
	}
	if (state.files) n = ftwalk((char*)state.files, copyfile, state.ftwflags|FTW_MULTIPLE, state.exact ? (Ftw_cmp_t)0 : cmpftw);
	else for (;;)
	{
		if (s = state.peekfile)
			state.peekfile = 0;
		else if (!(s = sfgetr(sfstdin, '\n', 1)))
			break;
		if (ftwalk(s, copyfile, state.ftwflags, NiL))
		{
			error(2, "%s: not completely copied", s);
			break;
		}
	}
	if (ap)
	{
		deltadelete(ap);
		putepilogue(ap);
	}
}

/*
 * position archive for appending
 */

void
append __PARAM__((register Archive_t* ap), (ap)) __OTORP__(register Archive_t* ap;){
	if (state.update) initdelta(ap);
	ap->format = IN_DEFAULT;
	copyin(ap);
	state.append = 0;
}
