/* $XConsortium: shipproto.c /main/cde1_maint/4 1995/10/13 23:57:46 montyb $ */
/***************************************************************
*                                                              *
*                      AT&T - PROPRIETARY                      *
*                                                              *
*         THIS IS PROPRIETARY SOURCE CODE LICENSED BY          *
*                          AT&T CORP.                          *
*                                                              *
*                Copyright (c) 1995 AT&T Corp.                 *
*                     All Rights Reserved                      *
*                                                              *
*           This software is licensed by AT&T Corp.            *
*       under the terms and conditions of the license in       *
*       http://www.research.att.com/orgs/ssr/book/reuse        *
*                                                              *
*               This software was created by the               *
*           Software Engineering Research Department           *
*                    AT&T Bell Laboratories                    *
*                                                              *
*               For further information contact                *
*                     gsf@research.att.com                     *
*                                                              *
***************************************************************/

/* : : generated by proto : : */

#if !defined(__PROTO__)
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)
#if defined(__cplusplus)
#define __MANGLE__	"C"
#else
#define __MANGLE__
#endif
#define __STDARG__
#define __PROTO__(x)	x
#define __OTORP__(x)
#define __PARAM__(n,o)	n
#if !defined(__STDC__) && !defined(__cplusplus)
#if !defined(c_plusplus)
#define const
#endif
#define signed
#define void		int
#define volatile
#define __V_		char
#else
#define __V_		void
#endif
#else
#define __PROTO__(x)	()
#define __OTORP__(x)	x
#define __PARAM__(n,o)	o
#define __MANGLE__
#define __V_		char
#define const
#define signed
#define void		int
#define volatile
#endif
#if defined(__cplusplus) || defined(c_plusplus)
#define __VARARG__	...
#else
#define __VARARG__
#endif
#if defined(__STDARG__)
#define __VA_START__(p,a)	va_start(p,a)
#else
#define __VA_START__(p,a)	va_start(p)
#endif
#endif
#line 1 "/home/gsf/src/cmd/proto/proto.c"

 

#line 27





# define ctime		_huh_ctime

# include <sys/types.h>
# include <sys/stat.h>

# undef	ctime

# ifndef _WIN32
# define remove(x)	unlink(x)
# define rename(x,y)	((link(x,y)||remove(x))?-1:0)
# endif



 




int
replace __PARAM__((const char* newfile, const char* oldfile, int preserve), (newfile, oldfile, preserve)) __OTORP__(const char* newfile; const char* oldfile; int preserve;){
	struct stat	st;
	time_t		ut[2];

	if (preserve && stat(oldfile, &st) || remove(oldfile) || rename(newfile, oldfile))
		return(-1);
	if (preserve)
	{
		ut[0] = st.st_atime;
		ut[1] = st.st_mtime;
		preserve = utime(oldfile, ut);
	}
	return(preserve);
}

#line 1 "../../lib/libpp/ppproto.c"

 










static const char id[] = "\n@(#)proto (AT&T Bell Laboratories) 05/09/95\000\n";



#line 1 "../../lib/libpp/ppfsm.c"

 







#line 1 "../../lib/libpp/pplib.h"

 









 




































 

















































struct ppsymbol;
struct ppindex;

typedef char*	(*PPBUILTIN) __PROTO__((char*, const char*, const char*));
typedef void	(*PPCOMMENT) __PROTO__((const char*, const char*, const char*, int));
typedef void	(*PPINCREF) __PROTO__((const char*, const char*, int, int));
typedef void	(*PPLINESYNC) __PROTO__((int, const char*));
typedef void	(*PPMACREF) __PROTO__((struct ppsymbol*, const char*, int, int, unsigned long));
typedef int	(*PPOPTARG) __PROTO__((int, int, const char*));
typedef void	(*PPPRAGMA) __PROTO__((const char*, const char*, const char*, const char*, int));

struct ppinstk				 
{
	char*		nextchr;	 
	struct ppinstk*	next;		 
	struct ppinstk*	prev;		 
	long*		control;	 
	char*		buffer;		 
	char*		file;		 
	char*		prefix;		 
	struct ppsymbol* symbol;	 

	struct ppindex*	index;		 
	int		buflen;		 

	int		line;		 
	short		fd;		 
	short		hide;		 
	short		flags;		 
	char		type;		 
};









struct pplist				 
{
	char*		value;		 
	struct pplist*	next;		 
};

struct oplist				 
{
	int		op;		 
	char*		value;		 
	struct oplist*	next;		 
};

struct pphide				 
{
	struct ppmacro*	macro;		 
	unsigned long	flags;		 
	int		level;		 
};

struct ppmacstk				 
{
	struct ppmacstk* next;		 
	struct ppmacstk* prev;		 
	int		line;		 
	char*		arg[1];		 
};

struct ppmember				 
{
	struct ppdirs*	archive;	 
	unsigned long	offset;		 
	unsigned long	size;		 
};

struct counter				 
{
	int		candidate;	 
	int		function;	 
	int		macro;		 
	int		pplex;		 
	int		push;		 
	int		terminal;	 
	int		token;		 
};



#line 228


#line 273




#line 287







#line 304








#line 1 "../../lib/libpp/pp.h"

 

























































































































































































 













 























 



















 






 









 



























 







 







 





struct ppdirs				 
{
	char*		name;		 
	struct ppdirs*	next;		 


	unsigned char c; unsigned char hosted; unsigned char index; unsigned char type; union { char* buffer; char* sp; struct ppdirs* subdir; } info;


};

struct ppkeyword			 
{
	char*		name;		 
	int		value;		 
};

struct ppmacro				 
{
	int		arity;		 
	char*		value;		 


	int size; char* formals;


};

struct ppsymbol				 
{
	int hash_header;			 
	unsigned long	flags;		 
	struct ppmacro*	macro;		 
	__V_*		value;		 


	struct pphide* hidden;


};









struct ppglobals			 
{
	const char*	version;	 
	char*		lineid;		 
	char*		outfile;	 
	char*		pass;		 
	char*		token;		 
	struct ppsymbol* symbol;	 

 

	char*		outbuf;		 
	char*		outp;	    	 
	unsigned long	offset;		 


	struct ppdirs* lcldirs; struct ppdirs* stddirs; int flags; char* symtab;		 



	struct ppcontext* context; long state; long mode; long option; long test; char* filedeps; struct ppdirs* firstdir; struct ppdirs* lastdir; int hide; int column; int pending; char* firstfile; char* lastfile; char* ignore; char* probe; char* filtab; char* prdtab; char* date; char* time; char* maps; long ro_state; long ro_mode; long ro_option; char* cdir; char* hostdir; char* ppdefault; struct ppindex* firstindex; struct ppindex* lastindex; struct oplist* firstop; struct oplist* lastop; struct oplist* firsttx; struct oplist* lasttx; unsigned char arg_file; unsigned char arg_mode; unsigned char arg_style; unsigned char c; unsigned char hosted; unsigned char ignoresrc; unsigned char initialized; unsigned char standalone; unsigned char spare_1;		 



	char* checkpoint; int constack; struct ppinstk* in; char* addp; char* args; char* addbuf; char* catbuf; char* path; char* tmpbuf; char* valbuf; char* include; char* prefix; struct ppmember* member; int hidden; int hiding; int level; struct { int input; int output; } pool; int truncate; struct ppmacstk* macp; char* maxmac; char* mactop; char* toknxt; long* control; long* maxcon; struct oplist* chop; struct ppfile* insert; struct ppfile* original; char* dirtab; char* strtab; PPBUILTIN builtin; PPCOMMENT comment; PPINCREF incref; PPLINESYNC linesync; PPLINESYNC olinesync; PPMACREF macref; PPOPTARG optarg; PPPRAGMA pragma; struct counter counter;		 


};

 





extern __MANGLE__ struct ppglobals	pp;
extern __MANGLE__ char		_pp_ctype[];

extern __MANGLE__ int		ppargs __PROTO__((char**, int));
extern __MANGLE__ void		ppcpp __PROTO__((void));
extern __MANGLE__ void		ppcomment __PROTO__((char*, char*, char*, int));
extern __MANGLE__ __V_*		ppcontext __PROTO__((__V_*, int));
extern __MANGLE__ void		pperror __PROTO__((int, ...));
extern __MANGLE__ void		ppincref __PROTO__((char*, char*, int, int));
extern __MANGLE__ void		ppinput __PROTO__((char*, char*, int));
extern __MANGLE__ int		pplex __PROTO__((void));
extern __MANGLE__ void		ppline __PROTO__((int, char*));
extern __MANGLE__ void		ppmacref __PROTO__((struct ppsymbol*, char*, int, int));
extern __MANGLE__ void		ppop __PROTO__((int, ...));
extern __MANGLE__ void		pppragma __PROTO__((char*, char*, char*, char*, int));
extern __MANGLE__ int		ppprintf __PROTO__((char*, ...));


#line 313 "../../lib/libpp/pplib.h"

#line 1 "../../lib/libpp/ppdef.h"
 

#line 14




































































































































































#line 314 "../../lib/libpp/pplib.h"

#line 1 "../../lib/libpp/ppkey.h"

 












 





 































 









 


































 










 





 



extern __MANGLE__ struct ppkeyword	ppkey[];


#line 315 "../../lib/libpp/pplib.h"



 































 





#line 367






































































































#line 481





#line 496


#line 510








#line 529


#line 551


#line 563































struct ppcontext			 
{
	struct ppdirs* lcldirs; struct ppdirs* stddirs; int flags; char* symtab;
	struct ppcontext* context; long state; long mode; long option; long test; char* filedeps; struct ppdirs* firstdir; struct ppdirs* lastdir; int hide; int column; int pending; char* firstfile; char* lastfile; char* ignore; char* probe; char* filtab; char* prdtab; char* date; char* time; char* maps; long ro_state; long ro_mode; long ro_option; char* cdir; char* hostdir; char* ppdefault; struct ppindex* firstindex; struct ppindex* lastindex; struct oplist* firstop; struct oplist* lastop; struct oplist* firsttx; struct oplist* lasttx; unsigned char arg_file; unsigned char arg_mode; unsigned char arg_style; unsigned char c; unsigned char hosted; unsigned char ignoresrc; unsigned char initialized; unsigned char standalone; unsigned char spare_1;
};

struct ppfile 
{
	int hash_header;			 
	struct ppsymbol* guard;		 
	struct ppfile*	bound[3];	 
	int		flags;		 
};



struct ppindex				 
{
	struct ppindex*	next;		 
	struct ppfile*	file;		 
	unsigned long	begin;		 
	unsigned long	end;		 
};



struct ppsymkey				 
{
	struct ppsymbol	sym;		 
	int		lex;		 
};















extern __MANGLE__ int		access __PROTO__((const char*, int));
extern __MANGLE__ __V_*		calloc __PROTO__((int, int));
extern __MANGLE__ int		close __PROTO__((int));
extern __MANGLE__ int		creat __PROTO__((const char*, int));
extern __MANGLE__ char*		ctime __PROTO__((time_t*));
extern __MANGLE__ void		exit __PROTO__((int));
extern __MANGLE__ void		free __PROTO__((__V_*));
extern __MANGLE__ int		link __PROTO__((const char*, const char*));
extern __MANGLE__ int		open __PROTO__((const char*, int, ...));
extern __MANGLE__ int		read __PROTO__((int, __V_*, int));
extern __MANGLE__ int		strncmp __PROTO__((const char*, const char*, size_t));
extern __MANGLE__ time_t		time __PROTO__((time_t*));
extern __MANGLE__ int		unlink __PROTO__((const char*));
extern __MANGLE__ int		write __PROTO__((int, const __V_*, int));







#line 691


extern __MANGLE__ void		ppassert __PROTO__((int, char*, char*));
extern __MANGLE__ void		ppbuiltin __PROTO__((void));
extern __MANGLE__ int		ppcall __PROTO__((struct ppsymbol*, int));
extern __MANGLE__ int		ppcontrol __PROTO__((void));
extern __MANGLE__ void		ppdump __PROTO__((void));
extern __MANGLE__ char*		ppexpand __PROTO__((char*));
extern __MANGLE__ long		ppexpr __PROTO__((int*));
extern __MANGLE__ void		ppfsm __PROTO__((int, char*));
extern __MANGLE__ char*		ppinstr __PROTO__((struct ppinstk*));
extern __MANGLE__ char*		ppkeyname __PROTO__((int, int));
extern __MANGLE__ char*		pplexstr __PROTO__((int));
extern __MANGLE__ void		ppload __PROTO__((char*));
extern __MANGLE__ char*		ppmodestr __PROTO__((long));
extern __MANGLE__ int		ppmultiple __PROTO__((struct ppfile*, struct ppsymbol*));
extern __MANGLE__ void		ppnest __PROTO__((void));
extern __MANGLE__ int		ppoption __PROTO__((char*));
extern __MANGLE__ char*		ppoptionstr __PROTO__((long));
extern __MANGLE__ void		pppclose __PROTO__((char*));
extern __MANGLE__ int		pppdrop __PROTO__((char*));
extern __MANGLE__ char*		pppopen __PROTO__((char*, int, char*, int));
extern __MANGLE__ int		pppread __PROTO__((char*));
extern __MANGLE__ int		pppredargs __PROTO__((void));
extern __MANGLE__ void		pppush __PROTO__((int, char*, char*, int));
extern __MANGLE__ struct ppsymbol*	pprefmac __PROTO__((char*, int));
extern __MANGLE__ int		ppsearch __PROTO__((char*, int, int));
extern __MANGLE__ char*		ppstatestr __PROTO__((long));
extern __MANGLE__ char*		pptokstr __PROTO__((char*, int));
extern __MANGLE__ void		pptrace __PROTO__((int));


#line 11 "../../lib/libpp/ppfsm.c"

#line 1 "../../lib/libpp/ppfsm.h"

 
































 
















 








































#line 106




#line 143




 















 











 





 





 














#line 220







 







 




extern __MANGLE__ short		_pp_fsmtab[(0+26)+1][255+1];

 



extern __MANGLE__ char		_pp_trigraph[255+1];

extern __MANGLE__ void		_pp_refill __PROTO__((int));


#line 12 "../../lib/libpp/ppfsm.c"

 

#line 49













struct fsminit				 
{
	int		state;		 
	unsigned char	ch[4];		 
	int		nextstate;	 
};

static struct fsminit	fsminit[] =
{
 
	{	0,	{ 6 },		((0+26)+11),			},
	{	0,	{ 5 },		(0),			},
	{	0,	{ 2 },		(0+21),			},
	{	0,	{ '.' },		(0+23),			},
	{	0,	{ 1 },		(0+17),			},
	{	0,	{ 'L' },		(0+18),			},
	{	0,	{ 'd', 'e', 'f', 'i' },	(0+1),			},
	{	0,	{ 'r', 't', 'v', 'w' },	(0+1),			},
	{	0,	{ '"', '\'' },		((0+26)+3),		},
	{	0,	{ '/' },		(0+10),			},
	{	0,	{ '\n' },		((0+26)+7),			},
	{	0,	{ ' ','\t','\f','\013' },	(0+25),			},

 
	{	(0+1),	{ 6 },		((0+26)+6),		},
	{	(0+1),	{ 1, 2 },	(0+17),			},
	{	(0+1),	{ 'a' },		(0+2),			},
	{	(0+1),	{ 'e' },		(0+3),			},
	{	(0+1),	{ 'f' },		(0+4),			},
	{	(0+1),	{ 'h' },		(0+5),			},
	{	(0+1),	{ 'l' },		(0+6),			},
	{	(0+1),	{ 'o' },		(0+7),			},
	{	(0+1),	{ 'x' },		(0+8),			},
	{	(0+1),	{ 'y' },		(0+9),			},

 
	{	(0+2),	{ 6 },		(((0+26)+12)),		},
	{	(0+2),	{ 1, 2 },	(0+17),			},
	{	(0+2),	{ '_','s','t','a' },	(0+2),			},
	{	(0+2),	{ 'r' },		(0+2),			},

 
	{	(0+3),	{ 6 },		(((0+26)+12)),		},
	{	(0+3),	{ 1, 2 },	(0+17),			},
	{	(0+3),	{ 't','u','r','n' },	(0+3),			},

 
	{	(0+4),	{ 6 },		(((0+26)+12)),		},
	{	(0+4),	{ 1, 2 },	(0+17),			},

 
	{	(0+5),	{ 6 },		(((0+26)+12)),		},
	{	(0+5),	{ 1, 2 },	(0+17),			},
	{	(0+5),	{ 'i','l','e' },	(0+5),			},

 
	{	(0+6),	{ 6 },		(((0+26)+12)),		},
	{	(0+6),	{ 1, 2 },	(0+17),			},
	{	(0+6),	{ 's','e' },		(0+6),			},

 
	{	(0+7),	{ 6 },		(((0+26)+12)),		},
	{	(0+7),	{ 1, 2 },	(0+17),			},
	{	(0+7),	{ 'r', 'i','d' },	(0+7),			},

 
	{	(0+8),	{ 6 },		(((0+26)+12)),		},
	{	(0+8),	{ 1, 2 },	(0+17),			},
	{	(0+8),	{ 't','e','r','n' },	(0+8),			},

 
	{	(0+9),	{ 6 },		(((0+26)+12)),		},
	{	(0+9),	{ 1, 2 },	(0+17),			},
	{	(0+9),	{ 'p','e','d','f' },	(0+9),			},

 
	{	(0+10),	{ 6 },		((0+26)+0),			},
	{	(0+10),	{ '*' },		(0+11),			},

	{	(0+10),	{ '/' },		(0+14),			},


 
	{	(0+11),	{ 6 },		(0+11),			},
	{	(0+11),	{ '\n', 5 },	((0+26)+1),		},
	{	(0+11),	{ '/' },		(0+13),			},
	{	(0+11),	{ '*' },		(0+12),			},
	{	(0+11),	{ '#', ';', ')' },	((( (0+11))<<(7+1))|(((0+26)+8))),		},

 
	{	(0+12),	{ 6 },		(0+11),			},
	{	(0+12),	{ '\n', 5 },	((0+26)+1),		},
	{	(0+12),	{ '#', ';', ')' },	((( (0+11))<<(7+1))|(((0+26)+8))),		},
	{	(0+12),	{ '*' },		(0+12),			},
	{	(0+12),	{ '/' },		((0+26)+1),		},

 
	{	(0+13),	{ 6 },		(0+11),			},
	{	(0+13),	{ '*', '\n', 5 },	((0+26)+1),		},
	{	(0+13),	{ '/' },		(0+13),			},

 
	{	(0+14),	{ 6 },		(0+14),			},
	{	(0+14),	{ '\n', 5 },	((0+26)+1),		},
	{	(0+14),	{ '/' },		(0+15),			},
	{	(0+14),	{ '*' },		(0+16),			},

 
	{	(0+15),	{ 6 },		(0+14),			},
	{	(0+15),	{ '*', '\n', 5 },	((0+26)+1),		},
	{	(0+15),	{ '/' },		(0+15),			},

 
	{	(0+16),	{ 6 },		(0+14),			},
	{	(0+16),	{ '\n', 5 },	((0+26)+1),		},
	{	(0+16),	{ '*' },		(0+16),			},
	{	(0+16),	{ '/' },		((0+26)+1),		},

 
	{	(0+17),	{ 6 },		((0+26)+6),		},
	{	(0+17),	{ 1, 2 },	(0+17),			},

 
	{	(0+23),	{ 6 },		((0+26)+0),			},
	{	(0+23),	{ '.' },		(0+24),			},
	{	(0+23),	{ 2 },		(0+21),			},

 
	{	(0+24),	{ 6 },		(((( (0401+1))-0401)<<(7+1))|( ((0+26)+14))),	},
	{	(0+24),	{ '.' },		(((( (0401+29))-0401)<<(7+1))|( ((0+26)+13))),	},

 
	{	(0+18),	{ 6 },		((0+26)+6),		},
	{	(0+18),	{ 1, 2 },	(0+17),			},
	{	(0+18),	{ '"', '\'' },		((( (0+19))<<(7+1))|(((0+26)+8))),		},

 
	{	(0+19),	{ 6 },		(0+19),			},
	{	(0+19),	{ '"', '\'' },		((0+26)+4),		},
	{	(0+19),	{ '\n', 5 },	((0+26)+4),		},
	{	(0+19),	{ '\\' },		(0+20),			},

 
	{	(0+20),	{ 6 },		((0+26)+5),		},
	{	(0+20),	{ '\n', 5 },	((0+26)+4),		},

 
	{	(0+21),	{ 6 },		(((( (0401+1))-0401)<<(7+1))|( ((0+26)+14))),	},
	{	(0+21),	{ 1, 2, '.' },	(0+21),			},
	{	(0+21),	{ 'e', 'E' },		(0+22),			},

 
	{	(0+22),	{ 6 },		(((( (0401+1))-0401)<<(7+1))|( ((0+26)+14))),	},
	{	(0+22),	{ 1, 2, '.' },	(0+21),			},
	{	(0+22),	{ '+', '-' },		(0+21),			},

 
	{	(0+25),	{ 6 },		((0+26)+15),			},
	{	(0+25),	{ ' ', '\t' },		(0+25),			},
	{	(0+25),	{ '\f', '\013' },		((0+26)+10),			},
































































































































































































































































 
	{	(-1),	{ 0 },			0,			}
};

short		_pp_fsmtab[(0+26)+1][255+1];

char		_pp_trigraph[255+1];


static char	spl[] = { '\\', '\r', 0 };
static char	aln[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$@";




static char*	let = &aln[10];
static char	hex[] = "fedcbaFEDCBA9876543210";
static char*	dec = &hex[12];
static char*	oct = &hex[14];

 




void
ppfsm __PARAM__((int op, register char* s), (op, s)) __OTORP__(int op; register char* s;){
	register int			c;
	register int			n;
	register int			i;
	register short*			rp;
	register struct fsminit*	fp;




	switch (op)
	{





























	case 4:
		for (fp = fsminit;; fp++)
		{
			if ((n = fp->nextstate) >= (0+26)) n = ~n;
			if (fp->state == (-1))
			{













				break;
			}
			rp = _pp_fsmtab[fp->state];
			for (i = 0; i < sizeof(fp->ch) && (c = fp->ch[i]); i++)
			{
				switch (c)
				{
				case 6:
					for (c = 0; c <= 255; c++)
						rp[c] = n;
 

				case 5:
					_pp_fsmtab[(0+26)][fp->state+1] = n < 0 ? ~n : n;
					continue;

				case 1:
					s = let;
					break;

				case 3:
					s = hex;
					break;

				case 2:
					s = dec;
					break;

				case 4:
					s = oct;
					break;

				default:
					rp[c] = n;
					continue;
				}
				while (c = *s++)
					rp[c] = n;
			}
		}

 




		for (i = 0; i < (0+26); i++)
		{
			rp = _pp_fsmtab[i];
			s = spl;
			while (c = *s++)
				if (c != '@' || !(( rp)>=_pp_fsmtab[(0+11)]&&( rp)<=_pp_fsmtab[(0+13)]||(( rp)>=_pp_fsmtab[(0+14)]&&( rp)<=_pp_fsmtab[(0+16)])))
				{
					if (rp[c] >= 0) rp[c] = ~rp[c];
					rp[c] &= ~(1<<7);
				}
			rp[0] = ~((0+26)+2);
			for (c = 0; c <= 255; c++)
				if (rp[c] == i)
					rp[c] = 0;
		}
		_pp_fsmtab[(0+26)][0] = ~((0+26)+2);































		break;





















































































































































	}
}
































































#line 18 "../../lib/libpp/ppproto.c"















struct proto 
{
	int		brace;		 
	int		fd;		 
	char*		file;		 
	long		flags;		 
	int		line;		 
	int		test;		 

	char*		tp;		 

	int		iz;		 
	char*		ib;		 
	char*		ip;		 

	int		oz;		 
	char*		ob;		 
	char*		op;		 

	char		pushback[4];	 

	char		variadic[256];	 

 
 
 
};

 

























































































static int		errors;

 








 



static int
sstrlen __PARAM__((register char* s), (s)) __OTORP__(register char* s;){
	register char*	b;

	for (b = s; *s; s++);
	return(s - b);
}

 



static int
sstrncmp __PARAM__((register char* s, register char* t, register int n), (s, t, n)) __OTORP__(register char* s; register char* t; register int n;){
	register char*	e = s + n;

	while (s < e)
	{
		if (*s != *t || !*s) return(*s - *t);
		s++;
		t++;
	}
	return(0);
}

 



static char*
memcopy __PARAM__((register char* s, register char* t, int n), (s, t, n)) __OTORP__(register char* s; register char* t; int n;){
	register char*	e = t + n;

	while (t < e) *s++ = *t++;
	return(s);
}

 



static char*
strcopy __PARAM__((register char* s, register char* t), (s, t)) __OTORP__(register char* s; register char* t;){
	while (*s++ = *t++);
	return(s - 1);
}

 








static char*
comment __PARAM__((register char* p, register char* s, register int n, int u), (p, s, n, u)) __OTORP__(register char* p; register char* s; register int n; int u;){
	register char*	e;
	char*		m;

	if (!s)
	{
		if (n)
		{
			*p++ = (n > 0) ? '/' : '*';
			e = p + 62;
			while (p < e) *p++ = '*';
			*p++ = (n > 0) ? '*' : '/';
		}
		else s = "";
	}
	if (s)
	{
		if (n > 62) n = 62;
		*p++ = '*';
		e = p + (62 - n) / 2;
		m = p + 62;
		while (p < e) *p++ = ' ';
		e = p + n;
		while (p < e)
		{
			n = *s++;
			if (u && n >= 'a' && n <= 'z') n = n - 'a' + 'A';
			*p++ = n;
		}
		e = m;
		while (p < e) *p++ = ' ';
		*p++ = '*';
	}
	*p++ = '\n';
	return(p);
}

 

#line 285










typedef struct
{
	char*		data;
	int		size;
} Item_t;

typedef struct
{
	int		type;
	Item_t		item[5];
} Notice_t;

static char*
copyright __PARAM__((register char* p, register char* s), (p, s)) __OTORP__(register char* p; register char* s;){
	register char*	v;
	register char*	x;
	register int	c;
	int		i;
	int		n;
	unsigned long	h;
	time_t		clock;
	char		buf[(62+4)];
	Notice_t	notice;

	notice.type = 2;
	for (i = 0; i < 5; i++)
		notice.item[i].data = 0;
	i = 0;
	while (c = *s)
	{
		while (c == ' ' || c == '\t' || c == '\n' || c == '\r')
			c = *++s;
		x = s;
		n = 0;
		h = 0;
		while (c && c != '=' && c != ' ' && c != '\t' && c != '\n' && c != '\r')
		{
			if (n++ < 6)
				h = (h << 5) + c - 'a';
			c = *++s;
		}
		if (c == '=')
		{
			n = (*++s == '"' || *s == '\'') ? *s++ : 0;
			v = s;
			while ((c = *s) && (n && c != n || !n && c != ' ' && c != '\t' && c != '\n' && c != '\r'))
				s++;
			switch (h)
			{
			case   ((('c'-'a')<<25)|(('o'-'a')<<20)|(('m'-'a')<<15)|(('p'-'a')<<10)|(('a'-'a')<<5)|('n'-'a')):
				c = 0;
				break;
			case   ((('c'-'a')<<25)|(('o'-'a')<<20)|(('n'-'a')<<15)|(('t'-'a')<<10)|(('a'-'a')<<5)|('c'-'a')):
				c = 2;
				break;
			case   ((('c'-'a')<<25)|(('o'-'a')<<20)|(('r'-'a')<<15)|(('p'-'a')<<10)|(('o'-'a')<<5)|('r'-'a')):
				c = 3;
				break;
			case   ((('l'-'a')<<25)|(('i'-'a')<<20)|(('c'-'a')<<15)|(('e'-'a')<<10)|(('n'-'a')<<5)|('s'-'a')):
				c = 4;
				break;
			case   ((('o'-'a')<<25)|(('r'-'a')<<20)|(('g'-'a')<<15)|(('a'-'a')<<10)|(('n'-'a')<<5)|('i'-'a')):
				c = 1;
				break;
			case   ((('t'-'a')<<15)|(('y'-'a')<<10)|(('p'-'a')<<5)|('e'-'a')):
				if (!sstrncmp( v, "proprietary", 11))
					notice.type = 2;
				else if (!sstrncmp( v, "nonexclusive", 11))
					notice.type = 1;
 
			default:
				c = -1;
				break;
			}
			if (c >= 0 && (notice.item[c].size = s - v))
				notice.item[c].data = v;
		}
		else
		{
			while (c && c != '\n')
				c = *++s;
			if (notice.item[i].size = s - x)
			{
				notice.item[i].data = x;
				if (i == 0)
				{
					notice.item[3].data = v = x;
					while ((c = *x) && c != '\n' && c != ' ' && (c < 'a' || c > 'z'))
						x++;
					if ((c = (x - v)) >= 3)
					{
						notice.item[3].size = c++;
						notice.item[0].data += c;
						notice.item[0].size -= c;
					}
					else notice.item[3].data = 0;
				}
			}
			if (i++ >= 2)
				break;
		}
		if (*s) s++;
	}
	p = comment(p, ((char*)0), 1, 0);
	p = comment(p, ((char*)0), 0, 0);
	s = buf;
	if (notice.type == 2)
	{
		if ((x = notice.item[i = 3].data) || (x = notice.item[i = 0].data))
		{
			s = memcopy(s, x, notice.item[i].size);
			*s++ = ' ';
			*s++ = '-';
			*s++ = ' ';
		}
		s = strcopy(s, "Proprietary");
		p = comment(p, buf, s - buf, 1);
		p = comment(p, ((char*)0), 0, 0);
		if (notice.item[4].data)
		{
			s = strcopy(buf, "This is proprietary source code");
			if (notice.item[3].data || notice.item[0].data)
				s = strcopy(s, " licensed by");
			p = comment(p, buf, s - buf, 1);
			if (x = notice.item[3].data)
			{
				s = memcopy(buf, x, notice.item[3].size);
				s = strcopy(s, " Corp.");
				p = comment(p, buf, s - buf, 1);
			}
			else if (x = notice.item[0].data)
				p = comment(p, x, notice.item[0].size, 1);
		}
		else
		{
			s = strcopy(buf, "This is unpublished proprietary source code");
			if (x) s = strcopy(s, " of");
			p = comment(p, buf, s - buf, 1);
			s = buf;
			if (x = notice.item[3].data)
				s = memcopy(s, x, notice.item[3].size);
			if (x = notice.item[0].data)
			{
				if (s > buf)
					*s++ = ' ';
				s = memcopy(s, x, notice.item[0].size);
			}
			if (s > buf)
				p = comment(p, buf, s - buf, 1);
			p = comment( p, "and is not to be disclosed or used except in",sizeof( "and is not to be disclosed or used except in")-1, 1);
			p = comment( p, "accordance with applicable agreements",sizeof( "accordance with applicable agreements")-1, 1);
		}
		p = comment(p, ((char*)0), 0, 0);
	}
	else if (notice.type == 1)
	{
		p = comment( p, "For nonexclusive individual use",sizeof( "For nonexclusive individual use")-1, 1);
		p = comment(p, ((char*)0), 0, 0);
	}
	s = strcopy(buf, "Copyright (c) ");
	time(&clock);
	s = memcopy(s, ctime(&clock) + 20, 4);
	if (x = notice.item[3].data)
	{
		*s++ = ' ';
		s = memcopy(s, x, notice.item[3].size);
		*s++ = ' ';
		s = strcopy(s, "Corp.");
	}
	else if (x = notice.item[0].data)
	{
		*s++ = ' ';
		s = memcopy(s, x, notice.item[0].size);
	}
	p = comment(p, buf, s - buf, 0);
	if (notice.type == 2)
	{
		if (!notice.item[4].data)
			p = comment( p, "Unpublished & Not for Publication",sizeof( "Unpublished & Not for Publication")-1, 0);
		p = comment( p, "All Rights Reserved",sizeof( "All Rights Reserved")-1, 0);
	}
	p = comment(p, ((char*)0), 0, 0);
	if (notice.item[4].data)
	{
		s = strcopy(buf, "This software is licensed");
		if (x = notice.item[3].data)
		{
			s = strcopy(s, " by ");
			s = memcopy(s, x, notice.item[3].size);
			*s++ = ' ';
			s = strcopy(s, "Corp.");
		}
		else if (x = notice.item[0].data)
		{
			s = strcopy(s, " by ");
			s = memcopy(s, x, notice.item[0].size);
		}
		p = comment(p, buf, s - buf, 0);
		p = comment( p, "under the terms and conditions of the license in",sizeof( "under the terms and conditions of the license in")-1, 0);
		p = comment(p, notice.item[4].data, notice.item[4].size, 0);
		p = comment(p, ((char*)0), 0, 0);
	}
	else if (notice.type == 2)
	{
		p = comment( p, "The copyright notice above does not evidence any",sizeof( "The copyright notice above does not evidence any")-1, 0);
		p = comment( p, "actual or intended publication of such source code",sizeof( "actual or intended publication of such source code")-1, 0);
		p = comment(p, ((char*)0), 0, 0);
	}
	if (x = notice.item[1].data)
	{
		p = comment( p, "This software was created by the",sizeof( "This software was created by the")-1, 0);
		p = comment(p, x, notice.item[1].size, 0);
		s = buf;
		if (x = notice.item[3].data)
			s = memcopy(s, x, notice.item[3].size);
		if (x = notice.item[0].data)
		{
			if (s > buf)
				*s++ = ' ';
			s = memcopy(s, x, notice.item[0].size);
		}
		if (s > buf)
			p = comment(p, buf, s - buf, 0);
		p = comment(p, ((char*)0), 0, 0);
	}
	if (x = notice.item[2].data)
	{
		p = comment( p, "For further information contact",sizeof( "For further information contact")-1, 0);
		p = comment(p, x, notice.item[2].size, 0);
		p = comment(p, ((char*)0), 0, 0);
	}
	p = comment(p, ((char*)0), -1, 0);
	return(p);
}







 




static char*
number __PARAM__((register char* p, register long n), (p, n)) __OTORP__(register char* p; register long n;){
	register long	d;

	for (d = 1000000; d > 1; d /= 10)
		if (n >= d) *p++ = '0' + (n / d) % 10;
	*p++ = '0' + n % 10;
	return(p);
}






static void
proto_error __PARAM__((char* iob, int level, char* msg, char* arg), (iob, level, msg, arg)) __OTORP__(char* iob; int level; char* msg; char* arg;){
	register char*	p;
	char		buf[1024];

	p = strcopy(buf, "proto: ");
	if (iob)
	{
		register struct proto*	proto = (struct proto*)(iob - sizeof(struct proto));

		if (proto->line)
		{
			if (proto->file)
			{
				*p++ = '"';
				p = strcopy(p, proto->file);
				*p++ = '"';
				*p++ = ',';
				*p++ = ' ';
			}
			p = strcopy(p, "line ");
			p = number(p, proto->line);
		}
		else if (proto->file) p = strcopy(p, proto->file);
	}
	else
	{
		p = strcopy(p, msg);
		msg = arg;
		arg = 0;
	}
	*p++ = ':';
	*p++ = ' ';
	if (level == 1) p = strcopy(p, "warning: ");
	p = strcopy(p, msg);
	if (arg)
	{
		*p++ = ' ';
		p = strcopy(p, arg);
	}
	*p++ = '\n';
	write(2, buf, p - buf);
	if (level >= 3) exit(level - 2);
	if (level >= 2) errors++;
}



 




static char*
linesync __PARAM__((register struct proto* proto, register char* p, register long n), (proto, p, n)) __OTORP__(register struct proto* proto; register char* p; register long n;){

	if (proto->flags & (1L<<12))

	{
		p = strcopy(p, "\n#line ");




		p = number(p, n);
		*p++ = '\n';
	}
	return(p);
}

 




static char*
init __PARAM__((char* op, int flags), (op, flags)) __OTORP__(char* op; int flags;){
	if (flags & (1L<<9)) op = strcopy(op, "\
\n\
#if !defined(__PROTO__)\n\
#if defined(__STDC__) || defined(__cplusplus) || defined(_proto) || defined(c_plusplus)\n\
#if defined(__cplusplus)\n\
#define __MANGLE__	\"C\"\n\
#else\n\
#define __MANGLE__\n\
#endif\n\
#define __STDARG__\n\
#define __PROTO__(x)	x\n\
#define __OTORP__(x)\n\
#define __PARAM__(n,o)	n\n\
#if !defined(__STDC__) && !defined(__cplusplus)\n\
#if !defined(c_plusplus)\n\
#define const\n\
#endif\n\
#define signed\n\
#define void		int\n\
#define volatile\n\
#define __V_		char\n\
#else\n\
#define __V_		void\n\
#endif\n\
#else\n\
#define __PROTO__(x)	()\n\
#define __OTORP__(x)	x\n\
#define __PARAM__(n,o)	o\n\
#define __MANGLE__\n\
#define __V_		char\n\
#define const\n\
#define signed\n\
#define void		int\n\
#define volatile\n\
#endif\n\
#if defined(__cplusplus) || defined(c_plusplus)\n\
#define __VARARG__	...\n\
#else\n\
#define __VARARG__\n\
#endif\n\
#if defined(__STDARG__)\n\
#define __VA_START__(p,a)	va_start(p,a)\n\
#else\n\
#define __VA_START__(p,a)	va_start(p)\n\
#endif\n\
#endif\n\
");
		else op = strcopy(op, "\
\n\
#if !defined(__PROTO__)\n\
#include <prototyped.h>\n\
#endif\n\
");
	return(op);
}















 





static int
lex __PARAM__((register struct proto* proto, register long flags), (proto, flags)) __OTORP__(register struct proto* proto; register long flags;){
	register char*		ip;
	register char*		op;
	register int		c;
	register int		state;
	register short*		rp;
	char*			m;
	char*			e;
	char*			t;
	char*			bp;
	char*			v;
	char*			im;
	char*			ko;
	char*			aom;
	int			n;
	int			line;
	int			quot;
	int			x;
	int			vc;

	char*			ie = 0;
	char*			om = 0;
	char*			aim = 0;
	char*			aie = 0;
	int			call = 0;
	int			group = 0;
	int			last = 0;
	int			paren = 0;

	char*			qe = 0;
	int			qn = 0;
	int			args = 0;


	((ip=proto->ip),(op=proto->op));

	if (flags & (1L<<5)) (ko=op);

 fsm_start:
	proto->tp = ip;
	state = 0;
	bp = ip;
	do
	{
		rp = _pp_fsmtab[state];
 fsm_get:
		while (!(state = rp[c = (*(unsigned char*)ip++)]));
 fsm_next:
		;
	} while (state > 0);
	if ((n = ip - bp - 1) > 0)
	{
		ip = bp;
		do switch( n) { default : memcpy( op, ip, n); op += n; ip += n; break; case 7 : * op++ = * ip++; case 6 : * op++ = * ip++; case 5 : * op++ = * ip++; case 4 : * op++ = * ip++; case 3 : * op++ = * ip++; case 2 : * op++ = * ip++; case 1 : * op++ = * ip++; case 0 : break; } while (0);
		ip++;
	}
	state = ~state;
 fsm_terminal:
	switch ((( state)&((1<<(7+1))-1)))
	{
	case ((0+26)+11):
		if (op > proto->ob && *(op - 1) == '=' && (op == proto->ob + 1 || *(op - 2) != '=')) switch (c)
		{
		case '+':
		case '-':
		case '*':
		case '&':
			(*op++=( ' '));
			break;
		}
		(*op++=( c));
		break;

	case ((0+26)+0):
		(ip--);
		c = (*(op-1));
		break;

	case ((0+26)+1):
		switch (c)
		{
		case '\n':
			if ((( rp)>=_pp_fsmtab[(0+14)]&&( rp)<=_pp_fsmtab[(0+16)])) goto fsm_newline;
			(*op++=( c));
			proto->line++;
			rp = _pp_fsmtab[(0+11)];
			break;
		case '/':

			if ((flags & ((1L<<5)|(1L<<14))) == (1L<<5)) (op=ko);
			else

			(*op++=( c));
			if ((( rp)>=_pp_fsmtab[(0+14)]&&( rp)<=_pp_fsmtab[(0+16)]))
			{
				rp = _pp_fsmtab[(0+14)];
				break;
			}
			goto fsm_start;
		case (255+1):
			break;
		default:

			if ((flags & ((1L<<5)|(1L<<14))) == (1L<<5)) (op=ko);
			else

			(*op++=( c));
			rp = _pp_fsmtab[(( rp)>=_pp_fsmtab[(0+14)]&&( rp)<=_pp_fsmtab[(0+16)]) ? (0+14) : (0+12)];
			break;
		}
		bp = ip;
		goto fsm_get;

	case ((0+26)+2):
		if (c)
		{
			if (state = _pp_fsmtab[(0+26)][((( rp)-_pp_fsmtab[0])/(255+1))+1])
				goto fsm_terminal;
			do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
			return(0);
		}
		(ip--);
 fsm_eob:
		if ((flags & ((1L<<1)|((1L<<15))|(1L<<20))) == ((1L<<15)) && (proto->flags & (1L<<15)))
		{

			if (!(flags & (1L<<5)))  

			flags |= (1L<<24);
			c = ip - proto->ib;
			if (!(flags & (1L<<14))) im = proto->tp;
			n = ip - im;
			if (ip - n < proto->ib)
				proto->flags |= (1L<<4);
			memcopy(proto->ib - n, ip - n, n);
			ip = proto->ib;
			proto->tp -= c;
			if (flags & (1L<<14))
			{
				im -= c;
				ie -= c;
			}
			if (aim) aim -= c;
			if (aie) aie -= c;
			if ((n = read(proto->fd, ip, proto->iz)) > 0)
			{
				if ((proto->flags & (1L<<21)) && n < proto->iz)
				{
					proto->flags &= ~(1L<<15);
					close(proto->fd);
				}
				*(ip + n) = 0;
				if (state & (1<<7)) goto fsm_splice;
				bp = ip;
				goto fsm_get;
			}
			*ip = 0;
			proto->flags &= ~(1L<<15);
			close(proto->fd);
		}
		if (state & (1<<7)) goto fsm_splice;
 
		if (!(flags & (1L<<20)) && (state = rp[c = (255+1)]))
		{
			bp = ip;
			goto fsm_next;
		}
		do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
		return(0);

	case ((0+26)+3):
		quot = c;

		if (c == '"' && qe)
		{
			for (n = 0, t = qe + 1; t < op && (*t == ' ' || *t == '\t' || *t == '\n' && ++n); t++);
			if (t == op)
			{
				op = qe;
				qe = 0;
				qn = n;
			}
			else (*op++=( c));
		}
		else

		(*op++=( c));
		rp = _pp_fsmtab[(0+19)];
		bp = ip;
		goto fsm_get;

	case ((0+26)+4):
		if (c == quot)
		{

			if (!(flags & (1L<<3)))
				qe = (c == '"') ? op : (char*)0;

			(*op++=( c));

			while (qn > 0)
			{
				qn--;
				(*op++=( '\n'));
			}

		}
		else if (c != '\n' && c != (255+1))
		{
			(*op++=( c));
			bp = ip;
			goto fsm_get;
		}
		else
		{

			while (qn > 0)
			{
				qn--;
				(*op++=( '\n'));
			}

			(ip--);
		}
		c = (0401+1);
		break;

	case ((0+26)+5):

		if (flags & (1L<<0)) (*op++=( c));
		else

		switch (c)
		{
		case 'a':
			(*op++=( '0'));
			(*op++=( '0'));
			(*op++=( '7'));
			break;
		case 'v':
			(*op++=( '0'));
			(*op++=( '1'));
			(*op++=( '3'));
			break;
		case 'x':
			do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
			lex(proto, (flags & ((1L<<15))) | (1L<<20));
			for (n = x = 0; (c = (*(unsigned char*)ip++)), x < 3; x++) switch (c)
			{
			case '0': case '1': case '2': case '3':
			case '4': case '5': case '6': case '7':
			case '8': case '9':
				n = (n << 4) + c - '0';
				break;
			case 'a': case 'b': case 'c': case 'd':
			case 'e': case 'f':
				n = (n << 4) + c - 'a' + 10;
				break;
			case 'A': case 'B': case 'C': case 'D':
			case 'E': case 'F':
				n = (n << 4) + c - 'A' + 10;
				break;
			default:
				goto fsm_hex;
			}
 fsm_hex:
			(ip--);
			(*op++=( ((n >> 6) & 07) + '0'));
			(*op++=( ((n >> 3) & 07) + '0'));
			(*op++=( (n & 07) + '0'));
			break;
		default:
			(*op++=( c));
			break;
		}
		rp = _pp_fsmtab[(0+19)];
		bp = ip;
		goto fsm_get;

	case ((0+26)+6):
		(ip--);

		if ((flags & (1L<<5)) && *proto->tp == 's' && !sstrncmp( proto->tp, "static", 6))
		{
			c = ((0500+4)+9);
			break;
		}

		if (*proto->tp == '_' && !sstrncmp( proto->tp, "__STDPP__directive", 6)) c = '#';
		else c = (0401+0);

		break;

	case ((0+26)+7):
 fsm_newline:
		proto->line++;

		if (flags & (1L<<5))
		{
			if (op != proto->ob && (*(op-1)) != ' ' && (*(op-1)) != '\n')
				(*op++=( ' '));
		}
		else

		(*op++=( c));
		if (flags & (1L<<3))
		{

			if (flags & (1L<<0))
			{
				if (flags & (1L<<5)) (op=ko);
				if (flags & (1L<<11))
				{
					*(ip - 1) = 0;
					op = strcopy(om, "/* ");
					op = strcopy(op, im);
					op = strcopy(op, " */\n");
				}
				flags &= ~((1L<<2)|(1L<<3)|(1L<<6)|(1L<<7)|(1L<<11)|(1L<<14)|(1L<<22)|(1L<<26));
			}
			else

			{
				if ((flags & ((1L<<2)|(1L<<22))) == ((1L<<2)|(1L<<22)))
				{
					*(ip - 1) = 0;
					op = strcopy(om, "#if defined(__STDC__) || defined(__STDPP__)\n");
					op = strcopy(op, im);
					op = strcopy(op, "\n#else\n");
					bp = ip;
					ip = im;
					*op++ = *ip++;
					while (*op = *ip++)
						if (*op++ == '#' && *ip != '(')
						{
							op--;
							while (*--op == ' ' || *op == '\t');
							if (*ip == '#')
							{
								op = strcopy(op + 1, "/**/");
								while (*++ip == ' ' || *ip == '\t');
							}
							else
							{
								if (*op != '"') *++op = '"';
								op++;
								while (*ip == ' ' || *ip == '\t') ip++;
								while ((c = *ip) >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c == '_') *op++ = *ip++;
								while (*ip == ' ' || *ip == '\t') ip++;
								if (*ip == '"') ip++;
								else *op++ = '"';
							}
						}
					ip = bp;
					op = strcopy(op, "\n#endif\n");
					op = linesync(proto, op, proto->line);
				}
				flags &= ~((1L<<2)|(1L<<3)|(1L<<6)|(1L<<7)|(1L<<14)|(1L<<16)|(1L<<22)|(1L<<23)|(1L<<26));
			}
			call = 0;
			group = 0;
			paren = 0;
			last = '\n';
		}
		if (paren == 0 && (flags & ((1L<<14)|(1L<<20)|(1L<<23)|(1L<<24))) == (1L<<24))
		{

			if (flags & (1L<<5)) (op=ko);

			do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
			return(0);
		}
		goto fsm_start;

	case ((0+26)+8):
		(*op++=( c));
		rp = _pp_fsmtab[((( state)>>(7+1))&((1<<7)-1))];
		bp = ip;
		goto fsm_get;

	case ((0+26)+13):
		(*op++=( c));
		c = (((( state)>>(7+1))&((1<<7)-1))+0401);
		break;

	case ((0+26)+14):
		(ip--);
		c = (((( state)>>(7+1))&((1<<7)-1))+0401);
		break;

	case (((0+26)+12)):
		(ip--);
		c = (0401+0);
		if (!(flags & (1L<<1))) switch (((((long)( *proto->tp))<<16)|(((long)( *(ip - 1)))<<8)|((long)( ip - proto->tp))))
		{
		case ((((long)( 'd'))<<16)|(((long)( 'o'))<<8)|((long)( 2))):
			c = ((0500+4)+6);
			break;
		case ((((long)( 'e'))<<16)|(((long)( 'e'))<<8)|((long)( 4))):
			if (!(flags & (1L<<20)) && !sstrncmp( proto->tp, "else", 4))
			{
				c = ((0500+4)+8);
				goto fsm_id;
			}
			break;
		case ((((long)( 'e'))<<16)|(((long)( 'n'))<<8)|((long)( 6))):
			if (!sstrncmp( proto->tp, "extern", 6))
				c = ((0500+4)+9);
			break;
		case ((((long)( 'f'))<<16)|(((long)( 'r'))<<8)|((long)( 3))):
			if (!(flags & (1L<<20)) && !sstrncmp( proto->tp, "for", 3))
			{
				c = ((0500+4)+11);
				goto fsm_id;
			}
			break;
		case ((((long)( 'i'))<<16)|(((long)( 'f'))<<8)|((long)( 2))):
			c = ((0500+4)+13);
			break;
		case ((((long)( 'r'))<<16)|(((long)( 'n'))<<8)|((long)( 6))):
			if (!(flags & (1L<<20)) && !sstrncmp( proto->tp, "return", 6))
			{
				c = ((0500+4)+17);
				goto fsm_id;
			}
			break;
		case ((((long)( 't'))<<16)|(((long)( 'f'))<<8)|((long)( 7))):
			if (!(flags & (1L<<20)) && !sstrncmp( proto->tp, "typedef", 7))
			{
				flags |= (1L<<26);
				c = ((0500+4)+9);
			}
			break;
		case ((((long)( 'v'))<<16)|(((long)( 't'))<<8)|((long)( 8))):
			if (*ip == '(' && !sstrncmp( proto->tp, "va_start", 8)) c = (0500+1);
			break;
		case ((((long)( 'v'))<<16)|(((long)( 'd'))<<8)|((long)( 4))):
			if (!sstrncmp( proto->tp, "void", 4))
			{
				if (flags & ((1L<<0)|(1L<<18)|(1L<<9)|(1L<<10))) c = ((0500+4)+30);
				else
				{
					do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
					line = proto->line;
					if (lex(proto, (flags & ((1L<<15))) | (1L<<20)) == '*')
					{
						memcopy(op - 4, "__V_", 4);
						memcopy(ip - 4, "__V_", 4);
					}
					else c = ((0500+4)+30);
					proto->line = line;
					do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
					bp = ip;
				}
			}
			break;
		case ((((long)( 'w'))<<16)|(((long)( 'e'))<<8)|((long)( 5))):
			if (!(flags & (1L<<20)) && !sstrncmp( proto->tp, "while", 5))
			{
				c = ((0500+4)+26);
				goto fsm_id;
			}
			break;
		}

		if ((flags & (1L<<0)) && c != ((0500+4)+9))
			c = (0401+0);

		break;

	case ((0+26)+10):
		goto fsm_start;

	case ((0+26)+15):
		(ip--);

		if ((flags & ((1L<<5)|(1L<<14))) == (1L<<5))
		{
			while (op > proto->ob && (*(op - 1) == ' ' || *(op - 1) == '\t'))
				op--;
			if (op > proto->ob && *(op - 1) != '\n') *op++ = ' ';
		}

		goto fsm_start;

	default:
		if (c == '\\' && (state & (1<<7)))
		{
			if (!(n = (*(unsigned char*)ip++)))
			{
				goto fsm_eob;
 fsm_splice:
				c = '\\';
				n = (*(unsigned char*)ip++);
			}
			if (n == '\n')
			{
				proto->line++;
				(*op++=( '\\'));
				(*op++=( '\n'));
				bp = ip;
				goto fsm_get;
			}
			(ip--);
			state &= ~(1<<7);
			if (state >= (0+26)) goto fsm_terminal;
			rp = _pp_fsmtab[state];
		}
		(*op++=( c));
		bp = ip;
		goto fsm_get;
	}
	if (!(flags & ((1L<<9)|(1L<<10)|(1L<<20))))
	{
		if (!(flags & (1L<<3))) switch (c)
		{
		case '(':

			if (!(flags & (1L<<0)) || proto->brace == 0)

			{
				if (paren++ == 0)
				{

					if (!(flags & (1L<<0)) || group <= 1)

					{

						args = 0;

						if (group++ == 0) group++;
						else if (flags & (1L<<7)) call++;
						flags |= (1L<<14);
						im = ip - 1;
						om = op - 1;
					}
				}
				else if (paren == 2 && !aim)
				{
					if (flags & (1L<<7))
					{
						aim = ip - 1;
						aom = op - 1;
					}
					else if ((flags & ((1L<<14)|(1L<<25))) == (1L<<14))
					{
						for (m = ip - 2; m > im && (*m == ' ' || *m == '\t'); m--);
						if (m == im)
						{
							flags &= ~(1L<<14);
							om = 0;
						}
					}
				}
				flags &= ~(1L<<25);
			}
			break;
		case ')':

			if (!(flags & (1L<<0)) || proto->brace == 0)

			if (--paren == 0)
			{

				if (flags & (1L<<0))
				{
					if (group != 2)
					{
						c = (0401+0);
						break;
					}
					group++;
				}

				ie = ip;
			}
			else if (paren == 1 && (flags & (1L<<7)) && !aie)
				aie = ip;
			break;
		case '*':
			if (last == '(' && group == 2)
			{
				group--;
				if (paren == 1)
				{
					flags |= (1L<<7);
					aim = aie = 0;
				}
			}
			break;
		case '#':
 fsm_directive:
			if (!(flags & ((1L<<1)|(1L<<3))))
			{
				flags |= (1L<<3);
				if (!(flags & (1L<<18)))
				{
					bp = ip;
					while (*ip == ' ' || *ip == '\t') ip++;
					if (*ip == 'l' && *++ip == 'i' && *++ip == 'n' && *++ip == 'e')
					{
						if (*++ip == ' ' || *ip == '\t')
						{
							proto->line = 0;
							while (*++ip >= '0' && *ip <= '9')
								proto->line = proto->line * 10 + *ip - '0';
							proto->line--;
						}
					}

					else if ((flags & ((1L<<0)|(1L<<5))) == (1L<<0))
					{
						n = 0;
						t = ip + 6;
						while (ip < t && *ip >= 'a' && *ip <= 'z') n = (n << 5) | (*ip++ - 'a');
						switch (n)
						{
						case   ((('e'-'a')<<15)|(('l'-'a')<<10)|(('s'-'a')<<5)|('e'-'a')):
						case   ((('e'-'a')<<20)|(('n'-'a')<<15)|(('d'-'a')<<10)|(('i'-'a')<<5)|('f'-'a')):
							while (*ip == ' ' || *ip == '\t') ip++;
							if (*ip != '\n' && *ip != '/' && *(ip + 1) != '*')
							{
								flags |= (1L<<11)|(1L<<14);
								im = ip;
								om = op + (ip - bp);
							}
							break;
						case   ((('e'-'a')<<15)|(('l'-'a')<<10)|(('i'-'a')<<5)|('f'-'a')):
						case   ((('e'-'a')<<20)|(('r'-'a')<<15)|(('r'-'a')<<10)|(('o'-'a')<<5)|('r'-'a')):
						case   ((('i'-'a')<<5)|('f'-'a')):
						case   ((('i'-'a')<<20)|(('f'-'a')<<15)|(('d'-'a')<<10)|(('e'-'a')<<5)|('f'-'a')):
						case   ((('i'-'a')<<25)|(('f'-'a')<<20)|(('n'-'a')<<15)|(('d'-'a')<<10)|(('e'-'a')<<5)|('f'-'a')):
						case   ((('u'-'a')<<20)|(('n'-'a')<<15)|(('d'-'a')<<10)|(('e'-'a')<<5)|('f'-'a')):
							break;
						case   ((('i'-'a')<<25)|(('n'-'a')<<20)|(('c'-'a')<<15)|(('l'-'a')<<10)|(('u'-'a')<<5)|('d'-'a')):
							if (*ip == 'e') ip++;
 
						case   ((('d'-'a')<<25)|(('e'-'a')<<20)|(('f'-'a')<<15)|(('i'-'a')<<10)|(('n'-'a')<<5)|('e'-'a')):
						case   ((('p'-'a')<<25)|(('r'-'a')<<20)|(('a'-'a')<<15)|(('g'-'a')<<10)|(('m'-'a')<<5)|('a'-'a')):
							if (*ip < 'a' || *ip > 'z') break;
 
						default:
							flags |= (1L<<11)|(1L<<14);
							im = bp - 1;
							om = op - 1;
							break;
						}
					}
					else

					{
						if (*ip == 'i' && *++ip == 'n' && *++ip == 'c' && *++ip == 'l' && *++ip == 'u' && *++ip == 'd' && *++ip == 'e')
						{
							while (*++ip == ' ' || *ip == '\t');
							if (*ip++ == '<' && *ip++ == 's' && *ip++ == 't' && *ip++ == 'd' && *ip++ == 'a' && *ip++ == 'r' && *ip++ == 'g' && *ip++ == '.' && *ip++ == 'h' && *ip++ == '>')
							{
								op = strcopy(op, "\
if !defined(va_start)\n\
#if defined(__STDARG__)\n\
#include <stdarg.h>\n\
#else\n\
#include <varargs.h>\n\
#endif\n\
#endif\n\
");
								op = linesync(proto, op, proto->line);
								break;
							}
						}
						else if (*ip == 'd' && *++ip == 'e' && *++ ip == 'f' && *++ip == 'i' && *++ip == 'n' && *++ip == 'e' && (*++ip == ' ' || *ip == '\t'))
						{
							flags |= (1L<<2)|(1L<<14);
							im = bp - 1;
							om = op - 1;
						}
					}
					ip = bp;
				}
			}
			break;
		case '{':
			if (proto->brace++ == 0 && paren == 0)
			{
				if (last == '=') flags |= (1L<<8);

				else if (flags & (1L<<0))
				{
					if ((flags & ((1L<<14)|(1L<<16)|(1L<<23))) == (1L<<14))
					{
						if (args)
						{
							v = number(op, args < 0 ? -args : args);
							v = strcopy(v, " argument actual/formal mismatch");
							*v++ = ' ';
							v = memcopy(v, im, ie - im);
							*v = 0;
							proto_error((char*)proto + sizeof(struct proto), 2, op, ((char*)0));
						}
						ip--;
 
	v = ie;
	while (ie < ip)
		if (*ie++ == '/' && *ie == '*')
		{
			e = ie - 1;
			while (++ie < ip)
			{
				if (*ie == '*')
				{
					while (ie < ip && *ie == '*') ie++;
					if (ie < ip && *ie == '/')
					{
						while (++ie < ip && (*ie == ' ' || *ie == '\t'));
						while (e > v && (*(e - 1) == ' ' || *(e - 1) == '\t')) e--;
						if (e > v && *e != '\n') *e++ = ' ';
						t = ie;
						while (--e >= v)
							*--t = *e;
						v = t;
						break;
					}
				}
			}
		}
	ie = v;
 
						op = om++;
						if (flags & (1L<<5))
						{
							v = op;
							while (v > ko && *--v != ' ');
							if (*v != ' ')
							{
								om = (v = (op += 4)) + 1;
								while (v >= ko + 4)
								{
									*v = *(v - 4);
									v--;
								}
								memcopy(ko, "int ", 4);
							}
							if (*v == ' ')
							{
								while (*(v + 1) == '*')
									*v++ = '*';
								*v = '\t';
								if ((v - ko) <= 8)
								{
									om = (e = ++op) + 1;
									while (e > v)
									{
										*e = *(e - 1);
										e--;
									}
								}
							}
							om = (v = (op += 7)) + 1;
							while (v >= ko + 7)
							{
								*v = *(v - 7);
								v--;
							}
							memcopy(ko, "extern ", 7);
						}
						(*op++=( '('));
						t = op;
						e = 0;
 
	while (ie < ip)
	{
		if ((c = *ie) == ' ' || c == '\t' || c == '\n')
		{
			while ((c = *++ie) == ' ' || c == '\t' || c == '\n');
			if (ie >= ip) break;
			if (c != '*' && op > om) (*op++=( ' '));
		}
		if ((n = ((c = *ie) == ',')) || c == ';')
		{
			if (flags & (1L<<5))
			{
				m = op;
				while (op > om && ((c = *(op - 1)) == '(' || c == ')' || c == '[' || c == ']'))
					op--;
				v = op;
				while (op > om && (c = *(op - 1)) != ' ' && c != '*')
					op--;
				while (*(op - 1) == ' ')
					op--;
				if (!e)
				{
					e = op;
					while (e > om && *(e - 1) == '*')
						e--;
				}




				if (op <= om)
					op = strcopy(op, "int");
				else if (*(op - 1) == ',')
					op = strcopy(op, " int");

				while (v < m)
					(*op++=( *v++));
			}
			(*op++=( ','));
			if (n)
			{
				if (x = !e) e = op - 1;
				(*op++=( ' '));
				m = t;
				while (m < e)
					(*op++=( *m++));
				if (x)
				{
					m = e;
					while (*--e != ' ');
					while (*(e - 1) == '*') e--;
					op -= m - e;
				}
			}
			while ((c = *++ie) == ' ' || c == '\t' || c == '\n');
			if (ie >= ip) (op--);
			else (*op++=( ' '));
			if (!n)
			{
				t = op;
				e = 0;
			}
		}
		else if (*ie == '*')
		{
			if (op > om && (c = *(op - 1)) == ' ') op--;
			while (*ie == '*') (*op++=( *ie++));
			while (*ie == ' ' || *ie == '\t' || *ie == '\n') ie++;
			if (c != '(') (*op++=( ' '));
		}
		else if (*ie == '(')
		{
			if (op > om && *(op - 1) == ' ') op--;
			(*op++=( *ie++));
			while (*ie == ' ' || *ie == '\t' || *ie == '\n') ie++;
		}
		else if (*ie == ')')
		{
			if (op > om && *(op - 1) == '(')
				proto_error((char*)proto + sizeof(struct proto), 1, "function pointer argument prototype omitted", ((char*)0));
			(*op++=( *ie++));
			while (*ie == ' ' || *ie == '\t' || *ie == '\n') ie++;
		}
		else if ((flags & (1L<<5)) && (op == om || *(op - 1) == ' ') && *ie == 'r' && !sstrncmp( ie, "register", 8) && (*(ie + 8) == ' ' || *(ie + 8) == '\t' || *(ie + 8) == '\n'))
		{
			ie += 8;
			if (op > om) (op--);
		}
		else (*op++=( *ie++));
	}
 
						if (op <= om) op = strcopy(op, "void");
						(*op++=( ')'));
						if (flags & (1L<<5))
						{
							(*op++=( ';'));
							(*op++=( '\n'));
							(proto->op=op);
							(ko=op);
						}
						else
						{
							(*op++=( '\n'));
							(*op++=( *ip));
						}
						ip++;
						flags &= ~((1L<<14)|(1L<<23));
					}
				}

				else if ((flags & ((1L<<14)|(1L<<18)|(1L<<23)|(1L<<25))) == ((1L<<14)|(1L<<25)))
				{
					line = proto->line;
					op = strcopy(om, " __PARAM__(");
					op = memcopy(op, im, ie - im);
					(*op++=( ','));
					(*op++=( ' '));
					(*op++=( '('));
					flags &= ~((1L<<14)|(1L<<23));
					if (flags & (1L<<27))
					{
						if ((vc = ie - im + 1) > sizeof(proto->variadic)) vc = sizeof(proto->variadic);
						memcopy(proto->variadic, im, vc);
						op = strcopy(op, "va_alist)) __OTORP__(va_dcl)\n{");
					}
					else
					{
						flags |= (1L<<23);
						proto->ip = im;
						proto->op = op;
						group = 0;
						for (;;)
						{
							switch (lex(proto, (flags & ((1L<<15))) | (1L<<20)))
							{
							case '(':
								if (paren++) group++;
								continue;
							case ')':
								if (--paren == 0)
								{
									group = 0;
									if (flags & (1L<<14))
									{
										flags &= ~((1L<<14)|(1L<<23));
										op = memcopy(op, m, e - m);
									}
									break;
								}
								continue;
							case ',':
								if (paren == 1)
								{
									group = 0;
									if (flags & (1L<<14))
									{
										flags &= ~((1L<<14)|(1L<<23));
										op = memcopy(op, m, e - m);
									}
									(*op++=( ','));
									(*op++=( ' '));
									proto->op = op;
								}
								continue;
							case (0401+0):
								if (group <= 1)
								{
									flags |= (1L<<14);
									m = proto->tp;
									e = proto->ip;
								}
								continue;
							default:
								continue;
							}
							break;
						}
						(*op++=( ')'));
						(*op++=( ')'));
					}
					if (!(flags & (1L<<23)))
					{
						flags |= (1L<<23);
						proto->op = strcopy(op, " __OTORP__(");
						proto->ip = im + 1;
						n = *(ie - 1);
						*(ie - 1) = ';';
						c = *ie;
						*ie = 0;
						lex(proto, (flags & ((1L<<15))) | (1L<<1));
						*(ie - 1) = n;
						*ie = c;
						proto->ip = ie;
						op = proto->op;
						(*op++=( ')'));
					}
					op = linesync(proto, op, proto->line = line);
					if (!(flags & (1L<<27))) (*op++=( '{'));
				}
			}
			flags &= ~((1L<<6)|(1L<<7)|(1L<<14)|(1L<<16)|(1L<<23));
			call = 0;
			group = 0;
			break;
		case '}':
			flags &= ~((1L<<6)|(1L<<7)|(1L<<14)|(1L<<16)|(1L<<23)|(1L<<25));
			if (--proto->brace == 0)
			{
				flags &= ~((1L<<8)|(1L<<27)|(1L<<28));

				if (flags & (1L<<5)) (op=ko);

			}
			call = 0;
			group = 0;
			paren = 0;
			break;
		case '=':
			if (last == '?') flags |= (1L<<3);
			else if (paren == 0 && (flags & ((1L<<8)|(1L<<14)|(1L<<23))) == (1L<<14)) goto fsm_statement;
			goto fsm_other;
		case ',':

			if (flags & (1L<<0))
			{
				if (paren == 1) args++;
				else
				{
					args--;
					flags &= ~(1L<<14);
				}
				break;
			}

			if (paren == 0 && (flags & (1L<<1))) *(op - 1) = c = ';';
 
		case ';':
 fsm_statement:
			if (flags & (1L<<8))  ;

			else if (flags & (1L<<0))
			{
				if (paren == 0)
				{
					if ((flags & (1L<<14)) && last == ')')
						flags &= ~(1L<<14);
					if (!(flags & (1L<<14)))
					{
						call = 0;
						group = 0;
						flags &= ~(1L<<23);
						if (flags & (1L<<5)) (op=ko);
						if (flags & (1L<<24))
						{
							do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
							return(0);
						}
					}
					else
					{
						args--;
						if ((flags & ((1L<<5)|(1L<<23))) == ((1L<<5)|(1L<<23)))
							(op=ko);
					}
				}
			}

			else if (paren == 0)
			{
				if ((flags & ((1L<<14)|(1L<<16)|(1L<<23))) == (1L<<14) && call > 1)
				{
					if ((flags & ((1L<<1)|(1L<<7))) == (1L<<7) && aim && aie < im)
					{
						while (aie < ip && (*aie == ' ' || *aie == '\t' || *aie == '\n')) aie++;
						v = aim;
						while (v < aie)
							if (*v++ == ')') break;
						while (v < aie && (*v == ' ' || *v == '\t' || *v == '\n')) v++;
						if (v == aie || !(flags & (1L<<19)))
						{
							if (flags & (1L<<19)) n = 3;
							else if (v == aie && *v == '(') n = 10;
							else n = 11;
							ko = op;
							om += n;
							v = op += n;
							while (v >= ko + n)
							{
								*v = *(v - n);
								v--;
							}
							if (flags & (1L<<19)) memcopy(aom, "(...))", 6);
							else if (n == 10) memcopy(aom, "(__VARARG__))", 13);
							else
							{
								ko = strcopy(aom, " __PROTO__(");
								ko = memcopy(ko, aim, aie - aim);
								*ko = ')';
								if (++ko >= om)
								{
									*ko++ = ')';
									om = ko;
								}
							}
						}
					}
					else if (flags & (1L<<26))
					{
						op = om;
						while (*--op == ' ' || *op == '\t' || *op == '\n');
						if (*op != ')')
						{
							op = om += 14;
							*--op = ')';
							while ((x = *(op - 14)) >= 'A' && x <= 'Z' || x >= 'a' && x <= 'z' || x >= '0' && x <= '9' || x == '_')
								*--op = x;
							memcopy(op - 13, "(__OTORP__(*)", 13);
						}
					}
					if (flags & (1L<<19))
					{
						if (!(flags & (1L<<25)))
						{
							op = strcopy(om, "(...)");
							(*op++=( c));
						}
					}
					else
					{
						if (flags & (1L<<1)) op = strcopy(om, "()");
						else if (!(flags & (1L<<25))) op = strcopy(om, "(__VARARG__)");
						else
						{
							op = strcopy(om, " __PROTO__(");
							op = memcopy(op, im, ie - im);
							(*op++=( ')'));
						}
						(*op++=( c));
					}
					flags &= ~((1L<<14)|(1L<<27)|(1L<<28));
					if (c == ',' && !(flags & (1L<<7)))
					{
						call = 1;
						group = 0;
						break;
					}
				}
				else if (flags & ((1L<<16)|(1L<<23))) call = 0;
				if (c == ';')
				{
					flags &= ~((1L<<13)|(1L<<26));
					if (flags & (1L<<24))
					{
						do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
						return(0);
					}
					call = 0;
				}
				else call = call > 1 && c == ',';
				group = 0;
				flags &= ~((1L<<6)|(1L<<7)|(1L<<14)|(1L<<16)|(1L<<23));
			}
			else if (paren == 1 && group == 1 && !(flags & ((1L<<6)|(1L<<13)))) flags |= (1L<<25)|(1L<<16);
			break;
		case ((0500+4)+6):
		case ((0500+4)+13):
			flags |= (1L<<25)|(1L<<23);
			break;
		case ((0500+4)+9):

			if (flags & (1L<<0))
			{
				if (proto->brace == 0)
					flags |= (1L<<23);
			}
			else

			if (paren == 0 && !(flags & (1L<<26)))
			{
				flags |= (1L<<13);
				if (!(flags & (1L<<18)))
					op = strcopy(op, " __MANGLE__");
			}
			break;
		case (0401+29):
			if (paren == 0 && (flags & ((1L<<1)|(1L<<27))) == (1L<<1))
			{
				op -= 3;
				do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
				return(c);
			}
			if (paren == 1 && !(flags & (1L<<23)))
				flags |= (1L<<27);
			flags |= (1L<<25);
			break;
		case ((0500+4)+30):
			goto fsm_id;
		case (0500+1):
			if ((flags & ((1L<<18)|(1L<<27))) == (1L<<27))
			{
				flags &= ~(1L<<14);
				line = proto->line;
				op = strcopy(op - 8, "__VA_START__");
				do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
				for (;;)
				{
					switch (lex(proto, (flags & ((1L<<15))) | (1L<<20)))
					{
					case 0:
					case ';':
						break;
					case (0401+0):
						if (!(flags & (1L<<14)))
						{
							flags |= (1L<<14);
							m = proto->tp;
							e = proto->ip;
						}
						continue;
					default:
						continue;
					}
					break;
				}
				((ip=proto->ip),(op=proto->op));
				if (flags & (1L<<14))
				{
					v = m;
					n = e - m;
				}
				else
				{
					v = "ap";
					n = 2;
				}
				op = strcopy(op, " __OTORP__(");
				proto->ip = proto->variadic;
				proto->op = op;
				flags &= ~(1L<<14);
				group = 0;
				bp = proto->ip + 1;
				if (*bp == 'r' && !sstrncmp( bp, "register", 8) && (*(bp + 8) == ' ' || *(bp + 8) == '\t')) bp += 9;
				for (;;)
				{
					switch (lex(proto, (flags & ((1L<<15))) | (1L<<20)))
					{
					case '(':
						if (paren++) group++;
						continue;
					case ')':
						if (--paren == 0)
						{
							if (flags & (1L<<14))
							{
								flags &= ~(1L<<14);
								if (!(flags & (1L<<28)))
								{
									op = memcopy(op, m, e - m);
									op = strcopy(op, " = ");
								}
								op = strcopy(op, "va_arg(");
								op = memcopy(op, v, n);
								(*op++=( ','));
								(*op++=( ' '));
								if (m > bp) op = memcopy(op, bp, m - bp);
								else op = strcopy(op, "int ");
								if (group > 1) op = strcopy(op, ")()");
								else op = memcopy(op, e, proto->ip - e - 1);
								(*op++=( ')'));
								(*op++=( ';'));
							}
							group = 0;
							break;
						}
						continue;
					case ',':
						if (paren == 1)
						{
							if (flags & (1L<<14))
							{
								flags &= ~(1L<<14);
								if (!(flags & (1L<<28)))
								{
									op = memcopy(op, m, e - m);
									op = strcopy(op, " = ");
								}
								op = strcopy(op, "va_arg(");
								op = memcopy(op, v, n);
								(*op++=( ','));
								(*op++=( ' '));
								if (m > bp) op = memcopy(op, bp, m - bp);
								else op = strcopy(op, "int ");
								if (group > 1) op = strcopy(op, ")()");
								else op = memcopy(op, e, proto->ip - e - 1);
								(*op++=( ')'));
								(*op++=( ';'));
								bp = proto->ip + 1;
								if (*bp == 'r' && !sstrncmp( bp, "register", 8) && (*(bp + 8) == ' ' || *(bp + 8) == '\t')) bp += 9;
							}
							group = 0;
							proto->op = op;
						}
						continue;
					case (0401+0):
						if (group <= 1)
						{
							flags |= (1L<<14);
							m = proto->tp;
							e = proto->ip;
						}
						continue;
					default:
						continue;
					}
					break;
				}
				op = strcopy(op, ")");
				flags |= (1L<<28);
				proto->line = line;
				call = 0;
				break;
			}
 
		case (0401+0):
 fsm_id:

			if (flags & (1L<<0))
			{
				if (!args && paren == 1) args++;
				break;
			}

			if (paren == 0)
			{
				if (last == ')')
				{
					if (proto->brace == 0 && !(flags & (1L<<1))) flags |= (1L<<23);
					call = !call;
				}
				else if ((flags & (1L<<23)) || c == (0401+0) || c == ((0500+4)+30)) call++;
				else flags |= (1L<<23);
				if (last == (0401+0)) flags |= (1L<<6);
			}
			c = (0401+0);
			flags |= (1L<<25);
			break;
		case (0401+1):
			if (*proto->tp >= '0' && *proto->tp <= '9')
				switch (*(op - 1))
				{
				case 'l':
				case 'L':
					switch (*(op - 2))
					{
					case 'l':
					case 'L':
					case 'u':
					case 'U':
						*(op - 2) = *(op - 1);
						op--;
						break;
					}
					break;
				case 'u':
				case 'U':
					op--;
					break;
				}
			goto fsm_other;

		case '[':
			if ((flags & (1L<<0)) && paren == 0 && group <= 2) flags |= (1L<<23);
 

		default:
 fsm_other:

			if (flags & (1L<<0)) break;

			flags |= (1L<<25);
			if (paren == 0) flags |= (1L<<16);
			break;
		}
		else if (c == '#' && *ip != '(') flags |= (1L<<22);
		last = c;

		if ((flags & ((1L<<5)|(1L<<14))) == ((1L<<5)|(1L<<14)) && ((flags & ((1L<<3)|(1L<<23))) || proto->brace || c != '(' && c != ')' && c != '*' && c != (0401+0)))
			(op=proto->op);
		else

		(proto->op=op);
		goto fsm_start;
	}
	else if (flags & ((1L<<9)|(1L<<10)))
	{

		if ((flags & (1L<<29)) && c == '%' && *ip == '{') t = 0;
		else

		{
			if (c == '#') for (t = ip; *t == ' ' || *t == '\t'; t++);
			else t = "";
			if (*t++ == 'i' && *t++ == 'f' && *t++ == 'n' && *t++ == 'd' && *t++ == 'e' && *t++ == 'f')
			{




					t = 0;
			}
		}
		if (t)
		{
			ip = bp;
			op = proto->op;
		}
		else while (*ip != '\n') *op++ = *ip++;
		op = init(op, flags);
		op = linesync(proto, op, proto->line);
		flags &= ~((1L<<9)|(1L<<10));
		proto->flags &= ~((1L<<9)|(1L<<10));
		goto fsm_start;
	}
	do{(proto->ip=ip);(proto->op=op);proto->flags&=~((1L<<8)|(1L<<27)|(1L<<28));proto->flags|=flags&((1L<<8)|(1L<<27)|(1L<<28));}while(0);
	return(c);
}

 



void
pppclose __PARAM__((char* iob), (iob)) __OTORP__(char* iob;){
	register struct proto*	proto = (struct proto*)(iob - sizeof(struct proto));

	if (proto->flags & (1L<<15)) close(proto->fd);
	free((char*)proto);  
}

 









char*
pppopen __PARAM__((char* file, int fd, char* notice, int flags), (file, fd, notice, flags)) __OTORP__(char* file; int fd; char* notice; int flags;){
	register struct proto*	proto;
	register char*		iob;
	register long		n;
	register char*		s;
	int			pragma;
	char*			b;

	int			comlen;
	char			com[(62+4)];

	int			m = 0;

	static int		retain;

 




	if (flags & (1<<0)) flags &= ~(1<<4);

	if (flags & (1<<10)) flags &= ~retain;
	else retain &= (1<<5);
	if (file && (fd = open(file, 0)) < 0) return(0);






















	{
 



		n = (4*1024);
		if (!(proto = (( 0)?( struct proto*)realloc((char*)( 0),sizeof( struct proto)*( 1)+( 5 * n + 2)):( struct proto*)calloc(1,sizeof( struct proto)*( 1)+( 5 * n + 2)))))
			return(0);
		proto->iz = n;
		proto->oz = 3 * n;
		proto->flags |= (1L<<15);
	}
	proto->fd = fd;
	iob = (char*)proto + sizeof(struct proto);
	proto->op = proto->ob = iob;
	proto->ip = proto->ib = iob + proto->oz + n;
	if (m) proto->flags |= (1L<<21);

 



	n = read(fd, proto->ip, proto->iz);
	if (!(proto->flags & (1L<<15)))
		close(fd);
	if (n < 0)
	{
		pppclose(iob);
		return(0);
	}
	*(proto->ip + n) = 0;

 











	if (notice)
	{
		s = comment(com, ((char*)0), 0, 0);
		comlen = s - com;
	}
	else *com = 0;

	pragma = -1;
	s = proto->ip;
	m = 64;
	while (m-- > 0 && *s)
	{
		while (*s == ' ' || *s == '\t') s++;
		if (*s == '#')
		{
			b = s++;
			while (*s == ' ' || *s == '\t') s++;
			if (!sstrncmp( s, "pragma", sizeof("pragma") - 1) && (*(s += sizeof("pragma") - 1) == ' ' || *s == '\t'))
			{
				while (*s == ' ' || *s == '\t') s++;
				if (*s == 'n' && *(s + 1) == 'o')
				{
					s += 2;
					pragma = -2;
				}
				if (!sstrncmp( s, "prototyped", sizeof("prototyped") - 1) && (*(s += sizeof("prototyped") - 1) == ' ' || *s == '\t' || *s == '\n' || *s == '\r'))
				{
					while (*s)
						if (*s++ == '\n')
						{
							pragma += 2;

							if (!(flags & (1<<1)) || (flags & (1<<7)))

							for (s--; b < s; *b++ = ' ');
							goto magic;
						}
				}
				pragma = -1;
			}
		}
		else if (*s == '/' && !sstrncmp( s, "/* : : generated by proto : : */\n", sizeof("/* : : generated by proto : : */\n") - 1))
		{
			pragma = 0;
			break;
		}

		else if (*s == '%' && *(s + 1) == '{') proto->flags |= (1L<<29);
		else if (notice)
		{
			if (*s == *com && !sstrncmp( s, com, comlen)) notice = 0;
			else
			{
				while (*s)
				{
					if (*s == *"Copyright"&& !sstrncmp( s, "Copyright", sizeof("Copyright") - 1))
					{
						s += sizeof("Copyright") - 1;
						while (*s == ' ' || *s == '\t') s++;
						if (*s == '(' && (*(s + 1) == 'c' || *(s + 1) == 'C') && *(s + 2) == ')')
							notice = 0;
					}
					else if (*s++ == '\n') break;
				}
				continue;
			}
		}

		while (*s && *s++ != '\n');
	}
 magic:
	if (flags & (1<<9)) proto->flags |= (1L<<19);
	if (flags & (1<<11)) proto->test = 1;

	if (flags & (1<<0)) pragma = -pragma;
	if (flags & (1<<1)) pragma = 0;
	if (flags & (1<<6)) proto->flags |= (1L<<12);
	if (!(proto->flags & (1L<<29)) && file && (m = sstrlen( file)) > 2 && file[--m] == 'y' && file[--m] == '.')
		proto->flags |= (1L<<29);

	if (pragma <= 0)
	{
		if (flags & (1<<9))
		{
			flags &= ~((1<<3)|(1<<4));
			proto->flags |= (1L<<18);
		}
		else if (!(flags & ((1<<2)|(1<<8))))
		{
			pppclose(iob);
			return(0);
		}
		else if ((flags & (1<<8)) || !pragma)
		{
			proto->flags |= (1L<<17);
			if (proto->flags & (1L<<15)) proto->oz += proto->iz;
			proto->iz = n;
			if (notice)
			{

				proto->op = copyright(proto->op, notice);
				if (!(flags & (1<<0)) && !(proto->flags & (1L<<29)))

				proto->op = linesync(proto, proto->op, 1);
				proto->iz += proto->op - proto->ob;
			}
			memcopy(proto->op, proto->ip, n);
			return(iob);
		}
	}

	if (!(retain & (1<<5)))
	{
		retain |= (1<<5);
		ppfsm(4, ((char*)0));
	}

	proto->line = 1;

	if (notice || (flags & ((1<<3)|(1<<4))))
	{

		if (notice) proto->op = copyright(proto->op, notice);

		if (flags & (1<<4))
		{
			proto->flags |= (1L<<10);
			if (flags & (1<<10))
				retain |= (1<<4);
		}
		else if (flags & (1<<3))
		{
			if (flags & (1<<10)) retain |= (1<<3);

			if (flags & (1<<0))
			{
				*proto->op++ = '#';
				proto->op = strcopy(proto->op, "pragma");
				*proto->op++ = ' ';
				proto->op = strcopy(proto->op, "prototyped");
				*proto->op++ = '\n';
			}
			else

			proto->flags |= (1L<<9);
		}

		if (!(flags & (1<<0)))
		{
			if (proto->flags & (1L<<29))
			{
				proto->op = strcopy(proto->op, "\n%{\n"+ !notice);
				proto->op = strcopy(proto->op, "/* : : generated by proto : : */\n");
				proto->op = strcopy(proto->op, "%}\n");
			}
			else
			{
				if (n || notice) *proto->op++ = '\n';
				proto->op = strcopy(proto->op, "/* : : generated by proto : : */\n");
				if (n) proto->op = linesync(proto, proto->op, proto->line);
				else if (proto->flags & ((1L<<9)|(1L<<10)))
					proto->op = init(proto->op, proto->flags);
			}
		}

	}


	proto->file = file;
	if (flags & (1<<0))
	{
		proto->flags |= (1L<<0);
		if (!(flags & (1<<3))) proto->flags |= (1L<<5);
	}

	return(iob);
}

 




int
pppread __PARAM__((char* iob), (iob)) __OTORP__(char* iob;){
	register struct proto*	proto = (struct proto*)(iob - sizeof(struct proto));
	register int		n;

	if (proto->flags & (1L<<17))
	{
		if (proto->iz)
		{
			n = proto->iz;
			proto->iz = 0;
		}
		else if (!(proto->flags & (1L<<15))) n = 0;
		else if ((n = read(proto->fd, proto->ob, proto->oz)) <= 0 || (proto->flags & (1L<<21)) && n < proto->oz)
		{
			proto->flags &= ~(1L<<15);
			close(proto->fd);
		}
	}
	else
	{
		if (proto->op == proto->ob)
		{
			if (proto->flags & (1L<<4)) return(-1);

			if (proto->flags & (1L<<29))
			{
				register char*	ip = proto->ip;
				register char*	op = proto->ob;
				register char*	ep = proto->ob + proto->oz - 2;

				if (!*ip)
				{
					ip = proto->ip = proto->ib;
					if (!(proto->flags & (1L<<15))) n = 0;
					else if ((n = read(proto->fd, ip, proto->iz)) <= 0 || (proto->flags & (1L<<21)) && n < proto->iz)
					{
						if (n < 0) n = 0;
						proto->flags &= ~(1L<<15);
						close(proto->fd);
					}
					ip[n] = 0;
				}
				if (proto->flags & (1L<<30))
				{
					proto->flags &= ~(1L<<30);
					if (*ip == '%')
					{
						*op++ = *ip++;
						if (proto->flags & (1L<<31)) proto->flags &= ~(1L<<29);
						else proto->flags |= (1L<<31);
					}
				}
				if (proto->flags & (1L<<29))
					while (op < ep && (n = *op++ = *ip))
					{
						ip++;
						if (n == '%')
						{
							if (*ip == '%' && (ip == proto->ip + 1 || *(ip - 2) == '\n'))
							{
								*op++ = *ip++;
								if (proto->flags & (1L<<31)) proto->flags &= ~(1L<<29);
								else proto->flags |= (1L<<31);
								break;
							}
							if (!*ip)
							{
								*op++ = '%';
								proto->flags |= (1L<<30);
								break;
							}
						}
						else if (n == '\n') proto->line++;
					}
				proto->op = memcopy(proto->ob, proto->ip, ip - proto->ip);
				proto->ip = ip;
			}
			else

			lex(proto, proto->flags);
			if ((proto->flags & ((1L<<4)|(1L<<15))) == (1L<<4))
				proto->op = strcopy(proto->op, "/* NOTE: some constructs may not have been converted */\n");
		}
		n = proto->op - proto->ob;
		proto->op = proto->ob;
	}
	return(n);
}























#line 69 "/home/gsf/src/cmd/proto/proto.c"




static int
proto __PARAM__((char* file, char* notice, int flags), (file, notice, flags)) __OTORP__(char* file; char* notice; int flags;){
	char*		b;
	char*		e;
	int		n;
	int		x;
	int		fd;

	if (file && access(file, 4)) proto_error(((char*)0), 2, file, "not found");
	else if (b = pppopen(file, 0, notice, flags))
	{
		if (file)
		{
			e = file + sstrlen( file) - 1;
			x = *e;
			*e = '_';
			if ((fd = (flags & ((1<<13)<<1)) ? creat(file, 0666) : 1) < 0)
			{
				proto_error(b, 2, "cannot create temporary file", ((char*)0));
				return(flags);
			}
			*e = x;
		}
		else fd = 1;
		while ((n = pppread(b)) > 0)
			if (write(fd, b, n) != n)
			{
				proto_error(b, 2, "write error", ((char*)0));
				flags |= ((1<<13)<<0);
				break;
			}
		if (file && (flags & ((1<<13)<<1)))
		{
			close(fd);
			*e = '_';
			strcpy(b, file);
			*e = x;
			if (replace(b, file, !(flags & (1<<0))))
				proto_error(b, 2, "cannot rename to", file);
		}
		pppclose(b);
	}
	return(flags);
}

int
main __PARAM__((int argc, char** argv), (argc, argv)) __OTORP__(int argc; char** argv;){
	char*		b;
	char*		file;
	int		fd;
	char*		list = 0;
	char*		notice = 0;
	int		flags = (1<<3);
	char		buf[1024];

	;
	while ((file = *++argv) && *file == '-' && *(file + 1))
	{
		for (;;)
		{
			switch (*++file)
			{
			case 0:
				break;
			case 'c':
				if (!*(notice = ++file) && !(notice = *++argv))
				{
					file = "??";
					continue;
				}
				break;
			case 'd':
				flags |= (1<<1);
				continue;
			case 'f':
				flags |= (1<<2);
				continue;
			case 'h':
				flags &= ~(1<<3);
				continue;
			case 'i':
				flags |= (1<<0);
				continue;
			case 'l':
				if (!*(list = ++file) && !(list = *++argv))
				{
					file = "??";
					continue;
				}
				break;
			case 'n':
				flags |= (1<<6);
				continue;
			case 'p':
				flags |= (1<<8);
				continue;
			case 'r':
				flags |= ((1<<13)<<1);
				continue;
			case 's':
				flags |= (1<<4);
				continue;
			case 't':
				flags |= (1<<11);
				continue;
			case 'z':
				flags |= (1<<1)|(1<<7);
				continue;
			case '+':
				flags |= (1<<9);
				continue;
			default:
				proto_error(((char*)0), 2, file, "unknown option");
 
			case '?':
				b = "Usage: proto [-dfhinprst+] [-c \"name='value' ...\"] [-l list] file ...\n";
				write(2, b, sstrlen( b));
				exit(2);
			}
			break;
		}
	}
	if (list)
	{
		if (*list == '-' && !*(list + 1)) fd = 0;
		else if ((fd = open(list, 0)) < 0) proto_error(((char*)0), 3, list, "not found");
		for (;;)
		{
			b = buf;
			while (read(0, b, 1) == 1 && *b != '\n' && b < &buf[sizeof(buf) - 1]) b++;
			if (b == buf) break;
			*b = 0;
			flags = proto(buf, notice, flags);
		}
	}
	if (file) do flags = proto(file, notice, flags); while (file = *++argv);
	else if (!list) flags = proto(file, notice, flags);
	exit(errors ? 1 : (flags & ((1<<13)<<0)) ? 2 : 0);
}
