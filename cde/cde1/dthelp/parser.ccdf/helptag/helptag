: Bourne shell
# helptag 
#
# Info for 'what' strings ...
#
# @(#)
# @(#)HP Help System - HelpTag Software  --  Version A.01.00
# @(#)
# @(#)Copyright (c) 1986 - 1993 Hewlett-Packard Company.
# @(#)               All rights reserved.
# @(#) User Interface Technology Division, Corvallis, OR
# @(#)
#########################################################

USESYSTEMUTILS=${USESYSTEMUTILS:-"YES"}
if [ $USESYSTEMUTILS = "YES" ]
then
   HELPTAGPARSER=${HELPTAGPARSER:-htag}
   VOLUMEGEN=${VOLUMEGEN:-volumegen}
   HELPCOMP=${HELPCOMP:-helpcomp}
else
   HELPTAGPARSER=${ALT_HELPTAGPARSER:-htag}
   VOLUMEGEN=${ALT_VOLUMEGEN:-volumegen}
   HELPCOMP=${ALT_HELPCOMP:-helpcomp}
fi


RM="/bin/rm -f "

directory=`/bin/pwd`
listfiles="no"
optlist=""
charset="default"

export optlist tagname extension
export directory statfile 

# clean up if the user interrupts this script
bailout(){
  # Remove the stat file ...
  rm $statfile 2> /dev/null
  exit 2
  }
trap bailout 1 2 3 4 5 6 7 8 10 12 13 14 15 16 17

if [ -z "$1" ]
then
  echo "Usage:  helptag [options] <filename>"
  echo "        (For more information:  helptag -help)"
  exit 2
fi

# determine what behavior we have from basename(1).  On some systems,
# the second parameter to basename(1) is a simple string; on others,
# it's a regular expression.  Since we want to find out if our input
# file name ends in ".", we need to use either "\." or "." depending
# on whether the "." is taken as an RE or a string.
string=`basename string .`
if [ $string = string ]
then
  dotsuffix=.
else
  dotsuffix=\\.
fi

# function to return extension, if any of a file name.
# when called, the file name should already have been broken into parts
# at any periods.
split_name()
{
if [ $# -eq 0 ]
then
  extension=""
elif [ $# -eq 1 ]
then
  extension=""
else
  shift `expr $# - 1`
  extension=".$1"
fi
}


# function used to simply return the positional parameters to their
# original state, i.e., what they were before calling "split_name".
reset()
{
true
}


# function to parse a file name.
parse_name()
{
# don't try to get extension if file ends in period
remdot=`basename "$1" $dotsuffix`
predot=`basename "$1"`
if [ "$remdot" = "$predot" ]
then
  # save original parameters and field separators
  saveParm="$*"
  saveIFS="$IFS"

  # cause file name to be split at periods
  IFS=.
  q=$1

  # get the extension, if any
  split_name $q

  # restore original field separators and file name
  IFS="$saveIFS"
  reset "$saveParm"
else
  extension="."
  tagname="$remdot"
fi

# get the directory, will be "." if none
directory=`dirname $1`

# get the file base name and remove trailing period, if any and no extension
tagname=`basename $1 $extension`
if [ "$extension" = "" ]
then
  tagname=`basename $tagname $dotsuffix`
fi
}


# Check command line for options:
gotfile=no
while [ $1 ]
do
  case $1 in
    -charset) shift
      if [ -z "$2" ]
      then
        echo ""
        echo "Sorry! \007Missing either a character set name or filename."
        echo ""
        echo "       Usage:  helptag -charset <charset> <filename>."
        echo ""
        exit 1
      fi
      charset=$1
      ;;
    -clean) shift
      if [ -z "$1" ]
      then
        echo "Delete all files generated by HelpTag"
        echo "Sorry, \007Please specify a file name (with no extension)"
        echo "For example:  $0 tagfilename"
        exit 1
      fi
      for commandline
      do 
        echo "Deleting HelpTag-generated files for $commandline"
        # check for .htg or .ttg extension
	saveCommandLine="$*"
	parse_name $commandline
	reset $saveCommandLine
	if [ \( "$extension" != ".htg" \) -a \( "$extension" != ".ttg" \) ]
	then
	  tagname=$tagname$extension
	fi
	if [ "$shortnames" = "yes" ]
	then
	  workfile=`echo $tagname | cut -c1-6`
	else
	  workfile=$tagname
	fi
	workfile=$directory/$workfile
        $RM $workfile.err
        $RM $workfile.hv
        $RM $workfile.hvk
        $RM $workfile.hmi
        $RM $workfile*.ht
        $RM $workfile.idt
        $RM $workfile.tpc
        $RM $workfile.xrh
        $RM $workfile.idx
        $RM $directory/.$tagname.st
	$RM $workfile.'xrh'
	$RM $workfile.'dr'
      done
      exit 0
     ;;  
    -debug)
     save=yes
     optlist="$optlist onerror=go"
     ;;
    -files)
     listfiles="yes"
     ;;
    -help)
     echo "______________________________"
     echo "To create run-time help files:"
     echo ""
     echo "                helptag [options] <filename>"
     echo ""
     echo "... where the options are:" 
     echo ""
     echo "   -memo               Includes writer's memos entered with <memo>."
     echo "   -verbose            Displays parser activity."
     echo "   -shortnames         Truncates all generated filenames for portability."
     echo "   -debug              Intermediate files (normally deleted) are saved."
     echo "                       Also, help topic (.ht) files are not compressed."
     echo "   -charset <charset>  Sets the default characterset to <charset>."
     echo ""
     echo "_________________________________________"
     echo "To remove all files generated by HelpTag:"
     echo ""
     echo "                helptag -clean  <filename>"
     echo ""
     echo "_________________________________"
     echo "To list all of the file entities:"
     echo ""
     echo "                helptag -files  <filename>"
     echo ""
     exit 2
     ;;
    -memo)
     memo=yes
     ;;
    -nomemo)
     memo=no
     ;;
    -shortnames)
     shortnames=yes
     ;;
    -verbose) 
     background=no
     ;;
    @*) optlist="$optlist $1"
     ;;
    *) if [ "$gotfile" = no ]
        then
          tagname=$1
          gotfile=yes
        else
          optlist="$optlist $1"
        fi
     ;;
    esac
  shift
done


echo "Running HelpTag   Version A.01.00 ..."

if [ "$gotfile" = no ]
then
  echo You must specify an input filename.
  echo "A \".htg\" extension is assumed if you don't provide one."
  exit 2
fi

# Analyze file name:
#   if no extension -> append .htg
#   if extension -> use as is
#   if trailing . -> use without extension
parse_name $tagname
if [ "$extension" = "" ]
then
  extension=".htg"
fi

# see if tag file exists
if [ ! -r $directory/$tagname$extension ]
then
  echo File $directory/$tagname$extension not found or not readable.
  exit 2
fi


# Remove old status file, if any.
statfile="$directory/.$tagname.st"
$RM $statfile


# Do we want a list of the files declared through entities?
if [ "$listfiles" = yes ]
then
  echo ""
  echo "Preparing to list files entered as entity declartions ..."
  echo ""
  $HELPTAGPARSER $directory/$tagname$extension f $optlist
  exit 2
fi


# Check write access to current directory
(echo "testing" > $statfile)
if [ $? -gt 0 ]
then
  echo Job not accepted.
  echo You may lack write permission in the current directory.
  exit 2
fi


# Should the parser ignore writer memos?
if [ "$memo" = yes ]
then
  optlist="$optlist memo"
elif [ "$memo" = no ]
then
  optlist="$optlist nomemo"
fi


# Does the user wish to truncate file names for portability?
if [ "$shortnames" = "yes" ]
then
  optlist="$optlist short"
  workfile=`echo $tagname | cut -c1-6`
else
  workfile=$tagname
fi
workfile=$directory/$workfile

if [ "$background" = "no" ]
then
    moreinfo=""
else
    moreinfo="  See file ${workfile}.err for more information."
fi

# Write the header (time stamp, etc.) to the status file.
echo "HelpTag Version A.01.00"  > $statfile
echo `date` >> $statfile

# Call the parser with the appropriate options.  
echo Starting HelpTag parser. >> $statfile
if [ "$background" = no ]
then
  echo Verbose mode started.
  $HELPTAGPARSER $directory/$tagname$extension - $optlist
  trouble=$?
  if [ \( $trouble -eq 77 \) -o \( $trouble -eq 66 \) ]
  then
    echo "Re-running parser to resolve xrefs" >> $statfile
    echo "Re-running parser to resolve xrefs"
    $HELPTAGPARSER $directory/$tagname$extension - $optlist
    trouble=$?
  fi
  if [ \( "$save" != "yes" \) -a \
       \( $trouble -ne 0 \) -a \( $trouble -ne 2 \) -a \( $trouble -ne 66 \) ]
  then
    echo "Error(s) in run of $HELPTAGPARSER -- exiting helptag."
    if [ "$save" != "yes" ]
    then
      $RM $workfile.'idt'
      $RM $workfile.'tpc'
      $RM $workfile.'xrh'
      $RM $workfile.'dr'
      $RM $workfile.'hmi'
      $RM $workfile.'idx'
    fi
    # Remove the stat file ...
    rm $statfile 2> /dev/null
    exit 1
  fi
else
  $HELPTAGPARSER $directory/$tagname$extension - $optlist 1>/dev/null 2>&1
  trouble=$?
  if [ \( $trouble -eq 77 \) -o \( $trouble -eq 66 \) ]
  then
    echo "Re-running parser to resolve xrefs" >> $statfile
    $HELPTAGPARSER $directory/$tagname$extension - $optlist 1>/dev/null 2>&1
    trouble=$?
  fi
  if [ \( "$save" != "yes" \) -a \
       \( $trouble -ne 0 \) -a \( $trouble -ne 2 \) -a \( $trouble -ne 66 \) ]
  then
    echo "Parser errors occurred!$moreinfo"
    if [ "$save" != yes ]
    then
      $RM $workfile.'idt'
      $RM $workfile.'tpc'
      $RM $workfile.'xrh'
      $RM $workfile.'dr'
      $RM $workfile.'hmi'
      $RM $workfile.'idx'
    fi
    # Remove the stat file ...
    rm $statfile 2> /dev/null
    exit 1
  fi
fi

# If there were parser errors, report them to the status file, and stdout.
echo "Parser done. \c" >> $statfile
if [ $trouble -gt 0 ]
then
  echo "Parser errors occurred!$moreinfo"  >> $statfile
  if [ "$save" = yes ]
  then
    echo "Continuing due to a -debug option" >> $statfile
  else
    echo "Continuing due to an onerror=go option" >> $statfile
  fi
  echo "Parser errors occurred!$moreinfo"
  if [ "$save" = yes ]
  then
    echo "Continuing due to a -debug option"
  else
    echo "Continuing due to an onerror=go option"
  fi
else
  echo No parser errors. >> $statfile
fi

# Assemble the intermediate files into the run-time files ...

# Save the charset (if specified) ...
if [ "$charset" != "default" ]
then
  echo NOTE:  Add this to the help volume file:  \"*.characterSet: $charset\"
fi


# Sort the <class>.idx file prior to running volumegen 
echo "Sorting the keyword index file." >> $statfile
if [ "$background" = "no" ]
then
  echo "Sorting the keyword index file."
fi

tr "\0" "\1" < $workfile.idx > $workfile.tmp
sort -f $workfile.tmp > $workfile.idx
tr "\1" "\0" < $workfile.idx > $workfile.tmp
mv $workfile.tmp $workfile.idx

echo "sort complete." >> $statfile
if [ "$background" = "no" ]
then
  echo "sorting complete."
fi


# Run the volumegen utility to create the Help Volume File ...
echo "Running $VOLUMEGEN to create the Help Volume File." >> $statfile
if [ "$background" = "no" ]
then
  echo "Running $VOLUMEGEN to create the Help Volume File."
fi

$VOLUMEGEN $workfile
if [ $? -ne 0 ]
then
  echo "Error in run of $VOLUMEGEN." >> $statfile
  echo "Error in run of $VOLUMEGEN -- exiting helptag."
  if [ "$save" != yes ]
  then
    $RM $workfile.'idt'
    $RM $workfile.'tpc'
    $RM $workfile.'xrh'
    $RM $workfile.'dr'
    $RM $workfile.'hmi'
    $RM $workfile.'idx'
  fi
  # Remove the stat file ...
  rm $statfile 2> /dev/null
  exit 1
fi

echo "$VOLUMEGEN complete." >> $statfile
if [ "$background" = "no" ]
then
  echo "$VOLUMEGEN complete."
fi


# Run the helpcomp utility to compress the Help Topic Files ...
echo "Running $HELPCOMP to compress the Help Topic Files." >> $statfile
if [ "$background" = "no" ]
then
  echo "Running $HELPCOMP to compress the Help Topic Files."
fi

if [ "$save" != yes ]
then
  $HELPCOMP $workfile
fi
if [ $? -ne 0 ]
then
  echo "Error in run of $HELPCOMP." >> $statfile
  echo "Error in run of $HELPCOMP -- exiting helptag."
  if [ "$save" != yes ]
  then
    $RM $workfile.'idt'
    $RM $workfile.'tpc'
    $RM $workfile.'xrh'
    $RM $workfile.'dr'
    $RM $workfile.'hmi'
    $RM $workfile.'idx'
  fi
  # Remove the stat file ...
  rm $statfile 2> /dev/null
  exit 1
fi

echo "$HELPCOMP complete." >> $statfile
if [ "$background" = "no" ]
then
  echo "$HELPCOMP complete."
fi


# Remove the intermediate files ...
# Note: currently the save option is set to save no intermediate files ...
if [ "$background" = "no" ]
then
  echo "Removing intermediate files."
fi

if [ "$save" != yes ]
then
  $RM $workfile.'idt'
  $RM $workfile.'tpc'
  $RM $workfile.'dr'
  $RM $workfile.'hmi'
  $RM $workfile.'idx'
fi


# All done ...
echo DONE >> $statfile
echo "Done."
