/* 
 * Copyright (c) 1996 Sun Microsystems, Inc. 
 */

#pragma ident "@(#)engine.c	1.16 97/05/12 SMI"

/*----------------------------- Include files --------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <fcntl.h>
#include <nl_types.h>
#include <errno.h>
#include <dlfcn.h>

#include "globals.h"
#include "spelltypes.h"
#include "engine.h"

/*------------------------------ Definitions  --------------------------------*/

/* Default location of the dictionaries. */
#define SUNSPELL_DICTS_DEF	"/usr/dt/config/sdtdict/"


/* Dictionary names. */
#define	DAT_CA			"ca.dat"		/* Catalan */
#define DAT_DE			"de.dat"		/* German */
#define DAT_DE_CH		"de_CH.dat"
#define DAT_EN_AU		"en_AU.dat"		/* English */
#define DAT_EN_UK		"en_UK.dat"
#define	DAT_EN_US		"en_US.dat"
#define DAT_ES			"es.dat"		/* Spanish */
#define DAT_FR			"fr.dat"		/* French */
#define DAT_FR_BE		"fr_BE.dat"
#define DAT_FR_CA		"fr_CA.dat"
#define DAT_FR_CH		"fr_CH.dat"
#define DAT_IT			"it.dat"		/* Italian */
#define DAT_SV			"sv.dat"		/* Swedish */


/* Default temporary directory, for temporary files. */
#define	TMP_DIR		"/tmp/"


/* Personal dictionary size increments, in kilobytes. */
#define PERSONAL_DICT_SIZE	5


/* Determine whether ICspl() or ICpd() was called. */
#define OP_ICSPL	0
#define OP_ICPD		1


/* Retrieved number of personal dictionary contents used when
 | locking the database.
 */
#define	RETRIEVE_NUM	5


/* Library name of the spell engine, required by the GUI. */
#define	SPELL_LIB_NAME	"libSDtSpellE.so"

#define DIR_MODE	0755

/*---------------------------- Global variables ------------------------------*/

/* Buffer to hold error messages generated by failed spell engine calls. */
#define	MAX_MSG_SIZE	256
char _sdtSpellCheckMsg[MAX_MSG_SIZE];


/* Handle to the Inso spell engine library. */
void *_spellEngLib = (void *) NULL;


/* Handles to the ICspl(), ICpd() and SLchncnv() functions in the
 | Inso spell engine library.
 */
RETCODE (*FP_icspl) (PFUCHAR, PFICBUFF);
RETCODE (*FP_icpd) (PFICBUFF, PFPD_IC_IO);
RETCODE (*FP_slchcnv) (PUCHAR, INT2B, PUCHAR, SWORD, UCHAR);


/*------------------------------- Functions ----------------------------------*/



/* Function	: _customDictExists()
 |
 | Objective    : This function checks to see if the user already has a
 |                custom dictionary present in their home dictory.
 |
 | Arguments    : char *        directory       - location of custom
 |						  dictionary
 |                char *        filename        - name of dictionary
 |						  file
 |                int  *        size            - determine the size of
 |                                                the personal
 |                                                dictionary that will
 |						  be used.
 |
 | Return Value	: Boolean True if the file exists, false otherwise.
 |
 | Side Effects : The size variable will be initialized to an
 |		  appropriate size for the dictionary.
 |
 */

Boolean 
_customDictExists(char *pd_path, char *pd_file, int *size)
{
	char            dictionary[MAXPATHLEN];
	struct stat     buffer;


	/* Build the complete dictionary file path and name, and check its
	 | status via the stat() call.  If file exists, return true,
	 | otherwise, return false.
	 */
	sprintf(dictionary, "%s%s", pd_path, pd_file);
	if (stat(dictionary, &buffer) == 0) {

		/* Assign a size equal to the current dictionary size, plus
		 | an extra 5k for words that the user might add.
		 */
		*size = (int) ((buffer.st_size + (PERSONAL_DICT_SIZE * 1024)) 
				/ 1024);
		return (True);

	} else {

		/* Assign the default initial size of 5K */
		*size = PERSONAL_DICT_SIZE;


		/* If the personal dictionary path doesn't exist, 
		 | then create it.
		 */
		if ((stat(pd_path, &buffer) != 0) && (errno == ENOENT))
			mkdir(pd_path, DIR_MODE);
		return (False);

	}
}


/* Function	: errnum2errstr()
 |
 | Arguments	: int		operation	- flag indicating whether
 |						  ICspl() or ICpd() function
 |						  was called.
 |		  int		errflag		- error flag of the function
 |
 | Return Value	: A string that maps the error number to a human readable
 |		  form.
 |
 | Side Effects : None.
 |
 | Objective	: This function returns a string that can be read by the user,
 |		  so that error numbers are not cryptic.
 |
 */

char
*errnum2errstr(int operation, int errflag)
{
	/* For unknown error codes. */
	char            unknown[256];


	if (operation == OP_ICSPL) {

		/* Return ICspl() error messages. */
		if (errflag & ICALLOCERR)
			return (catgets(_spellCat, 5, 1, 
				"memory allocation error"));
		else if (errflag & ICHEADERR)
			return (catgets(_spellCat, 5, 2, 
				"main dictionary database header error"));
		else if (errflag & ICOPENERR)
			return (catgets(_spellCat, 5, 4, 
				"could not open database"));
		else if (errflag & ICREADERR)
			return (catgets(_spellCat, 5, 5, 
				"disk read error"));
		else if (errflag & ICSEEKERR)
			return (catgets(_spellCat, 5, 6, 
				"disk seek error"));
		else {
			sprintf(unknown, "%s: %d",
				catgets(_spellCat, 5, 8, 
				"unknown ICspl() error flag returned"), 
				errflag);
			return (unknown);
		}

	} else {

		/* Return ICpd() error messages. */
		switch (errflag) {
		case SLREAD_ERR:
			return (catgets(_spellCat, 5, 5, 
				"disk read error"));

		case SLWRITE_ERR:
			return (catgets(_spellCat, 5, 7, 
				"disk write error"));

		case SLOPEN_ERR:
			return (catgets(_spellCat, 5, 10, 
				"error opening file"));

		case SLCLOSE_ERR:
			return (catgets(_spellCat, 5, 11, 
				"error closing file"));

		case SLALLOC_ERR:
			return (catgets(_spellCat, 5, 1, 
				"memory allocation error"));

		case SLTMPFNAME_ERR:
			return (catgets(_spellCat, 5, 12, 
				"error creating temporary file"));

		case PD_HEAD_ERR:
			return (catgets(_spellCat, 5, 3, 
				"personal dictionary database header error"));

		case PD_DATA_ERR:
			return (catgets(_spellCat, 5, 13, 
				"error accessing RAM database"));

		case PD_RANGE_ERR:
			return (catgets(_spellCat, 5, 14, 
				"illegal word was entered into personal database"));

		case PD_PID_ERR:
			return (catgets(_spellCat, 5, 16, 
				"invalid application identification number"));

		case PD_DID_ERR:
			return (catgets(_spellCat, 5, 17, 
				"invalid database identification number"));

		case PD_DB_BUSY:
			return (catgets(_spellCat, 5, 15, 
				"access denied since personal dictionary is in use by another operation"));

		case PD_FULL_ERR:
			return (catgets(_spellCat, 5, 18, 
				"memory limit of personal dictionary reached"));

		case PD_NOTFND_ERR:
			return (catgets(_spellCat, 5, 33, 
				"word not found in personal dictionary"));

		case PD_LOCK_ERR:
			return (catgets(_spellCat, 5, 34, 
				"personal dictionary locked"));

		case PD_SDINIT_ERR:
			return (catgets(_spellCat, 5, 28, 
				"failed to initialize personal dictionary"));

		case PD_MAXDID_ERR:
			return (catgets(_spellCat, 5, 37, 
				"personal dictionary maximum reached"));

		default:
			sprintf(unknown, "%s: %d",
				catgets(_spellCat, 5, 9, 
				"unknown ICpd() error flag returned"), errflag);
			return (unknown);
		}
	}
}


/* Function	:	_getLanguage()
 |
 | Objective	:	Get the language the spell checker will use based
 | 			on language string passed.
 |
 | Argument	:	char *locale		- language string (typically,
 |						  in form similar to that
 |						  of $LANG)
 |
 | Return value	:	SPL_LANGUAGE
 |
 | Side effects :	None.
 */

SPL_LANGUAGE
_getLanguage(char *locale)
{

	/* Return the language that the dictionary will use. */
	if (strcmp(locale, LOCALE_EN_AU) == 0)
		/* Australian English. */
		return(EN_AU);
	else if (strcmp(locale, LOCALE_EN_UK) == 0)
		/* British/UK English. */
		return(EN_UK);
	else if ((strcmp(locale, LOCALE_C) == 0) || 
		 (strcmp(locale, LOCALE_EN_US) == 0))
		/* US English - C locale defaults to US English */
		return(EN_US);
/*
 | CATALAN TURNED OFF, PER JEAN CUNNINGTON
 |
	else if (strcmp(locale, LOCALE_CA) == 0)
		Catalan.
		return(CA);
 */

	else if (strcmp(locale, LOCALE_DE_CH) == 0)
		/* German/Swiss. */
		return(DE_CH);
	else if ((strcmp(locale, LOCALE_DE) == 0) || strstr(locale, "de_"))
		/* Any partial German locale should refer to German/Austrian. */
		return(DE);
	else if ((strcmp(locale, LOCALE_ES) == 0) || strstr(locale, "es_"))
		/* Any Spanish partial locale should refer to just Spanish. */
		return(ES);
	else if ((strcmp(locale, LOCALE_FR) == 0) || strstr(locale, "fr_"))
		/* Any French partial locale should refer to just French. */
		return(FR);
	else if (strcmp(locale, LOCALE_IT) == 0)
		/* Italian */
		return(IT);
	else if (strcmp(locale, LOCALE_SV) == 0)
		/* Swedish */
		return(SV);
	else
		return(UNSUPPORTED);
}


/* Function	:	_setDictLanguage()
 |
 | Objective	:	Determine what language and dialect to use when
 |			correcting documents.  The language and dialect
 |			to use are determined by:
 |				1) Value of resource in the .desksetdefaults
 |				   file.
 |				2) If .desksetdefaults file is not present,
 |				   the the value is determined by the LANG
 |				   environment variable.
 |				3) If the LANG environment variable does
 |				   not map out to a supported locale, or
 |				   if the dictionary for the locale has
 |				   not been installed, then default to
 |				   US English.
 |
 | Arguments	:	ICBUFF	*icbuff		- the buffer that is used
 |						  to interface with the
 |						  spelling engine.
 |			char    *lang		- language string to determine
 |						  to determine what dictionary
 |						  to use.
 |
 | Return Value :	None.
 |
 | Side effects	:	The icbuff structure will be updated with the proper
 |			language dictionary and dialect ot use.
 */

void
_setDictLanguage(ICBUFF * icbuff, char **lang)
{
	/* Unless otherwise stated, the default dialect and mode is always
	 | SLDEFAULT.  See individual case statements if a specific dialect
	 | and mode are required.
	 */
	icbuff->lang_dialect = SLDEFAULT;
	icbuff->lang_mode = SLDEFAULT;


	/* Determine language, dialect, and mode. */
	switch (_getLanguage(*lang)) {

/* 
 | CATALAN TURNED OFF, PER JEAN CUNNINGTON
 |
	case CA:
		Catalan Spelling
		icbuff->lang = SLCATALAN;
		icbuff->lang_mode = SLPUNTVOLAT;
		strcpy(icbuff->mstr_fn, DAT_CA);
		return;
 */



	case EN_AU:
		/* Australian Spelling */
		icbuff->lang = SLAUSTRALIAN;
		icbuff->lang_dialect = SLAUSTRLN;
		strcpy(icbuff->mstr_fn, DAT_EN_US);
		return;


	case EN_UK:
		/* British Spelling, -ise version */
		icbuff->lang = SLENGLISH;
		icbuff->lang_dialect = SLISE_UK_ENGLISH;
		strcpy(icbuff->mstr_fn, DAT_EN_UK);
		return;


	case DE:
		icbuff->lang = SLGERMAN;
		icbuff->lang_dialect = SLSCHARFES;
		strcpy(icbuff->mstr_fn, DAT_DE);
		return;


	case DE_CH:
		icbuff->lang = SLGERMAN;
		icbuff->lang_dialect = SLDOPPEL;
		strcpy(icbuff->mstr_fn, DAT_DE_CH);
		return;


	case ES:
		icbuff->lang = SLSPANISH;
		icbuff->lang_mode = SLUNACCENT;
		strcpy(icbuff->mstr_fn, DAT_FR);
		strcpy(icbuff->mstr_fn, DAT_ES);
		return;


	case FR:
		icbuff->lang = SLFRENCH;
		icbuff->lang_mode = SLUNACCENT | SLOPENLIG;
		strcpy(icbuff->mstr_fn, DAT_FR);
		return;


	case IT:
		icbuff->lang = SLITALIAN;
		strcpy(icbuff->mstr_fn, DAT_IT);
		return;


	case SV:
		icbuff->lang = SLSWEDISH;
		strcpy(icbuff->mstr_fn, DAT_SV);
		return;


	case UNSUPPORTED:
		/* Re-do the lang variable, so that is valid now. 
		 | If unsupported, default to the US English language.
		 */
		free(*lang);
		*lang = (char *) calloc(strlen(LOCALE_EN_US) + 5, sizeof(char));
		strcpy(*lang, LOCALE_EN_US);

	case EN_US:
	default:
		/* American Spelling.  C and UNSUPPORTED locales default to
		 | this dictionary.
		 */
		icbuff->lang = SLENGLISH;
		icbuff->lang_dialect = SLAMERICAN;
		strcpy(icbuff->mstr_fn, DAT_EN_US);
		return;

	}
}


/* Function	: _initEngineFuncs()
 |
 | Objective	: Open up the library that contains the spell engine
 |		  functions, and assign function pointers to ICspl(),
 |		  ICpd() and SLchcnv() so that we can access these
 |		  functions.
 | 
 | Arguments	: None.
 |
 | Return Value	: Boolean true if the library was successfully found
 |		  and opened, false otherwise.
 |
 | Side effects	: The library and function pointers are initialized by
 |		  calls to dlopen and dlsym.
 |
 */

Boolean
_initEngineFuncs(void)
{
	/* See if we can access the spell engine software. */
	_spellEngLib = dlopen(SPELL_LIB_NAME, RTLD_LAZY);


	if (_spellEngLib != (void *) NULL) {

		/* We have access to the Inso spell engine library. Get the
		 | handle to the ICspl(), ICpd, and SLchcnv | functions.
		 */
		FP_icspl = (RETCODE(*) (PFUCHAR, PFICBUFF))
			dlsym(_spellEngLib, "ICspl");
		FP_icpd = (RETCODE(*) (PFICBUFF, PFPD_IC_IO))
			dlsym(_spellEngLib, "ICpd");
		FP_slchcnv = (RETCODE(*) (PUCHAR, INT2B, PUCHAR, SWORD, UCHAR))
			dlsym(_spellEngLib, "SLchcnv");


		/* Make sure the we got function pointers back! */
		if ((FP_icspl != NULL) && (FP_icpd != NULL) &&
		    (FP_slchcnv != NULL))
			return (True);
	}


	/* The initialization of the library function pointers failed.  */
	return (False);
}


/* Function	: _initMainDict()
 |
 | Arguments	: char *lang	- language string to determine what language
 |				  dictionary to use.
 |
 | Return Value	: A pointer to an ICBUFF structure that will be used to
 |		  perform the spell engine functions.
 |
 | Side Effects : None.
 |
 | Objective	: This function initializes the CDE spell checking engine,
 |		  and allocates and returns an ICBUFF buffer that can be
 |		  used to check and verify the validity of words by using
 |		  the main dictionary.
 |
 | Extra Notes	: This function does not initialize personal dictionaries;
 |		  See the _initPersonalDict() function.
 |
 */

ICBUFF
* _initMainDict(char **lang)
{
	/* Allocate an icbuff structure that will be used in checking words
	 | against the main dictionary.  If the allocation is successfull,
	 | and the engine was correctly initialized, then return this
	 | allocated icbuff structure to the user.
	 */
	ICBUFF         *icbuff = (ICBUFF *) NULL;


	/* Allocate memory for the icbuff structure. */
	icbuff = (ICBUFF *) calloc(1, sizeof(ICBUFF));
	if (icbuff == (ICBUFF *) NULL) {
		sprintf(_sdtSpellCheckMsg, "libSDtSpell: %s: %s\n", 
			catgets(_spellCat, 5, 30, "main dictionary"), 
			catgets(_spellCat, 5, 21, "failed to allocate buffer"));
		return ((ICBUFF *) NULL);
	}


	/* Initialize the ICBUFF structure with parameters that are
	 | required for initializing the main dictionary.
	 */
	icbuff->task = ICINITIALIZE;


	/* Get the location of the directories.  By default, assume it is
	 | in the directory defined by SUNSPELL_DICTS_DEF.  However, allow
	 | the user the flexibility to define its location (it could be on
	 | a server, for example), so check the environment variable
	 | SUNSPELL_DICTS for its location.  The directory must have a
	 | trailing slash at the end, for the initialization to work.  Need
	 | to check the environment variable doesn't have a trailing "/",
	 | then append one.  NOTE: CHECK FOR ARRAY BOUNDS!
	 */
	if (getenv("SUNSPELL_DICTS") == (char *) NULL)
		strcpy((char *) icbuff->mstr_path.path, SUNSPELL_DICTS_DEF);
	else {
		strncpy((char *) icbuff->mstr_path.path,
		       getenv("SUNSPELL_DICTS"), SLPATHMAX);
		if (icbuff->mstr_path.path[strlen((char *) icbuff->mstr_path.path)] != '/')
			strcat((char *) icbuff->mstr_path.path, "/\0");
	}


	/* Get the default language and dialect that the spell checker will
	 | use when correcting documents.
	 */
	_setDictLanguage(icbuff, lang);


	/* Hyphenation is turned off. */
	icbuff->hyp_flag = False;


	/* Not using the Finnish morphological database, so set this to
	 | NULL.
	 */
	icbuff->iclngbuf = (PFICLNGBUF) NULL;


	/* Use the internal parser provided by CorrectSpell.  The parser
	 strips of punctuation, numbers and other non-essential characters
	 | prior to checking the word.
	 */
	icbuff->parse_flag = True;


	/* Cache size for optimal operation.  This should be configurable
	 | using some logic.  Best values are 4096, 8192 and 16384.  Higher
	 | values are possible, but according to the documentation, won't
	 | give much performance gain.
	 */
	icbuff->cache_siz = 16384;


	/* Now, call ICspl() to initialize the spell engine. */
	(*FP_icspl) ((unsigned char *) NULLSTR, icbuff);
	if (icbuff->retcode != OKRET) {

		/* Print out the nature of the ICspl() error. */
		sprintf(_sdtSpellCheckMsg, "libSDtSpell: %s\n%s", errnum2errstr(OP_ICSPL, icbuff->init_flags), catgets(_spellCat, 5, 22, "failed to initialize main dictionary"));


		/* Free up the memory used by icbuff, display an error
		 | message from the _initMainDict() call, and return a NULL
		 | pointer back to the user.
		 */
		free(icbuff);
		return ((ICBUFF *) NULL);

	}


	/* Initialization successful.  Return ICBUFF structure. */
	return (icbuff);
}


/* Function	: _initPersonalDict()
 |
 | Arguments	: ICBUFF    **icbuff	- the icbuff structure that
 |					  the personal dictionary will
 |					  associated with
 |		  char       *pd_path   - location (directory path) where
 |					  personal dictionary can be found
 |		  char       *pd_file	- filename of personal dictionary
 |
 | Return Value	: PD_IC_IO	*pdbuff		- pointer to the personal
 |						  dictionary structure, which
 |						  be used in checking 
 |						  operations
 |
 | Side Effects : None.
 |
 | Objective	: This function returns a pointer to a personal dictionary
 |		  structure.  The structure will be used when checking the
 | 		  spelling of documents.
 |
 */

PD_IC_IO
*_initPersonalDict(ICBUFF **icbuff, char *pd_path, char *pd_file)
{
	PD_IC_IO	*pdbuff;	/* Personal dictionary to use. */
	int		dict_size;	/* It's initial size. */
	int		i, j;		/* General counters. */


	/* Allocate memory for the PD_IC_IO structure. */
	pdbuff = (PD_IC_IO *) calloc(1, sizeof(PD_IC_IO));
	if (pdbuff == (PD_IC_IO *) NULL)
	{
		sprintf(_sdtSpellCheckMsg, 
			"libSDtSpell: _initPersonalDict(): %s\n\n%s\n",
			catgets(_spellCat, 5, 28, "failed to initialize personal dictionary"),
			catgets(_spellCat, 5, 19, "Only main dictionary will be used."));
		return((PD_IC_IO *) NULL);
	}


	/* Need to allocate memory for the pReturns array of the 
	 | PD_IC_IO structure we just allocated.  Documentation
	 | says to give the array a size of ICMAXALT.
	 */
	if ((pdbuff -> pReturns = calloc(ICMAXALT, sizeof(PFUCHAR))) == NULL)
	{
		free(pdbuff);
		sprintf(_sdtSpellCheckMsg, 
			"libSDtSpell: _initPersonalDict(): %s\n\n%s\n", 
			catgets(_spellCat, 5, 28, "failed to initialize personal dictionary"),
			catgets(_spellCat, 5, 19, "Only main dictionary will be used."));
		return((PD_IC_IO *) NULL);
	}


	/* Need to allocate memory for each of the pReturn array
	 | elements.
	 */
	for (i = 0; i < ICMAXALT; i++)
	{
		pdbuff -> pReturns[i] = (PFICPD_RET)calloc(1, sizeof(ICPD_RET));
		if (pdbuff -> pReturns[i] == (PFICPD_RET) NULL)
		{
			/* Free previously allocated elements, the
			 | pReturns member, then the pdbuff structure.
			 */
			for (j = 0; j < i; j++)
				free(pdbuff -> pReturns[j]);
 			free(pdbuff -> pReturns);
			free(pdbuff);
			sprintf(_sdtSpellCheckMsg,
				"libSDtSpell: _initPersonalDict(): %s\n\n%s\n", 
				catgets(_spellCat, 5, 28, "failed to initialize personal dictionary"),
				catgets(_spellCat, 5, 19, "Only main dictionary will be used."));
			return((PD_IC_IO *) NULL);
		}
	}


	/* Initialize the PD_IC_IO structure. */
	pdbuff -> task = PDIC_INIT_PD;
	if ((*FP_icpd)((ICBUFF *) NULL, pdbuff) != OKRET)
	{
		/* Determine what kind of error occured. */
		sprintf(_sdtSpellCheckMsg,
			"libSDtSpell: _initPersonalDict(): %s\n\n%s\n", 
			errnum2errstr(OP_ICPD, pdbuff -> xStatus.wError), 
			catgets(_spellCat, 5, 19, "Only main dictionary will be used."));


		/* Free the buffer before returning. */
		for (j = 0; j < ICMAXALT; j++)
			free(pdbuff -> pReturns[j]);
 		free(pdbuff -> pReturns);
		free(pdbuff);
		return((PD_IC_IO *) NULL);
	}


	/* Now start up the personal dictionary; fill in the
	 | necessary values, before calling ICpd().
	 */
	pdbuff -> task = PDIC_START_DICT;
	sprintf((char *) pdbuff -> szOpenFilename, "%s", pd_file);
	sprintf((char *) pdbuff -> OpenPath.path, "%s", pd_path);


	/* Use the user's custom dictionary, if it exists.  Otherwise,
	 | create a new one.
	 */
	if (_customDictExists((char *) pdbuff -> OpenPath.path,
			     (char *) pdbuff -> szOpenFilename, &dict_size))
		/* Only support ASCII list type of custom dictionary. */
		pdbuff -> byOtype = PD_RAW_FILE;
	else
		pdbuff -> byOtype = PD_NEW_FILE;
	sprintf((char *) pdbuff -> tmpPath.path, "%s", TMP_DIR);
	pdbuff -> wDictSize = dict_size;

	/* NEED TO MAKE THIS LOCALIZED. */
	pdbuff -> byDictlang = SLENGLISH;
	if ((*FP_icpd)(*icbuff, pdbuff) != OKRET)
	{
		/* Determine what kind of error occured. */
		sprintf(_sdtSpellCheckMsg,
			"libSDtSpell: _initPersonalDict(): %s\n\n%s\n", 
			errnum2errstr(OP_ICPD, pdbuff -> xStatus.wError),
			catgets(_spellCat, 5, 19, "Only main dictionary will be used."));


		/* Free the buffer before returning. */
		for (j = 0; j < ICMAXALT; j++)
			free(pdbuff -> pReturns[j]);
 		free(pdbuff -> pReturns);
		free(pdbuff);
		return((PD_IC_IO *) NULL);
	}


	/* Initialization successfull, return pdbuff structure. */
	return(pdbuff);
}


/* Function	: _freePDBuffer()
 |
 | Objective	: This function frees up the memory allocated to the
 |		  personal dictionary buffers.
 |
 | Arguments	: SpellEngP *speller	- the SpellEngP structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: None.
 */

void
_freePDBuffer(PDBuffP personal)
{
	int             i;


	/* In case NULL was passed, exit.  Otherwise, recursively free all
	 | the pdbuffers.
	 */
	if (personal == (PDBuffP) NULL)
		return;
	else if (personal->next != (PDBuffP) NULL)
		_freePDBuffer(personal->next);

	for (i = 0; i < ICMAXALT; i++)
		free(personal->pdBuff->pReturns[i]);

	free(personal->pdBuff->pReturns);
	free(personal->pdBuff);

	personal->pdBuff = (PD_IC_IO *) NULL;
}


/* Function	: _terminatePersonalDict()
 |
 | Objective	: This function ends the personal dictionary function of
 |		  the spell checker.
 |
 | Arguments	: SpellEngP *speller	- the SpellEngP structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: True if the personal dictionary was successfully
 |		  terminated, False otherwise.
 |
 | Side Effects : The memory occupied by the pdbuff component of the
 |		  spellBuf structure is freed.
 |
 | Extra Notes	: This function does not save the dictionary.  The personal
 |		  dictionary has to be save first before termination, or
 |		  else modifications will not be save.
 */

Boolean
_terminatePersonalDict(SpellEngP speller)
{
	int             i;	/* General counter. */


	/* If the pdbuff is NULL, then the personal dictionary was not
	 | initialized.  Return false - the pointer may have been set to
	 | NULL accidentally!
	 */
	if (speller->userDict->pdBuff == (PD_IC_IO *) NULL) {
		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _terminatePersonalDict(): %s\n",
		       catgets(_spellCat, 5, 35, "null pdbuff pointer passed"));
		_freePDBuffer(speller->userDict);
		free(speller->userDict);
		speller->userDict = (PDBuffP) NULL;
		return (False);
	}


	/* Stop the dictionary engine first. */
	speller->userDict->pdBuff->task = PDIC_STOP_DICT;
	if ((*FP_icpd) (speller->mainDict->icBuff,
			speller->userDict->pdBuff) != OKRET) {

		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _terminatePersonalDict(): %s\n",
			errnum2errstr(OP_ICPD,
				speller->userDict->pdBuff->xStatus.wError));
		_freePDBuffer(speller->userDict);
		free(speller->userDict);
		speller->userDict = (PDBuffP) NULL;
		return (False);
	}


	/* Now terminate the personal dictionary. */
	speller->userDict->pdBuff->task = PDIC_TERM_PD;
	if ((*FP_icpd) (speller->mainDict->icBuff,
			speller->userDict->pdBuff) != OKRET) {
		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _terminatePersonalDict(): %s\n",
			errnum2errstr(OP_ICPD,
				speller->userDict->pdBuff->xStatus.wError));
		_freePDBuffer(speller->userDict);
		free(speller->userDict);
		speller->userDict = (PDBuffP) NULL;
		return (False);
	}


	/* Termination OK - just free the buffers. */
	_freePDBuffer(speller->userDict);
	free(speller->userDict);
	speller->userDict = (PDBuffP) NULL;
	return (True);
}


/* Function	: _terminateMainDict()
 |
 | Arguments	: ICBUFF *icbuff	- the ICBUFF structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: True if the engine was successfully shut down, False
 |		  otherwise.
 |
 | Side Effects : The memory occupied by the spellBuff structure is freed.
 |
 | Objective	: This function terminates the CDE spell checking engine,
 |		  and frees up the SpellEngP structure.
 |
 | Extra Notes	: None.
 |
 */

Boolean
_terminateMainDict(SpellEngP speller)
{
	/* Value to return. */
	Boolean         terminate_ok;


	/* Terminate the personal dictionary first.  Need to check userDict
	 | just in case the dictionary was terminated prematurely, or
	 | wasn't initialized.
	 */
	if (speller->userDict != NULL)
		_terminatePersonalDict(speller);


	/* Now, terminate the spell engine. */
	speller->mainDict->icBuff->task = ICTERMINATE;
	(*FP_icspl) ((unsigned char *) NULLSTR, speller->mainDict->icBuff);


	/* Now, check if the termination was successful. */
	if (speller->mainDict->icBuff->retcode != OKRET) {
		terminate_ok = False;
		sprintf(_sdtSpellCheckMsg, "_terminateMainDict(): %s\n",
			catgets(_spellCat, 5, 23, 
				"failed to terminate the spelling engine"));
	} else
		terminate_ok = True;


	/* Free the memory used up by the ICBUFF structure before returning
	 | to the calling program.
	 */
	free(speller->mainDict->icBuff);
	speller->mainDict->icBuff = (ICBUFF *) NULL;
	free(speller->mainDict);
	speller->mainDict = (ICBuffP) NULL;

	return (terminate_ok);
}


/* Function	: _addPersonalDict()
 |
 | Arguments	: char         *newWord - word to be added into the user's
 |					  personal dictionary
 |		  SpellEngP    *speller - the SpellEngP structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: Boolean True, if the function successfully added the word
 |		  to the user's personal dictionary, False otherwise.
 |
 | Side Effects : None.
 |
 | Objective	: This function adds a word to the user's personal
 |		  dictionary.
 |
 */

Boolean
_addPersonalDict(char *newWord, SpellEngP speller)
{
	unsigned char  *convWord;	/* Word converted to dictionary   */
	int             convRes;        /* format, and conversion result. */
	int             spellRes;	/* Return code of ICspl().	  */


	if (speller->userDict->pdBuff == (PD_IC_IO *) NULL) {

		/* If NULL, then the personal dictionary isn't being used,
		 | either because the user specified not to use the
		 | dictionary, or some error occured in during
		 | initialization so only the main dictionary is running.
		 | In either case,nothing was added, so send a False value,
		 | and let the calling function deal with this.
		 */
		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _addPersonalDict(): %s\n",
			catgets(_spellCat, 5, 35,
				"null pdbuff pointer passed"));
		return (False);

	} else {

		/* Convert the word to dictionary format. */
		convRes = _convertWord((unsigned char *) newWord, NAT_TO_DEF,
				       speller->mainDict->icBuff,
				       &convWord);
		if (convRes != OKRET) {

			sprintf(_sdtSpellCheckMsg,
				"SDtSpell: _addPersonalDict(): %s\n",
				catgets(_spellCat, 5, 38,
					"format conversion failed"));
			return (False);
		}


		/* Now initialize the pdbuff structure for the add function. */
		speller->userDict->pdBuff->task = PDIC_ADD;
		strcpy((char *) speller->userDict->pdBuff->szWord,
		       (char *) convWord);
		free(convWord);


		/* Add the word. */
		spellRes = (*FP_icpd) (speller->mainDict->icBuff,
				       speller->userDict->pdBuff);
		if (spellRes == OKRET)
			return (True);
		else {

			/* Adding word failed. */
			return (False);
		}
	}
}


/* Function	: _delPersonalDict()
 |
 | Arguments	: char         *word	- word to be deleted from the user's
 |					  personal dictionary
 |		  SpellEngP *speller	- the SpellEngP structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: Boolean True, if the function successfully deleted the
 |		  word from the user's personal dictionary, False otherwise.
 |
 | Side Effects : None.
 |
 | Objective	: This function deletes a word from the user's personal
 |		  dictionary.
 |
 */

Boolean
_delPersonalDict(char *word, SpellEngP * speller)
{
	unsigned char  *convWord;	/* Word converted to dictionary   */
	int             convRes;        /* format, and conversion result. */
	int             spellRes;	/* Return code of ICspl().	  */


	/* Make sure that the pdbuff is not null. */
	if ((*speller)->userDict->pdBuff == (PD_IC_IO *) NULL) {

		/* The personal dictionary isn't being used, either because
		 | the user specified not to use the dictionary, or some
		 | error occured in during initialization so only the main
		 | dictionary is running.  In either case, nothing was
		 | added, so send a False value, and let the calling
		 | function deal with this.
		 */
		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _addPersonalDict(): %s\n",
		       catgets(_spellCat, 5, 35, "null pdbuff pointer passed"));
		return (False);

	} else {

		/* Convert the word to dictionary format. */
		convRes = _convertWord((unsigned char *) word, NAT_TO_DEF,
				       (*speller)->mainDict->icBuff,
				       &convWord);
		if (convRes != OKRET)
			return (False);


		/* Now initialize the pdbuff structure for the delete
		 | function.
		 */
		(*speller)->userDict->pdBuff->task = PDIC_DELETE;
		strcpy((char *) (*speller)->userDict->pdBuff->szWord,
		       (char *) convWord);


		/* Perform the delete operation. */
		spellRes = (*FP_icpd) ((*speller)->mainDict->icBuff,
				       (*speller)->userDict->pdBuff);
		free(convWord);
		if (spellRes == OKRET)
			return (True);
		else {
			sprintf(_sdtSpellCheckMsg,
				"SDtSpell: _delPersonalDict(): %s\n",
				errnum2errstr(OP_ICPD,
			     (*speller)->userDict->pdBuff->xStatus.wError));
			return (False);
		}
	}
}


/* Function	: _getPersonalDictEntry()
 |
 | Arguments	: SpellEngP *speller	- the SpellEngP structure that was
 |					  allocated by the _initMainDict()
 |					  call.
 |
 | Return Value	: Boolean True, if the function successfully retrieved
 |		  some of the personal dictionary's contents, False
 |		  otherwise.
 |
 | Side Effects : None.
 |
 | Objective	: This function retrieves some of the entries in the
 |		  user's personal dictionary.
 |
 */

Boolean
_getPersonalDictEntry(SpellEngP * speller)
{
	/* Set up the task member of the PD_IC_IO structure. */
	(*speller)->userDict->pdBuff->task = PDIC_GETWORD;


	/* Now retrieve the entries. */
	if ((*FP_icpd) ((*speller)->mainDict->icBuff,
			(*speller)->userDict->pdBuff) == OKRET)
		return (True);
	else {
		/* Create error message and return false. */
		return (False);
	}
}


/* Function	: _lockPersonalDict()
 | Arguments	: SpellEngP  *speller	- the 
 |
 |		  Boolean       lockState	- state to tell whether
 |						  the function should lock
 |						  (True) or unlock (False)
 |						  the personal dictionary
 | Return Value : Boolean			- True if the operation
 |						  succeed, False otherwise.
 | Side effects : None.
 |
 | Objective	: This function locks or unlocks the personal dictionary,
 |		  based on the lockState that was specified by the
 |		  user.
 */

Boolean
_lockPersonalDict(SpellEngP * speller, Boolean lockState)
{
	/* Determine what operation we're going to perform, based on the
	 | value of lockState.  If true, we are locking the | personal
	 | dictionary; if false, we are unlocking the | personal dictionary.
	 */
	if (lockState) {
		(*speller)->userDict->pdBuff->task = PDIC_GETWORD_SORT_START;
		(*speller)->userDict->pdBuff->list_num = RETRIEVE_NUM;
	} else
		(*speller)->userDict->pdBuff->task = PDIC_GETWORD_STOP;


	/* Perform the operation on the personal dictionary. */
	if ((*FP_icpd) ((*speller)->mainDict->icBuff, 
	    (*speller)->userDict->pdBuff) == OKRET)
		return (True);
	else {
		sprintf(_sdtSpellCheckMsg,
			"libSDtSpell: _lockPersonalDict(): %s\n",
			errnum2errstr(OP_ICPD,
			(*speller)->userDict->pdBuff->xStatus.wError));
		return (False);
	}
}


/* Function	: _savePersonalDict()
 |
 | Arguments	: PD_IC_IO	*pdbuff		- pointer to the personal
 |						  dictionary structure
 |
 |		  ICBUFF	*icbuff		- the icbuff structure that
 |						  the personal dictionary is
 |						  associated with
 |
 | Return Value	: Boolean True, if the function successfully saved the
 |		  personal dictionary's contents, and False otherwise.
 |
 | Side Effects : None.
 |
 | Objective	: This function saves the user's personal dictionary.
 |		  This function is called when a user quits out of the
 |		  spell checker, or if the data buffer containing
 |		  the contents of the personal dictionary limit is
 |		  reached.
 |
 */

Boolean
_savePersonalDict(SpellEngP speller)
{
	/* Return value if save was successful or not. */
	Boolean         save_ok = True;


	/* Determine wheter to break out of while loop */
	Boolean         break_out = False;


	/* Status from the ICpd() call. */
	int             status;


	/* First - need to save the contents of the personal dictionary. If
	 | error is PD_DB_BUSY, keep on trying the save until successful,
	 | or until another kind of error code was returned.
	 */
	speller->userDict->pdBuff->task = PDIC_SAVE;
	strcpy((char *) speller->userDict->pdBuff->szCloseFilename,
	       (char *) speller->userDict->pdBuff->szOpenFilename);
	strcpy((char *) speller->userDict->pdBuff->ClosePath.path,
	       (char *) speller->userDict->pdBuff->OpenPath.path);
	speller->userDict->pdBuff->byCtype = PD_RAW_FILE;
	while (!break_out) {

		status = (*FP_icpd) (speller->mainDict->icBuff,
				     speller->userDict->pdBuff);
		if ((status == OKRET) || (speller->userDict->pdBuff->xStatus.wError != PD_DB_BUSY));
		break_out = True;
	}


	/* If an error other than PD_DB_BUSY occurred, then inform user. */
	if (status != OKRET) {

		/* Determine what kind of error occured. */
		sprintf(_sdtSpellCheckMsg,
			"libSDtSpell: _savePersonalDict(): %s\n\n%s\n",
			errnum2errstr(OP_ICPD, 
			speller->userDict->pdBuff->xStatus.wError),
			catgets(_spellCat, 5, 20, 
			"Any modifications made will not be saved."));


		/* Even though we had an error, we still need to terminate
		 | the personal dictionary.  Just close it without saving
		 */
		speller->userDict->pdBuff->task = PDIC_NOSAVE;
		(*FP_icpd) (speller->mainDict->icBuff,
			    speller->userDict->pdBuff);
		save_ok = False;
	}
	return (save_ok);
}


/* Function	: _convertWord()
 | 
 | Arguments	: unsigned char	*word	- the word to convert from one
 | 					  kind of format to another
 |		  int 		flag	- tells type of conversion to
 | 					  perform
 |		  ICBUFF	*icbuff	- the spell engine buffer structure
 |		  unsigned char **conv	- place holder for the converted word
 | 
 |
 | Return Value	: unsigned char		- the word in its converted format.
 | Side effects	:	The returned converted word must be manually freed
 |			by the calling function, or else memory will not
 |			be deallocated.
 |
 | Objective	:	This function converts the given word from one format
 |			to another.  If DEF_TO_NAT is passed for the flag,
 |			then this function will convert the word from 
 |			Inso Spell Library format to the machine's native
 |			format.  If the flag NAT_TO_DEF is passed, then
 |			the function converts the word from the machine's
 |			native format to Inso Spell Library format.
 |			
 |			The conversion is required in order to search for
 |			the word in the dictionaries that Inso provides.
 |
 |			If the conversion fails, then the value returned
 |			should be null.
 |
 */

int
_convertWord(unsigned char *word, int flag, ICBUFF * icbuff,
	     unsigned char **conv)
{
	/* Result to return. */
	int             result;


	/* Allocate space for the converted word. */
	*conv = (unsigned char *) calloc(2 * strlen((char *) word), 
					 sizeof(unsigned char));


	/* Convert the word. */
	result = (*FP_slchcnv) (word, (int) strlen((char *) word), *conv,
				flag, icbuff->lang);
	if (result != OKRET) {
		free(*conv);
		*conv = (unsigned char *) NULL;
		if (flag = NAT_TO_DEF)
			sprintf(_sdtSpellCheckMsg, "libSDtSpell: %s\n",
				catgets(_spellCat, 5, 25,
			        "word conversion to dictionary format failed"));
		else
			sprintf(_sdtSpellCheckMsg, "libSDtSpell: %s\n",
				catgets(_spellCat, 5, 36,
				"word conversion to system format failed"));
	}
	return (result);
}

	
/* Function	: _correctWord()
 |
 | Arguments	: ICBUFF *icbuff	- icbuff structure used when
 |					  performing the correct operation
 |		  int task		- task to ICspl(); valid values are
 |					  ICCORRECT, ICCORMORE, ICSPACEINSERT
 |		  Boolean *do_more	- set to true if more alternatives
 |					  can be derived by another call to
 |					  _correctWord();
 |
 | Return Value	: True if correction alternatives were found, False
 |		  otherwise.
 |
 | Side Effects : The members of the icbuff variable may have been updated 
 |		  by the ICspl() call, e.g., list[] for alternate word list, 
 |		  error_flags and process_flags for further info about the 
 |		  results of the ICspl() call, and the like. 
 |
 | Objective	: Given an incorrectly spelled word, this function calls
 |		  on ICspl() to generate a list of words that are possible
 |		  corrections to the word.
 |
 */

Boolean
_correctWord(ICBUFF ** icbuff, int task, Boolean * do_more)
{
	/* Assign the icbuff variable, for local manipulation. */
	ICBUFF         *spell_buf = *icbuff;


	/* Assume we can't get any more alternatives if we call
	 | _correctWord() again.
	 */
	*do_more = False;


	/* Perform the specified correction task.  Rather than just assign
	 | the task, check that the task is valid by a switch statement.
	 | The task may be valid, but not be supported by the engine
	 | implementation.
	 */
	switch (task) {

	case ICCORRECT:
		spell_buf->task = ICCORRECT;
		break;


	case ICSPACEINSERT:
		spell_buf->task = ICSPACEINSERT;
		break;


	case ICCORMORE:
		spell_buf->task = ICCORMORE;
		break;


	default:
		sprintf(_sdtSpellCheckMsg, "_correctWord(): %s",
		  catgets(_spellCat, 5, 32, "uknown correction task code"));
		return (False);
	}
	(*FP_icspl) ((unsigned char *) NULLSTR, spell_buf);


	/* Perform extended correction. */
	spell_buf->all_steps = True;


	/* Check the return code. */
	switch (spell_buf->retcode) {

	case ICRETDONE:
	case ICRETFULL:
		return (True);


	case ICRETCONT:
		*do_more = True;
		return (True);


	case ERRET:
	default:
		sprintf(_sdtSpellCheckMsg, "_correctWord(): %s",
			catgets(_spellCat, 5, 27, "unknown spell engine error occurred while trying to find corrections\n"));
		return (False);
	}
}


/* Function	: _verifyWord()
 |
 | Objective	: Verifies that the given word is correctly spelled.
 |
 | Arguments	: char     *word	- word to verify, from the text 
 |					  edit widget
 |		  ICBUFF   **icbuff	- icbuff structure used when 
 |					  performing the verify operation
 |		  Boolean  *altFound	- a variable that is set to True
 |					  when the verify operation is able
 |					  to provide a list of alternates,
 |					  and False otherwise
 |
 | Return Value	: True if the word was verified as a correctly spelled word,
 |		  False otherwise.
 |
 | Side Effects : The altFound variable is set to true if a list of
 |		  alternate words was generated.
 |
 | Extra Notes	: None.
 |
 */

Boolean
_verifyWord(char *word, ICBUFF ** icbuff, Boolean * altFound)
{
	unsigned char  *convWord;	/* The input word in dictionary   */
	int             convRes;        /* format, and conversion result. */
	int             spellRes;	/* Result of ICspl() call.	  */
	Boolean         verifyOK;	/* Value to return to the user.   */


	/* Check that the word is not a NULL string. */
	if (word == (char *) NULL) {

		sprintf(_sdtSpellCheckMsg, "_verifyWord(): %s\n",
			catgets(_spellCat, 5, 24,
			"no word provided for verification"));
		return (False);
	}


	/* Convert the word into the dictionary format. */
	convRes = _convertWord((unsigned char *) word, NAT_TO_DEF,
			       (*icbuff), &convWord);
	if (convRes != OKRET)
		return (False);


	/* Assume that there are no alternatives. Only turn this to true if
	 | ICRETALT was returned by ICspl().
	 */
	*altFound = False;


	/* Now, verify that word is in the dictionary. */
	(*icbuff)->task = ICVERIFY;
	spellRes = (*FP_icspl) (convWord, (*icbuff));
	switch (spellRes) {

	case ICRETINVALID:
	case ICRETNOTFOUND:
		/* Invalid or incorrect word with no alternatives found. */
		verifyOK = False;
		break;


	case ICRETALT:
		/* Incorrect word, but alternatives were found in either
		 | the main dictionary or in the user's personal dictionary.
		 */
		*altFound = True;
		verifyOK = False;
		break;


	case ICRETPREPROC:
	case ICRETFOUND:
		/* Word was found in the dictionary. */
		verifyOK = True;
		break;


	case ERRET:
		/* If erret returned, and the process_flags and error_flags
		 * are not set, then the word that was passed in is not
		 * a word - probably just a string of symbols, like in
		 * a signature line.  In this case, return True, i.e.,
		 * assume correct, and go check the next word.  Otherwise,
		 * assume a processing error!
		 */
		if ((*icbuff)->process_flags == 0 && 
		    (*icbuff)->error_flags == 0)
			verifyOK = True;
		else {
			sprintf(_sdtSpellCheckMsg,
				"SDtSpell: _verifyWord(): %s%s\n",
				catgets(_spellCat, 5, 26, "unknown spell engine error occurred while trying to verify word: "),
				word);
			verifyOK = False;
		}
		break;


	default:
		sprintf(_sdtSpellCheckMsg,
			"SDtSpell: _verifyWord(): %s%s\n",
			catgets(_spellCat, 5, 26, "unknown spell engine error occurred while trying to verify word: "),
			word);
		verifyOK = False;
		break;
	}


	/* Free memory occupied by conv_word, before returning. */
	free(convWord);
	return (verifyOK);
}
