.de LI
.\" simulate -mm .LIs by turning them into .TPs
.TP \\n()Jn
\\$1
..
.de Lc
.\" version of .LI that emboldens its argument
.TP \\n()Jn
\s-1\f3\\$1\f1\s+1
..
.TH SdmSystemUtility 3 "10/17/96"
.BH "10/17/96"
.\" @(#)SdmSystemUtility.3	1.1 96/10/17 SMI
.\" CDE Common Source Format, Version 1.0.0
.\" (c) Copyright 1993, 1994, 1995, 1996 Hewlett-Packard Company
.\" (c) Copyright 1993, 1994, 1995, 1996 International Business Machines Corp.
.\" (c) Copyright 1993, 1994, 1995, 1996 Sun Microsystems, Inc.
.\" (c) Copyright 1993, 1994, 1995, 1996 Novell, Inc.
.SH NAME
SdmSystemUtility \- general system level utility class
.SH SYNOPSIS
.\"
.SS Includes
.ft 3
.nf
#include <SDtMail/SystemUtility.hh>
.\"
.SS Creation
All member methods are static; class cannot be instantiated.
.\"
.SS Methods
.nf
.sp 0.5v
.ft 3
.ta \w'char* Sdm'u
char* SdmSystemUtility::GetHostName();
.PP
.ft 3
.ta \w'void Sdm'u
void SdmSystemUtility::GetGroupName(
	char* \f2grp_name\fP);
.PP
.ft 3
.ta \w'gid_t Sdm'u
gid_t SdmSystemUtility::GetIdForGroupName(
	char* \f2grp_name\fP);
.PP
.ft 3
.ta \w'void Sdm'u
void SdmSystemUtility::GetPasswordEntry(
	passwd & \f2result\fP);
.PP
.ft 3
.ta \w'SdmErrorCode Sdm'u
SdmErrorCode SdmSystemUtility::ImapServiceVerify(
	SdmError& \f2err\fP,
	char* \f2host\fP,
	long \f2port\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::Random();
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeAccess(
	const char* \f2path\fP,
	int \f2amode\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeClose(
	int \f2fd\fP);
.PP
.ft 3
.ta \w'void Sdm'u
void SdmSystemUtility::SafeCtime(
	const time_t \f2*clock\fP,
	char* \f2buf\fP,
	int buflen = \f226\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeDup2(
	int \f2fd1\fP,
	int \f2fd2\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeExecvp(
	const char* \f2file\fP,
	char* const \f2*argv\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeFChmod(
	int \f2fd\fP,
	mode_t \f2mode\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeFStat(
	int \f2fd\fP,
	struct stat * \f2buf\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeFTruncate(
	int \f2fd\fP,
	off_t \f2len\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeFchown(
	int \f2fd\fP,
	uid_t \f2owner\fP,
	gid_t \f2group\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeFsync(
	int \f2fd\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeGuaranteedStat(
	const char* \f2path\fP,
	struct stat * \f2buf\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeLStat(
	const char* \f2path\fP,
	struct stat * \f2buf\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeLink(
	const char* \f2existingPath\fP,
	const char* \f2newPath\fP);
.PP
.ft 3
.ta \w'void Sdm'u
void SdmSystemUtility::SafeLocaltime(
	const time_t \f2*clock\fP,
	tm & \f2result\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeLockf(
	int \f2fd\fP,
	int \f2func\fP,
	long \f2size\fP);
.PP
.ft 3
.ta \w'off_t Sdm'u
off_t SdmSystemUtility::SafeLseek(
	int \f2fd\fP,
	off_t \f2offset\fP,
	int \f2whence\fP);
.PP
.ft 3
.ta \w'time_t Sdm'u
time_t SdmSystemUtility::SafeMktime(
	tm * \f2timeptr\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeOpen(
	const char* \f2path\fP,
	int \f2oflag\fP,
	mode_t mode = \f20644\fP);
.PP
.ft 3
.ta \w'ssize_t Sdm'u
ssize_t SdmSystemUtility::SafeRead(
	int \f2fd\fP,
	void * \f2buf\fP,
	size_t \f2bytes\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeRemove(
	const char* \f2path\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeRename(
	const char* \f2oldPath\fP,
	const char* \f2newPath\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeStat(
	const char* \f2path\fP,
	struct stat * \f2buf\fP);
.PP
.ft 3
.ta \w'size_t Sdm'u
size_t SdmSystemUtility::SafeStrftime(
	char* \f2buf\fP,
	size_t \f2buf_size\fP,
	const char* \f2format\fP,
	const tm * \f2timeptr\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeTruncate(
	const char* \f2path\fP,
	off_t \f2len\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeUTime(
	const char* \f2path\fP,
	utimbuf * \f2ntime\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeUnlink(
	const char* \f2path\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeWait(
	int * \f2status\fP);
.PP
.ft 3
.ta \w'int Sdm'u
int SdmSystemUtility::SafeWaitpid(
	pid_t \f2proc\fP,
	int * \f2status\fP,
	int \f2options\fP);
.PP
.ft 3
.ta \w'ssize_t Sdm'u
ssize_t SdmSystemUtility::SafeWrite(
	int \f2fd\fP,
	const void * \f2buf\fP,
	size_t \f2bytes\fP);
.PP
.ft 3
.ta \w'ssize_t Sdm'u
ssize_t SdmSystemUtility::SafeWriteStrip(
	int \f2fd\fP,
	const void * \f2buf\fP,
	size_t \f2bytes\fP);
.PP
.ft 3
.ta \w'unsigned long Sdm'u
unsigned long SdmSystemUtility::SafeWritev(
	int \f2fd\fP,
	struct iovec \f2*iov\fP,
	int \f2iovcnt\fP);
.PP
.ft 3
.ta \w'SdmErrorCode Sdm'u
SdmErrorCode SdmSystemUtility::SmtpServiceVerify(
	SdmError& \f2err\fP,
	char* \f2host\fP,
	long \f2port\fP);
.PP
.ft 3
.ta \w'SdmErrorCode Sdm'u
SdmErrorCode SdmSystemUtility::TcpServiceVerify(
	SdmError& \f2err\fP,
	char* \f2host\fP,
	char* \f2service\fP,
	long \f2port\fP);
.\"
.fi
.ft 1
.\" end of methods list
.ta 0.25i 0.50i 0.75i 1.0i 1.25i 1.50i 1.75i 2.0i 2.5i 3.0i
.SH DESCRIPTION
The SdmSystemUtility class provides general methods for manipulating "system
level" type activities.  Some of the methods are meant to be used internally by
the library and thus are not documented in this manual page.
.PP
USE OF METHODS NOT DOCUMENTED IN THIS MANUAL PAGE BY CLIENTS OF THE LIBRARY IS STRONGLY
DISCOURAGED.
.PP
.SH METHOD TYPES
There are two basic types of methods provided by this class: safe system call
interfaces, and system utility interfaces.
.SS Safe system call interfaces
Any method that begins with the word 'Safe' is an interface to the system call
that matches the remainder of the method's name. For example, 'SafeOpen' is an
interface to the 'Open' system call. The arguments and return values are
identical to those provided by the real system call, and thus they are not
documented in this manual page. Refer to the system manual page for details.
.PP
The reason for these interfaces is to trap the 'EINTR' error return and cause
the system call to be restarted. In a multi-threaded environment where signals
are enabled, it is possible that system calls may be unexpectedly
interrupted. If the 'EINTR' error is returned, the system call should be
restarted unless the code in question is prepared to handle the signal event
(e.g. calling poll()). In general, these safe system call interfaces should be
always used in place of calling the system call directly.
.SS System utility interfaces
All methods that do not begin with the word 'Safe' are utility methods that provide
"system level" type functionality and so are provided in this class.
.\"
.SH CREATION
The SdmSystemUtility class is a container for general methods that deal with messages and
message containers; as such no SdmSystemUtility object can be created or destroyed.
.\"
.SH DESTRUCTION
The SdmSystemUtility class is a container for general methods that deal with messages and
message containers; as such no SdmSystemUtility object can be created or destroyed.
.\"
.SH METHODS
The following static methods are provided:
.PP
.\"
.SS \f3GetHostName\fP
()

This method returns the official name of the host on which the application is running.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "None."
.br

.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(char* )\fP"
.br
A pointer to a character string containing the name of the current host is
returned. This character string is not allocated in dynamic memory. This character
string must NOT be passed to free() or any other memory deallocation method.
.PP
.RE
.nr )J 0
.\"
.SS \f3GetGroupName\fP
(\f3grp_name\fP)

This method returns the name of the primary group in which the user running the
application belongs.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3grp_name\fP (\f3char*\fP)"
.br
This is a pointer to a buffer of memory with at least 1024 bytes of memory in it. This
buffer is then filled in with the primary group name in which the user running the
application belongs. If the buffer is too small, memory corruption will occur.
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "None."
.br

.PP
.RE
.nr )J 0
.\"
.SS \f3GetIdForGroupName\fP
(\f3grp_name)

This method returns the systems numeric i.d. for a corresponding character group name.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3grp_name\fP (\f3\fP)"
.br
This is the name of the group whose id is to be looked up.
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(gid_t)\fP"
.br
The id corresponding to the character group name passed in is returned; a -1 is returned
if the group name passed in is not valid (does not exist).
.PP
.RE
.nr )J 0
.\"
.SS \f3GetPasswordEntry\fP
(\f3result\fP)

Get the password entry for the user running the application.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3result\fP (\f3passwd&\fP)"
.br
A pointer to a passwd structure to be filled in with the entry for the current user
running the application.
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "None."
.br

.PP
.RE
.nr )J 0
.\"
.SS \f3ImapServiceVerify\fP
(\f3err\fP, \f3host\fP, \f3port\fP)

This method is used to verify that a given host has an imap server available.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3err\fP (\f3SdmError&\fP)"
.br
Error container, used to store return result code.
.LI "\f3host\fP (\f3char*\fP)"
.br
A character string representing the name of the host to check to see if an imap server is
running on.
.LI "\f3port\fP (\f3long\fP)"
.br
The port number on which the service is supposed to be running. This is normally 0 to cause
the default port for the IMAP service to be checked. Only if the user overrides the port
number should a non-zero value be specified. Usually the default port for IMAP service is
the appropriate port to be used.
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(SdmErrorCode)\fP"
.br
Value of return result code stored in err argument. See the description of TcpServiceVerify()
for a list of possible return error codes.
.PP
.RE
.nr )J 0
.\"
.SS \f3Random\fP
()

Return a random number.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "None."
.br

.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(int)\fP"
.br
A random number is returned.
.PP
.RE
.nr )J 0

.\"
.SS \f3SmtpServiceVerify\fP
(\f3err\fP, \f3host\fP, \f3port\fP)

This method is used to verify that a given host has an Smtp server available.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3err\fP (\f3SdmError&\fP)"
.br
Error container, used to store return result code.
.LI "\f3host\fP (\f3char*\fP)"
.br
A character string representing the name of the host to check to see if an Smtp server is
running on.
.LI "\f3port\fP (\f3long\fP)"
.br
The port number on which the service is supposed to be running. This is normally 0 to cause
the default port for the Smtp service to be checked. Only if the user overrides the port
number should a non-zero value be specified. Usually the default port for Smtp service is
the appropriate port to be used.
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(SdmErrorCode)\fP"
.br
Value of return result code stored in err argument. See the description of TcpServiceVerify()
for a list of possible return error codes.
.PP
.RE
.nr )J 0
.\"
.SS \f3TcpServiceVerify\fP
(\f3err\fP, \f3host\fP, \f3service\fP, \f3port\fP)

This method is used to verify that a given host has a specific service available
via the TCP/IP local area network.
.PP
Arguments:
.PP
.RS 3
.nr )J 6
.LI "\f3err\fP (\f3SdmError&\fP)"
.br
Error container, used to store return result code.
.LI "\f3host\fP (\f3char*\fP)"
.br
A character string representing the name of the host to check to see if the specified
service is available.
.LI "\f3service\fP (\f3char*\fP)"
.br
A character string representing the name of the service to be checked for. See the
documentation on the /etc/services file (service(4)). Typically, this would be
'imap', 'smtp', etc. If a service is specified, the port number for the service
is automatically determined and the port argument to this method is ignored.
.br
If this argument is NULL (0), then the port number argument to this method is used to
attempt to connect to. The service must be listening on that port for this method to
return success.
.LI "\f3port\fP (\f3long\fP)"
.br
This argument specifies the port number on which the service being queried is listening.
It is only used if the service argument to this method is NULL (0).
.PP
.RE
.nr )J 0
Return value:
.RS 3
.nr )J 7
.LI "\f3(SdmErrorCode)\fP"
.br
One of the following error codes will be returned:
.br
\f3Sdm_EC_Success\fP - the specified service is available
.br
\f3Sdm_EC_NET_BadPortNumberSpecified\fP - the host name was followed by a port number
specifier (e.g. hostname:port) but the port specified is not all numeric characters.
.br
\f3Sdm_EC_NET_HostNameSyntaxError\fP - the host name was enclosed in [] characters and so was
interpreted as a numeric I.P. address (e.g. [129.155.12.45]) and that address was not
syntactically correct. See the manual page on inet_addr(3n).
.br
\f3Sdm_EC_NET_HostDoesNotExist\fP - the host name specified is not reachable on the 
current local area network.
.br
\f3Sdm_EC_NET_CannotCreateConnection\fP - a network connection could not be opened; probably
due to a system resource limit being reached.
.br
\f3Sdm_EC_NET_ServiceNotAvailable\fP - the specified service is not available on the host.
.PP
.RE
.nr )J 0
.\"
.RE
.nr )J 0
