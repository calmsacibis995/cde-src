//%%  (c) Copyright 1993, 1994 Hewlett-Packard Company			
//%%  (c) Copyright 1993, 1994 International Business Machines Corp.	
//%%  (c) Copyright 1993, 1994 Sun Microsystems, Inc.			
//%%  (c) Copyright 1993, 1994 Novell, Inc. 				
//%%  $Revision: $ 			 				
/* @(#)dm_key.C	1.17 93/09/07
 * Tool Talk Database Manager (DM) - dm_key.cc
 *
 * Copyright (c) 1990 by Sun Microsystems, Inc.
 *
 * Implementation of the _Tt_key class.
 */

#include "dm/dm.h"
#include "dm/dm_key.h"
#include "util/tt_assert.h"
#include "util/tt_base64.h"
#include <sys/types.h>
#include <time.h>
#include <sys/time.h>

#if defined(ultrix)
#include <sys/time.h>
extern "C" void gettimeofday(struct timeval *,struct timezone *);
#endif

#include <sys/timeb.h>
#include <memory.h>
#include <stdlib.h>
#include <unistd.h>

_Tt_key::
_Tt_key(short ver_num)
{
	// XXX: we really wish there were a portable way to get unique
	// timestamp values.  Until then, there's this hack.  The
	// time_usec values are misnamed, left over from a previous
	// version that tried to use a microsecond timer.  They're
	// really just a count of the number of oids generated this
	// second.  This is actually still buggy since if we somehow
	// generate more than 10000 pids per second, we could clash
	// with oids generated by other processes on the system.
	// But I'm willing to bet on that not happening.

	static long lasttime_sec = 0;
	static long lasttime_usec = 0;

	long host_id = _tt_dm->host_id();
	_key.version = ver_num;
	_key.padding = 0;
	_key.hostid = _tt_dm->host_id();
	_key.time_sec = time(NULL);
	if (lasttime_sec != _key.time_sec) {
		// first key generated this second;
		lasttime_usec = _key.time_usec = getpid()*10000;
	} else {
		_key.time_usec = ++lasttime_usec;
	}
}

_Tt_key::
_Tt_key(_Tt_key_ptr key)
{
	_key = key->_key;
}

_Tt_key::
_Tt_key(_Tt_string s)
{
	// This is currently used in several ways: either to take in a
	// 16-byte binary version of a key, or to take in a longer
	// ascii-encoded version of the key.  We distinguish between
	// the two cases by checking the first byte-- this is the
	// high order byte of the version number which is zero.

	// XXX: this needs to be cleaned up -- for example, whereever
	// a 16-byte _Tt_string is used for a key, a _Tt_key instance
	// should be used instead, thus saving all the conversions.

	if (s[0]=='\0') {
		// just ram in the bits
		memcpy((char *)&_key, (char *)s, OID_KEY_LENGTH);
	} else {
		// decode
		_Tt_string t;
		s = s.split('|',t);
		_key.version = (unsigned short)_tt_base64_decode(t);
		// In the future, if the key format changes, it may
		// be necessary to check the version here and
		// decode according to the version number.
		_key.padding = (unsigned short)0;
		s = s.split('|',t);
		_key.hostid = _tt_base64_decode(t);
		s = s.split('|',t);
		_key.time_sec = _tt_base64_decode(t);
		_key.time_usec = _tt_base64_decode(s);
	}
}

_Tt_key::
_Tt_key(const unsigned char *s)
{
	memcpy((char *)&_key, (const char *)s, OID_KEY_LENGTH);
}

_Tt_key::
~_Tt_key()
{
}

/*
 *  _Tt_string - converts a key to a printable string.
 * The string is of the form:
 *   <version number>|<hostid>|<sec>|<usec>
 *   each component is encoded as an unsigned base-64 number using 
 *   0-9, a-z, A-Z, - and _ as the digits.
 */

_Tt_key::
operator _Tt_string() const
{
	_Tt_string result("");
	result = result.cat(_tt_base64_encode(_key.version));
	result = result.cat("|");
	result = result.cat(_tt_base64_encode(_key.hostid));
	result = result.cat("|");
	result = result.cat(_tt_base64_encode(_key.time_sec));
	result = result.cat("|");
	result = result.cat(_tt_base64_encode(_key.time_usec));
	return result;
}

short _Tt_key::
version_number() const
{
	return _key.version;
}

const char * _Tt_key::
content() const
{
	return (char *)&_key;	// should be unused, I hope
}

int _Tt_key::
operator== (const _Tt_key &key) const
{
	// Very minor optimization:: compare the most likely differences
	// first
	return (_key.time_sec==key._key.time_sec &&
		_key.time_usec==key._key.time_usec && 
		_key.version==key._key.version &&
		_key.padding==key._key.padding &&
		_key.hostid==key._key.hostid);
}

void _Tt_key::
print(FILE *fs) const
{
	fprintf(fs, "%s", (char *)(_Tt_string)*this);
}


