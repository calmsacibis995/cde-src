/*** DTB_USER_CODE_START vvv Add file header below vvv ***/
/*** DTB_USER_CODE_END   ^^^ Add file header above ^^^ ***/

/*
 * File: sdtfprop_stubs.c
 * Contains: Module callbacks and connection functions
 *
 * This file was generated by dtcodegen, from module sdtfprop
 *
 * Any text may be added between the DTB_USER_CODE_START and
 * DTB_USER_CODE_END comments (even non-C code). Descriptive comments
 * are provided only as an aid.
 *
 *  ** EDIT ONLY WITHIN SECTIONS MARKED WITH DTB_USER_CODE COMMENTS.  **
 *  ** ALL OTHER MODIFICATIONS WILL BE OVERWRITTEN. DO NOT MODIFY OR  **
 *  ** DELETE THE GENERATED COMMENTS!                                 **
 */

#include <stdio.h>
#include <Xm/Xm.h>
#include "dtb_utils.h"
#include "sdtfprop.h"
#include "sdtfprop_ui.h"

/*
 * Header files for cross-module connections
 */
#include "sdtfprop_ui.h"


/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All necessary header files have been included.
 ***
 *** Add include files, types, macros, externs, and user functions here.
 ***/

#include "sdtfprop_uc.h"

/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/



void 
sdtfprop_mod_cancelButton_CB1(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    DtbSdtfpropModdialogInfo	dtbTarget = (DtbSdtfpropModdialogInfo)clientData;
    DtbSdtfpropModdialogInfo	instance = dtbTarget;	/* obsolete */
    
    if (!(dtbTarget->initialized))
    {
        dtb_sdtfprop_moddialog_initialize(dtbTarget, dtb_sdtfprop_propdialog.propdialog);
    }
    XtUnmanageChild(instance->moddialog_shellform);
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogOK_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    if ( proginfo.current_pane == INFO_PANE )
        exit( 0 );

    ProcessPermissionPaneExit( False );

    exit( 0 );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogApply_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    ProcessPermissionPaneExit( False );

    return;

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogReset_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    _DtTurnOnHourGlass( proginfo.topLevel );

    LoadNewFile( (proginfo.current_fdata)->file_name );

    _DtTurnOffHourGlass( proginfo.topLevel );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogCancel_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    if ( ( proginfo.current_pane == INFO_PANE ) ||
         ProcessPermissionPaneExit( True ) )
        exit( 0 );
    else
        return;

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogHelp_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    ShowHelpDialog( HELP_VOLUME, HELP_HOMETOPIC_ID );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogDelete_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    char		msg_str[BUF_SIZ];
    register int	i;
    int			answer;
    int			d_list[256];	/* Default ACL entries position list */
    int			d_cnt;		/* Number of default ACL entries */
    int			pos_cnt = 0;
    int			*pos_list = NULL;
    aclent_t		*aclentry;
    ListEntryData	*listentry;
    ListItemRec		*curr;

    /*
     * Since we have hard-coded XmNselectionPolicy as XmBROWSE_SELECT
     * (single selection) so there should only be 1 item selected.
     */
    if (XmListGetSelectedPos(instance->accessList,&pos_list,&pos_cnt) == False)
        return;

    if ((aclentry = GetListItemsEntry(proginfo.list.items, *pos_list)) == NULL)
        return;

    /*
     * Check to see if we are deleting a default ACL entry.  If we are
     * deleting a default ACL entry, then we must delete all default ACL
     * entries from the list first.
     */
    if ( ( aclentry->a_type == DEF_USER_OBJ ) ||
         ( aclentry->a_type == DEF_GROUP_OBJ ) ||
         ( aclentry->a_type == DEF_OTHER_OBJ ) ||
         ( aclentry->a_type == DEF_CLASS_OBJ ) ) 
    {
        i = 1;
        d_cnt = 0;
        curr = proginfo.list.items;
        memset( (void *)d_list, 0, sizeof(d_list) );

        /* Find the position of all the default ACL entries in the list */
        while ( curr != NULL )
        {
            if ( (curr->acl_entry).a_type & ACL_DEFAULT )
                d_list[d_cnt++] = i;

            i++;
            curr = curr->next;
        }

        msg_str[0] = '\0';
        sprintf( msg_str, catgets( Dtb_project_catd, 3, 47, "Deleting Default Owning User, Default Owning Group, Default Other,\nor Default Mask will resulted in all default ACL entries being deleted.\n\nDo you want to delete all default ACL entries?" ) );

        answer = AlertPrompt( proginfo.topLevel,
            DIALOG_TYPE, XmDIALOG_QUESTION,
            DIALOG_TITLE,
            catgets( Dtb_project_catd, 3, 18, "Properties : Delete Confirmation" ),
            DIALOG_STYLE, XmDIALOG_PRIMARY_APPLICATION_MODAL,
            DIALOG_TEXT, msg_str,
            BUTTON_IDENT, ANSWER_ACTION_1,
            catgets( Dtb_project_catd, 3, 9, "Delete" ),
            BUTTON_IDENT, ANSWER_CANCEL,
            catgets( Dtb_project_catd, 2, 21, "Cancel" ),
            NULL );

        if ( answer == ANSWER_ACTION_1 )
        {
            proginfo.list.has_def_user_obj = False;
            proginfo.list.has_def_group_obj = False;
            proginfo.list.has_def_other_obj = False;
            proginfo.list.has_def_class_obj = False;

            /*
             * Because the entry in the list widget is stored in ascending
             * order, we need to delete the entries from the list in
             * descending order.
             */
            for ( i = d_cnt - 1 ; i >= 0 ; i-- )
            {
                if ( d_list[i] != 0 )
                    proginfo.list.items = DeleteListItemsEntry(
                        proginfo.list.items, d_list[i] );
            }
        }
    }
    else
    {
        listentry = CvtAclEntryToListEntry( *aclentry );

        msg_str[0] = '\0';
        sprintf( msg_str, catgets( Dtb_project_catd, 3, 40, "Do you want to delete this ACL entry?\n\nType:  %-*s   Name:  %s" ), C_FIELD_SIZE, listentry->class, listentry->name );

        answer = AlertPrompt( proginfo.topLevel,
            DIALOG_TYPE, XmDIALOG_QUESTION,
            DIALOG_TITLE,
            catgets( Dtb_project_catd, 3, 18, "Properties : Delete Confirmation" ),
            DIALOG_STYLE, XmDIALOG_PRIMARY_APPLICATION_MODAL,
            DIALOG_TEXT, msg_str,
            BUTTON_IDENT, ANSWER_ACTION_1,
            catgets( Dtb_project_catd, 3, 9, "Delete" ),
            BUTTON_IDENT, ANSWER_CANCEL,
            catgets( Dtb_project_catd, 2, 21, "Cancel" ),
            NULL );

        if ( answer == ANSWER_ACTION_1 )
        {
            proginfo.list.items =
                DeleteListItemsEntry( proginfo.list.items, *pos_list );
        }

        XtFree( (char *)listentry );
    }

    XtFree( (char *)aclentry );
    XtFree( (char *)pos_list );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogACL_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    if ( XtIsManaged( instance->aclPermCpane ) )
        HideACL();
    else
        ShowACL();

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogChange_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropModdialogInfo instance = &dtb_sdtfprop_moddialog;

    int *pos_list = NULL;
    int pos_cnt = 0;

    /* Get the position of the selected item */
    if ( XmListGetSelectedPos( dtb_sdtfprop_propdialog.accessList,
                               &pos_list, &pos_cnt ) == False )
    {
        return;
    }

    /*
     * Since we have hard-coded XmNselectionPolicy as XmBROWSE_SELECT
     * (single selection) so there should only be 1 item selected.
     */
    SetModDialogValues( CHG_OP, *pos_list ); 

    XtFree( (char *)pos_list );

    XtManageChild( instance->moddialog_shellform );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogAdd_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropModdialogInfo instance = &dtb_sdtfprop_moddialog;

    int *pos_list = NULL;
    int pos_cnt = 0;

    /* Get the position of the selected item */
    if ( XmListGetSelectedPos( dtb_sdtfprop_propdialog.accessList,
                               &pos_list, &pos_cnt ) == False )
    {
        /* Add the new entry at the bottom of the list */
        SetModDialogValues( ADD_OP, 0 ); 
    }
    else
    {
        /* Add the new entry below the current selected item */
        SetModDialogValues( ADD_OP, *pos_list ); 
        XtFree( (char *)pos_list );
    }

    XtManageChild( instance->moddialog_shellform );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogItemSelect_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    register int i; 
    int		 position =  ((XmListCallbackStruct *)callData)->item_position;
    ListItemRec	*list = proginfo.list.items;

    if ( ( list == NULL ) || ( proginfo.is_modifiable == False ) )
        return;				/* Error - shouldn't be here */

    /* Find the ACL entry in the list */
    for ( i = 1 ; i < position ; i++ )
    {
        if ( list->next != NULL )
            list = list->next;          /* Keep going... */
        else
            return;			/* Entry doesn't exist */
    }

    /* Can't delete the Mask */
    if ( (list->acl_entry).a_type == CLASS_OBJ )
        XtSetSensitive( instance->deleteButton, False );
    else
        XtSetSensitive( instance->deleteButton, True );

    XtSetSensitive( instance->changeButton, True );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
ModDialogPermChange_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropModdialogInfo instance = (DtbSdtfpropModdialogInfo)clientData;

    Boolean     give_warning = False;
    int         mask = 7; 
    int		perm, r_perm, w_perm, x_perm, class_type;
    String	eperm;
    XmString	label_xmstring;

    /* Use the real MASK if the ACL type is USER or GROUP */
    class_type = GetModDialogClassType();

    if ( ( class_type == USER ) || ( class_type == GROUP ) )
        mask = GetMaskValues();

    perm = GetModDialogPermValues( instance );
    eperm = CvtPermModeToString( perm & mask );

    label_xmstring = XmStringCreateLocalized( eperm );
    XtVaSetValues( instance->mod_effPermLabel,
        XmNlabelString, label_xmstring,
        NULL );
    XmStringFree( label_xmstring );
    XtFree( eperm );

    SetModDialogFooter( " " );		/* Clear the footer first */

    /*
     * Give user warning that the effective permission is not being updated
     * due to the mask value.
     */
    r_perm = IS_RPERM( perm );		/* Get read access bit */
    w_perm = IS_WPERM( perm );		/* Get write access bit */
    x_perm = IS_XPERM( perm );		/* Get execute access bit */

    if ( ( widget == (instance->mod_permCbox_items).r_item ) && r_perm )
    {
        if ( !( r_perm & mask ) )
            give_warning = True;
    }
    if ( ( widget == (instance->mod_permCbox_items).w_item ) && w_perm )
    {
        if ( !( w_perm & mask ) )
            give_warning = True;
    }
    if ( ( widget == (instance->mod_permCbox_items).x_item ) && x_perm )
    {
        if ( !( x_perm & 1 & mask ) )
            give_warning = True;
    }
    if ( give_warning )
    {
        XBell( proginfo.display, 0);
        SetModDialogFooter( catgets( Dtb_project_catd, 3, 44,
            "Effective permissions are being restricted by Mask value." ) );
    }

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
ModDialogPostCreateProc_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    DtbSdtfpropModdialogInfo	dtbSource = (DtbSdtfpropModdialogInfo)callData;
    
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    XtVaSetValues( dtbSource->moddialog_shellform,
        XmNdialogStyle, XmDIALOG_PRIMARY_APPLICATION_MODAL,
        XmNdefaultPosition, True,
        NULL );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
ModDialogClassTypeChange_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropModdialogInfo instance = &dtb_sdtfprop_moddialog;

    int class_type = GetModDialogClassType();

    /* Enable the name field for entries that required a name */
    if ( ( class_type & USER ) || ( class_type & GROUP ) )
    {
        /* Enable name field */
        XtSetSensitive( instance->mod_nameLabel, True );
        XtSetSensitive( instance->mod_nameTfield, True );
    }
    else
    {
        /* Disable name field */
        XtSetSensitive( instance->mod_nameLabel, False );
        XtSetSensitive( instance->mod_nameTfield, False );
    }

    /*
     * If we are adding a default entry and the required default ACL enries
     * have not been added then give user warning that those entries will
     * also be added.
     */
    if ( ( class_type & ACL_DEFAULT ) &&
         ( !proginfo.list.has_def_user_obj ||
           !proginfo.list.has_def_group_obj ||
           !proginfo.list.has_def_other_obj ||
           !proginfo.list.has_def_class_obj ) )
    {
        SetModDialogFooter( " " );	/* Clear the footer first */

        XBell( proginfo.display, 0);
        SetModDialogFooter( catgets( Dtb_project_catd, 3, 46,
            "All required default ACL entries will also be added." ) );
    }

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
PropDialogBrowse_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    char	*file_name = NULL;

    _DtTurnOnHourGlass( proginfo.topLevel );

    file_name = GetFileName( NULL, proginfo.directory, NULL, NULL );

    if ( *file_name && ( strlen( file_name ) > 0 ))
        LoadNewFile( file_name );

    /* Free the string that has been returned from GetFileName() */
    XtFree( file_name );

    _DtTurnOffHourGlass( proginfo.topLevel );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
UpdateOwnerEffectPerm_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    mode_t	perm = 0;
    String	eperm;
    XmString	label_xmstring;

    if ( XmToggleButtonGetState( (instance->ownerRead_items).nolabel_item ) )
        perm += 4;
    if ( XmToggleButtonGetState( (instance->ownerWrite_items).nolabel_item ) )
        perm += 2;
    if ( XmToggleButtonGetState( (instance->ownerExecute_items).nolabel_item ) )
        perm += 1;

    eperm = CvtPermModeToString( perm );
    label_xmstring = XmStringCreateLocalized( eperm );
    XtVaSetValues( instance->ownerEffectLabel,
        XmNlabelString, label_xmstring,
        NULL );
    XmStringFree( label_xmstring );
    XtFree( eperm );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
UpdateGroupEffectPerm_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    mode_t	perm = 0;
    String	eperm;
    XmString	label_xmstring;

    if ( XmToggleButtonGetState( (instance->groupRead_items).nolabel_item ) )
        perm += 4;
    if ( XmToggleButtonGetState( (instance->groupWrite_items).nolabel_item ) )
        perm += 2;
    if ( XmToggleButtonGetState( (instance->groupExecute_items).nolabel_item ) )
        perm += 1;

    eperm = CvtPermModeToString( perm /* & GetMaskValues() */ ); /* Bug fix 4006757 */
    label_xmstring = XmStringCreateLocalized( eperm );
    XtVaSetValues( instance->groupEffectLabel,
        XmNlabelString, label_xmstring,
        NULL );
    XmStringFree( label_xmstring );
    XtFree( eperm );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
UpdateOtherEffectPerm_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    mode_t	perm = 0;
    String	eperm;
    XmString	label_xmstring;

    if ( XmToggleButtonGetState( (instance->otherRead_items).nolabel_item ) )
        perm += 4;
    if ( XmToggleButtonGetState( (instance->otherWrite_items).nolabel_item ) )
        perm += 2;
    if ( XmToggleButtonGetState( (instance->otherExecute_items).nolabel_item ) )
        perm += 1;

    eperm = CvtPermModeToString( perm );
    label_xmstring = XmStringCreateLocalized( eperm );
    XtVaSetValues( instance->otherEffectLabel,
        XmNlabelString, label_xmstring,
        NULL );
    XmStringFree( label_xmstring );
    XtFree( eperm );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
ShowInfoPane_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    if ( !XmToggleButtonGetState( widget ) )
        return;

    /* Reset the Category type to the previous item if user has canceled */ 
    if ( !ProcessPermissionPaneExit( True ) ) 
    {
        XmToggleButtonSetState(
            dtb_sdtfprop_propdialog.categoryRbox_items.Permissions_item,
            True, True );
        SetFocus( dtb_sdtfprop_propdialog.categoryRbox_items.Permissions_item );
        return;
    }

    proginfo.current_pane = INFO_PANE;

    /* The Apply button is not applicable for the Information Dialog */
    XtSetSensitive( instance->applyButton, False );

    XtManageChild( instance->infoCpane );
    XtUnmanageChild( instance->permCpane );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}


void 
ShowPermPane_CB(
    Widget widget,
    XtPointer clientData,
    XtPointer callData
)
{
    /*** DTB_USER_CODE_START vvv Add C variables and code below vvv ***/

    DtbSdtfpropPropdialogInfo instance = (DtbSdtfpropPropdialogInfo)clientData;

    if ( !XmToggleButtonGetState( widget ) )
        return;

    proginfo.current_pane = PERM_PANE;

    /* Set Apply button sensitivity accordingly for the Permissions Dialog */
    XtSetSensitive( instance->applyButton, proginfo.is_modifiable );

    XtManageChild( instance->permCpane );
    XtUnmanageChild( instance->infoCpane );

    /*** DTB_USER_CODE_END   ^^^ Add C variables and code above ^^^ ***/
    
    /*** DTB_USER_CODE_START vvv Add C code below vvv ***/
    /*** DTB_USER_CODE_END   ^^^ Add C code above ^^^ ***/
}



/**************************************************************************
 *** DTB_USER_CODE_START
 ***
 *** All automatically-generated data and functions have been defined.
 ***
 *** Add new functions here, or at the top of the file.
 ***/

/*** DTB_USER_CODE_END
 ***
 *** End of user code section
 ***
 **************************************************************************/


