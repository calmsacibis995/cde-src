#ifndef lint
static char sccsid[] = "@(#)pageviewui.c 1.30 97/05/13";
#endif

/*
 * Copyright 1993 Sun Microsystems, Inc.  All rights reserved.
 */

/*
 * pageviewui.c - User interface object initialization functions
 * for page view pop up.
 * This file was generated by `gxv' from `imagetool.G'.
 */

#include <Xm/Xm.h>
#include <Xm/DialogS.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/ManagerP.h>
#include <Xm/MessageB.h>
#include <Xm/PushB.h>
#include <Xm/RowColumn.h>
#include <Xm/ScrolledW.h>
#include <Xm/ToggleBG.h>
#include <Dt/SpinBox.h>

#include "display.h"
#include "help.h"
#include "image.h"
#include "imagetool.h" 
#include "ui_imagetool.h"

static char	last_page [24];
static char	first_page [24];
static Colormap form_colormap;

Pixmap	       *pixmaps = NULL;
int		choices = 0;
int             prev_number = 0;

/*
 * Create object `pages' in the specified instance.
 */
Widget *
PgOverviewPagesCreate (p, number)
     PgOverviewObjects  *p;
     int                 number;
{
     int		i, offset, col;
     XmString           xmstrings[4];
     register int       ac = 0;
     Arg                al[64];
     char               name[32];
     int                slider_size, nbottom, nrows_showing;
     Dimension          button_width, button_height, width1, width2;
     extern void        PgOverviewPageCallback();

     XtUnmanageChild (p->scrolledw);
/*
 * Destroy old buttons, if exists.
 */
     if (p->pix_form)
       XtDestroyWidget (p->pix_form);
/*
 * Create new radio box
 */
     ac = 0;
     XtSetArg(al[ac], XmNspacing, 0); ac++;
     XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
     XtSetArg(al[ac], XmNmarginHeight, 0); ac++;
     p->pix_form = XmCreateForm (p->scrolledw, "PixmapRadio", al, ac);

     choices = number;
     p->buttons = (Widget *) calloc(1, sizeof (Widget) * number);
/*
 * Create the Drawn buttons on the rowcol.
 */
     for (i = 0; i < number; i++) {
       ac = 0;
       XtSetArg (al[ac], XmNlabelPixmap, pixmaps[i]); ac++;
       XtSetArg (al[ac], XmNlabelType, XmPIXMAP); ac++;
       XtSetArg (al[ac], XmNfillOnSelect, True); ac++;
       XtSetArg (al[ac], XmNindicatorOn, False); ac++;
       XtSetArg (al[ac], XmNshadowThickness, 1); ac++;
       XtSetArg (al[ac], XmNspacing, 0); ac++;
       XtSetArg (al[ac], XmNmarginWidth, 0); ac++;
       XtSetArg (al[ac], XmNmarginHeight, 0); ac++;
       XtSetArg (al[ac], XmNnavigationType, XmTAB_GROUP); ac++;

       XtSetArg (al[ac], XmNcolormap, form_colormap); ac++;
       XtSetArg (al[ac], XmNtopOffset, 0); ac++;
       XtSetArg (al[ac], XmNleftOffset, 0); ac++;
       XtSetArg (al[ac], XmNrightOffset, 0); ac++;
       XtSetArg (al[ac], XmNbottomOffset, 0); ac++;
       
       sprintf (name, "Thumbnail%-d", i);
       /*
	* Set Top Attachment 
	*/
       if (i < 4) {
	 XtSetArg (al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
       }
       else {
	 XtSetArg (al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	 XtSetArg (al[ac], XmNtopWidget, p->buttons[i-4]); ac++;
       }
       /*
	* Set Left Attachment
	*/
       if ((i % 4) == 0) {
	 XtSetArg (al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
       }
       else {
	 XtSetArg (al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	 XtSetArg (al[ac], XmNleftWidget, p->buttons[i-1]); ac++;
       }
       /*
	* Set Right Attachment 
	*/
       if ((i % 4) == 3) {
	 XtSetArg (al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
       }
       else {
	 XtSetArg (al[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
       }
       /*
	* Set Bottom Attachment
	*/
       nbottom = (number % 4) == 0 ? 4 : number % 4;
       if ((number - i) <= nbottom) {
	 XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
       }
       else {
	 XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
       }
       /*
	* Create the button
	*/
       p->buttons[i] = XmCreateToggleButtonGadget (p->pix_form, name, al, ac);
       /*
	* Set callback on button.
	*/
       XtAddCallback (p->buttons[i], XmNvalueChangedCallback, 
		      PgOverviewPageCallback, (XtPointer)i);
     }

/*
 * Show 4 rows of buttons at most
 */
     XtVaGetValues (p->buttons[0], XmNheight, &button_height,
		                   XmNwidth, &button_width, NULL);
     button_height++;
     button_width++;
     
     p->nrows = ((number % 4) > 0) ? ((number / 4) + 1) : (number / 4);
     XtVaSetValues (p->pix_form, XmNnumColumns, p->nrows, NULL);

     if (p->nrows > 4)
       nrows_showing = 4;
     else
       nrows_showing = p->nrows;

     /*
      * Shell has never been mapped because extra_height hasn't
      * been calculated yet so just set dimensions on scrolledw.
      */
     /*
      * Always size the scrolledw.
      */
       if (p->nrows <= 4) {
	 /*
	  * No vertical scrollbar needed.
	  */ 
	 XtVaSetValues (p->scrolledw, 
			XmNheight, (Dimension) ((button_height * nrows_showing)
						+ (4 - nrows_showing + 1)),
			XmNwidth, (Dimension) (button_width * 4), 
			NULL);
       }
       else
	 /*
	  * Vertical Scrollbar needed -
	  * add in scrollbar width when setting width.
	  */
	 XtVaSetValues (p->scrolledw, 
			XmNheight, (Dimension) ((button_height * nrows_showing)
						+ 4),
			XmNwidth, (Dimension) ((button_width * 4) + base->sb_width) + 4, 
			NULL);
     /*
      * Shell has been mapped before because extra_height != 0
      * so resize it to new dimensions.
      */
     if (p->extra_height != 0) {
       if (p->nrows <= 4) {
	 Dimension sw_width = (button_width * 4) + p->extra_width;
	 /*
	  * No vertical scrollbar needed.
	  */
	 XtVaSetValues (p->shell, 
			XmNheight, (Dimension) ((button_height * nrows_showing)
					         + (4 - nrows_showing + 1) 
						 + p->extra_height),
			XmNwidth, (sw_width > p->dialog_width) ? sw_width : 
			          p->dialog_width,
			NULL);
       }
       else {
	 Dimension sw_width = ((button_width * 4) + base->sb_width) + 2 +
	                       p->extra_width;
	 /*
	  * Vertical Scrollbar needed -
	  * add in scrollbar width when setting width.
	  */
	 XtVaSetValues (p->shell,
			XmNheight, (Dimension) ((button_height * nrows_showing)
						 + p->extra_height + 4),
			XmNwidth, (sw_width > p->dialog_width) ? sw_width :
			           p->dialog_width,
			NULL);
       }
     }
	 
     XtManageChildren (p->buttons, number);
     XtManageChild (p->pix_form); 
     prev_number = number;
     /*
      * Set the first page button
      */
     XmToggleButtonGadgetSetState (p->buttons[0], True, False);
     XmProcessTraversal (p->buttons[0], XmTRAVERSE_CURRENT);
     XtVaSetValues (p->goto_value, DtNposition, 1,
		                   DtNmaximumValue, number, 
		    NULL);

/*
 * Set value of first page.
 */
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 135,
						      "Page 1"));
     XtVaSetValues (p->start_page_label, XmNlabelString, xmstrings[0], NULL);
     XmStringFree (xmstrings[0]);
/*
 * Set value of end page item...
 */
     sprintf (last_page, catgets (prog->catd, 1, 136, "Page %d"), 
	                 number > 16 ? 16 : number);
     xmstrings[0] = XmStringCreateLocalized (last_page);
     XtVaSetValues (p->end_page_label, XmNlabelString, xmstrings[0],
		                       XmNrightOffset, 0, NULL);
     XmStringFree (xmstrings[0]);
/*
 * Set offset of end_page_label to correct column
 * Right justify label in case text width is
 * larger than width of last button.
 * Don't forget to take the scrollbar width into account if number > 16.
 */
     if (number > 16)
       offset = base->sb_width;
     else {
       col = number % 4;
       if (col == 0)
	 col = 4;
       offset = (4 - col) * button_width;
     }

     XtVaGetValues (p->scrolledw, XmNwidth, &width1, NULL);
     XtVaGetValues (p->end_page_label, XmNwidth, &width2, NULL);
       
     if ((int) (width2 + offset) > (int) width1)
       offset = (int) (width1 - width2);
     XtVaSetValues (p->end_page_label, XmNrightOffset, offset, NULL);
     XtManageChild (p->scrolledw);

     return p->buttons;
}

/*
 * Initialize an instance of object `pageview'.
 */
PgOverviewObjects *
PgOverviewObjectsInitialize (parent, npages)
     Widget   parent;
     int      npages;
{
     PgOverviewObjects  *p;
     Widget              children[11];      /* Children to manage */
     Arg                 al[64];            /* Arg List */
     register int        ac = 0;            /* Arg Count */
     XmString            xmstrings[4];
     Dimension           height1, height2;
     GC                  select_gc;
     XGCValues           gc_vals;
     extern void         PopupEventHandler();
     extern void         DisplayPageCallback();
     extern void         GoToValueCallback();
     extern void         PgOverviewCancelCallback();
     extern void         PgOverviewSBCallback();
     extern void         PgOverviewTraverseObscuredCB();
     
     p = (PgOverviewObjects *) calloc (1, sizeof (PgOverviewObjects));
     p->width = (int) (ps_display->pagewidth * 6.0);
     p->height = (int) (ps_display->pageheight * 6.0);
/*
 * Create Dialog Shell, Message Box, Form.
 */
     ac = 0;
     XtSetArg(al[ac], XmNtitle, catgets (prog->catd, 1, 137, 
					 "Image Viewer - Page Overview")); ac++;
     p->shell = XmCreateDialogShell ( parent, "OverviewShell", al, ac );
/*
 * Create Message Dialog Box
 */
     ac = 0;
     XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
     XtSetArg(al[ac], XmNdialogType, XmDIALOG_TEMPLATE); ac++;	 
     XtSetArg(al[ac], XmNnoResize, TRUE); ac++; 
     p->dialog = XmCreateMessageBox (p->shell, "OverviewDialog", al, ac );
/*
 * Add event handler to catch Maps/Unmaps.
 */
     XtAddEventHandler (p->shell, StructureNotifyMask, False,
			PopupEventHandler, p->dialog);
/*
 * Create Form
 */
     ac = 0;
     XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
     XtSetArg(al[ac], XmNnoResize, FALSE); ac++;
     p->form = XmCreateForm ( p->dialog, "OverviewForm", al, ac );
     XtVaGetValues (p->form, XmNcolormap, &form_colormap, NULL);
/*
 * Create Start Page Label.
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 138,
						      "Page 1"));
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], XmNleftOffset, 0); ac++;
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->start_page_label = XmCreateLabel (p->form, "StartPageLabel", al, ac );
     XmStringFree (xmstrings[0]);

/*
 * Create Scrolled Window
 */
     ac = 0;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNtopWidget, p->start_page_label); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], XmNscrollingPolicy, XmAUTOMATIC); ac++;
     p->scrolledw = XmCreateScrolledWindow (p->form, "OverviewScrolledW", 
					    al, ac );
     ac = 0;
     XtSetArg(al[ac], XmNhorizontalScrollBar, &p->hscroll ); ac++;
     XtSetArg(al[ac], XmNverticalScrollBar, &p->vscroll ); ac++;
     XtGetValues(p->scrolledw, al, ac );
     XtUnmanageChild(p->hscroll);
/*
 * Create new radio box
 */
     ac = 0;
     XtSetArg(al[ac], XmNspacing, 0); ac++;
     XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
     XtSetArg(al[ac], XmNmarginHeight, 0); ac++;
     p->pix_form = XmCreateForm (p->scrolledw, "PixmapRadio", al, ac);
/*
 * Create End Page Label.
 */
     ac = 0;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNtopWidget, p->scrolledw); ac++;
     XtSetArg(al[ac], XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET); ac++;
     XtSetArg(al[ac], XmNrightWidget, p->scrolledw); ac++;
     XtSetArg(al[ac], XmNrightOffset, 0); ac++;
     p->end_page_label = XmCreateLabel (p->form, "EndPageLabel", al, ac );
/* 
 * Create Label for Go To Spin Box.
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 139,
						      "Go To Page:"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNtopWidget, p->end_page_label); ac++;
     XtSetArg(al[ac], XmNtopOffset, 10); ac++;
     XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
     p->goto_label = XmCreateLabel (p->form, "GoToLabel", al, ac );
     XmStringFree (xmstrings[0]);
/*
 * Create Go To Spin Box
 */
     ac = 0;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNleftWidget, p->goto_label); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNtopWidget, p->end_page_label); ac++;
     XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
     XtSetArg(al[ac], DtNspinBoxChildType, DtNUMERIC); ac++;
     XtSetArg(al[ac], DtNmaximumValue, 999); ac++;
     XtSetArg(al[ac], DtNminimumValue, 1); ac++;
     XtSetArg(al[ac], DtNposition, 1); ac++;
     XtSetArg(al[ac], XmNcolumns, 4); ac++;
     XtSetArg(al[ac], XmNshadowThickness, 0); ac++;
     XtSetArg(al[ac], XmNtopOffset, 10); ac++;
     p->goto_value = DtCreateSpinBox (p->form, "GoToSpinBox", al, ac);
     XtVaGetValues (p->goto_value, XmNheight, &height1, 
		                   DtNtextField, &p->goto_text, NULL);
     XmImUnregister (p->goto_text);
     XtVaGetValues (p->end_page_label, XmNheight, &height2, NULL);
		    
     XtVaSetValues (p->scrolledw, XmNbottomOffset, (height1 + height2 + 10), NULL);
/*
 * Create Display Page Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 140, 
						      "Display Page"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->display_button = XmCreatePushButton (p->dialog, 
					     "OverviewDisplayButton", al, ac);
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create page buttons
 */
     p->buttons = PgOverviewPagesCreate (p, npages);
/*
 * Create Close Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 141, 
						      "Close"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->cancel_button = XmCreatePushButton (p->dialog, "OverviewCloseButton", 
					    al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create Help Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 142, 
						      "Help"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->help_button = XmCreatePushButton (p->dialog, "OverviewHelpButton", 
					  al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Set Revert button to be the default button
 * and minimize the button widths.
 */
     XtVaSetValues (p->dialog, XmNdefaultButton, p->display_button,
		               XmNminimizeButtons, True, NULL);

     p->showing = False;

/*
 * Set callback for traversal to obscured page.
 */
     XtAddCallback(p->scrolledw, XmNtraverseObscuredCallback,
                   PgOverviewTraverseObscuredCB, NULL);
/*
 * Set help callback on dialog
 */
     XtAddCallback (p->dialog, XmNhelpCallback, HelpItemCallback, 
		    HELP_OVERVIEW_ITEM);
     XtAddCallback (p->help_button, XmNactivateCallback, HelpItemCallback, 
		    HELP_OVERVIEW_ITEM);
/*
 * Set callbacks on buttons
 */
     XtAddCallback (p->goto_text, XmNmodifyVerifyCallback, 
		    GoToValueCallback, p);
     XtAddCallback (p->goto_text, XmNactivateCallback, 
		    GoToValueCallback, p);
     XtAddCallback (p->display_button, XmNactivateCallback, 
		    DisplayPageCallback, p);
     XtAddCallback (p->cancel_button, XmNactivateCallback, 
		    PgOverviewCancelCallback, p);
     XtAddCallback (p->vscroll, XmNvalueChangedCallback, PgOverviewSBCallback,
		    p);
     XtAddCallback (p->vscroll, XmNdragCallback, PgOverviewSBCallback, p);
     XtAddCallback (p->vscroll, XmNpageIncrementCallback, PgOverviewSBCallback, p);
     XtAddCallback (p->vscroll, XmNpageDecrementCallback, PgOverviewSBCallback, p);
     XtAddCallback (p->vscroll, XmNincrementCallback, PgOverviewSBCallback, p);
     XtAddCallback (p->vscroll, XmNdecrementCallback, PgOverviewSBCallback, p);
     
/*
 * Manage the widgets 
 */
     ac = 0;
     XmScrolledWindowSetAreas (p->scrolledw, p->hscroll, p->vscroll, p->pix_form);
     children[ac++] = p->start_page_label;
     children[ac++] = p->scrolledw;
     children[ac++] = p->end_page_label;
     children[ac++] = p->goto_label;
     children[ac++] = p->goto_value;
     XtManageChildren(children, ac);
     ac = 0;
     children[ac++] = p->form;
     children[ac++] = p->display_button;
     children[ac++] = p->cancel_button;
     children[ac++] = p->help_button;
     XtManageChildren(children, ac);
     
     return p;
}

void
PgOverviewSBCallback (w, client_data, cbs)
     Widget                      w;
     XtPointer                   client_data;
     XmScrollBarCallbackStruct  *cbs;
{
     PgOverviewObjects *p = (PgOverviewObjects *)client_data;
     int                start_row, end_row, inc, end, col, offset;
     XmString           xmstring;
     Dimension          button_width, button_height, width1, width2;

     if (cbs == NULL || p->thumbnails_created == False)
       return;
/*
 * Calculate start and end rows currently showing.
 */
     XtVaGetValues (pg_overview->vscroll, XmNincrement, &inc, NULL);
/*
 * This is a kludge because for some reason, inc is 86 instead of 72
 * where it is initially set in PgOverviewCallback.
 */
     XtVaGetValues (pg_overview->buttons[0], XmNheight, &button_height, NULL);
     if (inc != button_height) {
       XmScrollBarSetValues (pg_overview->vscroll, 0, (int) (button_height * 4),
			     (int) button_height, (int) (button_height * 3), False);
       XtVaGetValues (pg_overview->vscroll, XmNincrement, &inc, NULL);
     }

     /* 
      * (DKenny - 13 May, 1997)
      *
      * Adjust the slider values to be exact multiples of Row and inc.
      * Do this because a call to XmScrollVisible will not be perfect in it
      * assessment of making page visible.
      *
      */
     if ( cbs->reason != XmCR_DRAG && cbs->value % inc != 0 ) {
        int s_size, min, max;
        int NewValue;
        int Value, increment, page_incr;

        int Row  =(cbs->value / inc);
        int Extra=cbs->value % inc;

        /* Get values so we can use them in XmScrollBarSetValues below */
        XmScrollBarGetValues (pg_overview->vscroll, &Value, &s_size, 
                              &increment, &page_incr);

        XtVaGetValues (pg_overview->vscroll, XmNminimum, &min, NULL);
        XtVaGetValues (pg_overview->vscroll, XmNmaximum, &max, NULL);

        if ( Extra > inc/2 )
            Row++;

        if ( Row == 0 && Extra < inc ) 
            NewValue=min;
        else
            NewValue=(Row * inc > max-s_size)?(max-s_size):(Row * inc);
           
        /*
         * Set new sb values, and return to pick up notify by
         * XmScrollBarSetValues
         */
        XmScrollBarSetValues (pg_overview->vscroll, NewValue, s_size,
                              increment, page_incr, True);
        return;
     }

     start_row = (cbs->value / inc) + 1;
     if (cbs->value % inc > 0) {
       end_row = start_row + 3;
       if (end_row > p->nrows)
	 end_row = p->nrows;
     }
     else
       end_row = start_row + 3;

/*
 * Set Start Page Label.
 */
     sprintf (first_page, catgets (prog->catd, 1, 143, "Page %d"),
	      ((start_row - 1) * 4) + 1);
     xmstring = XmStringCreateLocalized (first_page);
     XtVaSetValues (p->start_page_label, XmNlabelString, xmstring, NULL);
     XmStringFree (xmstring);
/*
 * Set End Page Label string to far right for now so we
 * can get the width below.
 */
     end = (end_row * 4);
     if (end > choices)
       end = choices;
     sprintf (last_page, catgets (prog->catd, 1, 144, "Page %d"), end);
     xmstring = XmStringCreateLocalized (last_page);
     XtVaSetValues (p->end_page_label, XmNlabelString, xmstring, 
		                       XmNrightOffset, 0, NULL);
     XmStringFree (xmstring);
/*
 * Set offset of end_page_label to correct column
 * If last row on bottom, figure out column 
 * otherwise, use last column 4.
 * Right justify label in case text width is
 * larger than width of last button.
 */
     if (p->nrows == end_row) {
       col = choices % 4;
       if (col == 0)
	 col = 4;
     }
     else 
       col = 4;

     XtVaGetValues (p->buttons[0], XmNwidth, &button_width, NULL);
     button_width++;

     
     offset = (4 - col) * button_width;
     if (choices > 16)
       offset = offset + base->sb_width;

     XtVaGetValues (p->scrolledw, XmNwidth, &width1, NULL);
     XtVaGetValues (p->end_page_label, XmNwidth, &width2, NULL);
       
     if ((int) (width2 + offset) > (int) width1)
       offset = (int) (width1 - width2);
     XtVaSetValues (p->end_page_label, XmNrightOffset, offset, NULL);

}

void 
ReversePgOverviewPages (p, number, reverse)
     PgOverviewObjects *p;
     int                number;
     int                reverse;
{
     char               name[40];
     int                i, nbottom;
     register int       ac = 0;
     
     Arg                al[64];
     extern void        PgOverviewPageCallback();

     if (XtIsRealized (p->scrolledw))
       XtUnmapWidget (p->scrolledw);
/*
 * Set the pixmaps in reverse order on the toggle buttons
 */
     if (reverse == TRUE) {
       for (i = 0; i < number; i++) {
   	 XtVaSetValues (p->buttons[i], 
		        XmNlabelPixmap, pixmaps[number - i - 1], NULL);
	 /*
	  * Set callback on button.
	  */
	 XtAddCallback (p->buttons[i], XmNvalueChangedCallback, 
			PgOverviewPageCallback, (XtPointer)i);
       }
     }
/* 
 * Set the pixmaps in order on the toggle buttons 
 */
     else {
       for (i = 0; i < number; i++) {
	 XtVaSetValues (p->buttons[i], XmNlabelPixmap, pixmaps[i], NULL);
	 /*
	  * Set callback on button.
	  */
	 XtAddCallback (p->buttons[i], XmNvalueChangedCallback, 
			PgOverviewPageCallback, (XtPointer)i);
       }
     }
#ifdef NEVER
     XtUnmanageChild (p->scrolledw);
/*
 * Destroy current buttons.
 */
     if (p->pix_form)
       XtDestroyWidget (p->pix_form);
/*
 * Create new radio box
 */
     ac = 0;
     XtSetArg(al[ac], XmNspacing, 0); ac++;
     XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
     XtSetArg(al[ac], XmNmarginHeight, 0); ac++;
     p->pix_form = XmCreateForm (p->scrolledw, "PixmapRadio", al, ac);

     if (reverse == TRUE) {
       for (i = 0; i < number; i++) {
	 ac = 0;
	 XtSetArg (al[ac], XmNlabelPixmap, pixmaps[number - i - 1]); ac++;
	 XtSetArg (al[ac], XmNlabelType, XmPIXMAP); ac++;
         XtSetArg (al[ac], XmNfillOnSelect, True); ac++;
         XtSetArg (al[ac], XmNindicatorOn, False); ac++;
         XtSetArg (al[ac], XmNshadowThickness, 1); ac++;
         XtSetArg (al[ac], XmNspacing, 0); ac++;
         XtSetArg (al[ac], XmNmarginWidth, 0); ac++;
         XtSetArg (al[ac], XmNmarginHeight, 0); ac++;
         XtSetArg (al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
#ifdef NEVER
	 XtSetArg (al[ac], XmNshadowType, XmSHADOW_ETCHED_OUT); ac++;
	 XtSetArg (al[ac], XmNshadowThickness, 2); ac++; 
#endif
	 XtSetArg (al[ac], XmNcolormap, form_colormap); ac++;	
	 XtSetArg (al[ac], XmNtopOffset, 0); ac++;
	 XtSetArg (al[ac], XmNleftOffset, 0); ac++;
	 XtSetArg (al[ac], XmNrightOffset, 0); ac++;
	 XtSetArg (al[ac], XmNbottomOffset, 0); ac++;
	 sprintf (name, "Thumbnail%-d", i);

	 /*
	  * Set Top Attachment 
	  */
	 if (i < 4) {
	   XtSetArg (al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	   XtSetArg (al[ac], XmNtopWidget, p->buttons[i-4]); ac++;
	 }
	 /*
	  * Set Left Attachment
	  */
	 if ((i % 4) == 0) {
	   XtSetArg (al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	   XtSetArg (al[ac], XmNleftWidget, p->buttons[i-1]); ac++;
	 }
	 /*
	  * Set Right Attachment 
	  */
	 if ((i % 4) == 3) {
	   XtSetArg (al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
	 }
	 /*
	  * Set Bottom Attachment
	  */
	 nbottom = (number % 4) == 0 ? 4 : number % 4;
	 if ((number - i) <= nbottom) {
	   XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
	 }
	 /*
	  * Create the button
	  */
	 p->buttons[i] = XmCreateToggleButtonGadget (p->pix_form, name, al, ac);
	 /*
	  * Set callback on button.
	  */
	 XtAddCallback (p->buttons[i], XmNvalueChangedCallback, 
			PgOverviewPageCallback, i);
       }
     }
     else {
       for (i = 0; i < number; i++) {
	 ac = 0;
	 XtSetArg (al[ac], XmNlabelPixmap, pixmaps[i]); ac++;
	 XtSetArg (al[ac], XmNlabelType, XmPIXMAP); ac++;
         XtSetArg (al[ac], XmNfillOnSelect, True); ac++;
         XtSetArg (al[ac], XmNindicatorOn, False); ac++;
         XtSetArg (al[ac], XmNshadowThickness, 1); ac++;
         XtSetArg (al[ac], XmNspacing, 0); ac++;
         XtSetArg (al[ac], XmNmarginWidth, 0); ac++;
         XtSetArg (al[ac], XmNmarginHeight, 0); ac++;
         XtSetArg (al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
#ifdef NEVER
	 XtSetArg (al[ac], XmNshadowType, XmSHADOW_ETCHED_OUT); ac++;	
	 XtSetArg (al[ac], XmNshadowThickness, 2); ac++; 
#endif
	 XtSetArg (al[ac], XmNcolormap, form_colormap); ac++;
	 XtSetArg (al[ac], XmNtopOffset, 0); ac++;
	 XtSetArg (al[ac], XmNleftOffset, 0); ac++;
	 XtSetArg (al[ac], XmNrightOffset, 0); ac++;
	 XtSetArg (al[ac], XmNbottomOffset, 0); ac++;
	 sprintf (name, "Thumbnail%-d", i);

	 /*
	  * Set Top Attachment 
	  */
	 if (i < 4) {
	   XtSetArg (al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNtopAttachment, XmATTACH_WIDGET); ac++;
	   XtSetArg (al[ac], XmNtopWidget, p->buttons[i-4]); ac++;
	 }
	 /*
	  * Set Left Attachment
	  */
	 if ((i % 4) == 0) {
	   XtSetArg (al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
	   XtSetArg (al[ac], XmNleftWidget, p->buttons[i-1]); ac++;
	 }
	 /*
	  * Set Right Attachment 
	  */
	 if ((i % 4) == 3) {
	   XtSetArg (al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNrightAttachment, XmATTACH_NONE); ac++;
	 }
	 /*
	  * Set Bottom Attachment
	  */
	 nbottom = (number % 4) == 0 ? 4 : number % 4;
	 if ((number - i) <= nbottom) {
	   XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
	 }
	 else {
	   XtSetArg (al[ac], XmNbottomAttachment, XmATTACH_NONE); ac++;
	 }
	 /*
	  * Create the button
	  */
	 p->buttons[i] = XmCreateToggleButtonGadget (p->pix_form, name, al, ac);
	 /*
	  * Set callback on button.
	  */
	 XtAddCallback (p->buttons[i], XmNvalueChangedCallback, 
			PgOverviewPageCallback, i);
       }
     }
     XtManageChildren (p->buttons, number);
     XtManageChild (p->pix_form); 
     XtManageChild (p->scrolledw);
#endif
     if (XtIsRealized (p->scrolledw))
       XtMapWidget (p->scrolledw);
     XSync (XtDisplay (base->top_level), 0);

}

/*
 * Create pixmaps (server images) for pop up.
 */ 

void
pageview_pixmaps_create (number)
     int        number;
{
     int	i, depth;
     Pixmap    *new_pixmaps;
     extern GC  small_gc;

     if (number > choices) {
       new_pixmaps = (unsigned long *) malloc (number *
					       sizeof (unsigned long));
       
       XtVaGetValues (base->top_level, XmNdepth, &depth, NULL);

       for (i = 0; i < number; i++) {
	 new_pixmaps [i] = XCreatePixmap (XtDisplay (base->top_level),
			     DefaultRootWindow (XtDisplay (base->top_level)),
					  51, 66, depth);
       }
	
       /*
	* Restore previous pixmaps.
	*/
       create_small_gc ();
       for (i = 0; i < choices; i++) {
	 if (ps_display->depth == 1 && pixmaps != NULL)
	   XCopyPlane (ps_display->xdisplay, pixmaps[i], new_pixmaps [i], 
		       small_gc, 0, 0, (int) (ps_display->pagewidth * 6.0),
		       (int) (ps_display->pageheight * 6.0), 0, 0, 1L);
	 else if (pixmaps != NULL) {
	   XCopyArea (ps_display->xdisplay, pixmaps[i], new_pixmaps [i],
		      small_gc, 0, 0, (int) (ps_display->pagewidth * 6.0),
		      (int) (ps_display->pageheight * 6.0), 0, 0);
	 }
       }

       /*
	* Destroy old pixmap pointer and it's pixmaps.
	*/
       if (pixmaps != NULL) {
	 for (i = 0; i < choices; i++) 
	   XFreePixmap (XtDisplay (base->top_level), pixmaps[i]);
         free (pixmaps);
       }
       pixmaps = new_pixmaps;
				  
       choices = number;
     }

}

void
PgOverviewCancelCallback (w, client_data, call_data)
     Widget     w;
     XtPointer  client_data;
     XtPointer  call_data;
{
     PgOverviewObjects *p = (PgOverviewObjects *)client_data;

     XtPopdown (XtParent (p->dialog));
}

void
PgOverviewPageCallback (w, client_data, cbs)
     Widget                       w;
     XtPointer                    client_data;
     XmToggleButtonCallbackStruct *cbs;
{
     int          button_no = (int) client_data;
     int          i;
     static       XEvent last_event;
     Boolean      set;
     extern void  DisplayPageCallback();

     /*
      * Check if new thumnails have been created yet.
      */
     if (cbs == NULL || pg_overview->thumbnails_created == False)
       return;
     
/*
 * Always have one selected.
 */
     XtVaGetValues (w, XmNset, &set, NULL);
     if (set == False)
       XmToggleButtonGadgetSetState (w, True, False);
     /*
      * Unset all buttons.
      */
     for (i = 0; i < current_image->pages; i++)
       XmToggleButtonGadgetSetState (pg_overview->buttons[i], False, False);

     XmToggleButtonGadgetSetState (pg_overview->buttons[button_no], True, False);
     /*
      * Update GoTo spin box value.
      */
     XtVaSetValues (pg_overview->goto_value, 
		    DtNposition, (int) (button_no + 1), NULL);
     /*
      * Check if double_click event.
      */
     if (cbs->event && cbs->event->type == ButtonRelease) {
       /* 
	* Force ButtonPress event for ds_is_double_click()
	*/
       cbs->event->type = ButtonPress;  
       if (ds_is_double_click (&last_event, cbs->event)) 
	 DisplayPageCallback (NULL, NULL, NULL);
       last_event = *cbs->event;
     }
}

/*
 * Callback which is called whenever a widget in the scroll_window is 
 * traversed to that is obscured - even partially by the scroll_window's 
 * viewing area.
 */
void
PgOverviewTraverseObscuredCB (w, client_data, cbs)
     Widget                             w;
     XtPointer                          client_data;
     XmTraverseObscuredCallbackStruct  *cbs;
{
    int NewValue;
    XmScrollVisible(w, cbs->traversal_destination,2,2);
    XtVaGetValues (pg_overview->vscroll, XmNvalue, &NewValue, NULL);
    XtVaSetValues (pg_overview->vscroll, XmNvalue, NewValue, NULL);
}
