/*
 * File: snap_dlog_ui.c
 * Contains: user module object initialize and create functions
 *
 * This file was generated by dtcodegen, from module snap_dlog
 *
 *    ** DO NOT MODIFY BY HAND - ALL MODIFICATIONS WILL BE LOST **
 */


#include <stdlib.h>
#include <sys/param.h>
#include <Xm/DialogS.h>
#include <Xm/Form.h>
#include <Xm/TextF.h>
#include <Xm/Separator.h>
#include <Xm/ToggleB.h>
#include <Xm/Label.h>
#include <Dt/ComboBox.h>
#include <Xm/PushB.h>
#include <Xm/Protocols.h>

#include "snap_dialog.h"

#include "display.h"
#include "image.h"
#include "imagetool.h"
#include "state.h"
#include "misc.h"
#include "help.h"
#include "ui_imagetool.h"
#include "multivis.h"

#include "sdtimage_snap.h"


#ifdef HAVE_EDITRES
#include <X11/Xmu/Editres.h>
#endif

typedef struct {
    Boolean open_d;
    Boolean openas_d;
    Boolean save_d;
    Boolean saveas_d;
    Boolean palette_d;
    Boolean info_d;
    Boolean pg_overview_d;
    Boolean pg_controls_d;
    Boolean properties_d;
    Boolean print_d;
    Boolean print_prev_d;
    Boolean about_d;
} DialogShowingStatusObjects;

static DialogShowingStatusObjects dialog_showing_status = {
    False, False, False, False, False, False,
    False, False, False, False, False, False };

int delay_values[]  = {0, 2, 4, 8, 16, 20, 24};
int delay_indices[] = {14, 15, 16, 17, 18, 19, 20};


static int motion_x1;
static int motion_y1;
static Boolean beep_during = False;
static Boolean hide_window = False;
static Boolean button_pressed = False;
static Boolean button_released = False;
static Position pressX;
static Position pressY;
static Position releaseX;
static Position releaseY;
static Position motionX;
static Position motionY;
static Position	inputX;
static Position	inputY;
static Dimension inputWidth;
static Dimension inputHeight;
static Dimension motion_width;
static Dimension motion_height;
static Window rootWindow;
static GC gc;

XImage * GenerateXimage(ImageInfo *image, unsigned char* data);
int CreateImageFromScreen(ImageInfo *image);

XtTranslations trans_table;

DtbSnapDlogDialogInfoRec	dtb_snap_dlog_dialog =
{
    False,	 /* created */
    False        /* snap_needs_save */
};

int
dtbSnapDlogDialogInfo_clear(DtbSnapDlogDialogInfo snapDialogInfo)
{
    memset((void *)(snapDialogInfo), 0, sizeof(*snapDialogInfo));
    return 0;
}

int DtbCreateSnapDialog(DtbSnapDlogDialogInfo snapDialogInfo, Widget parent)
{
  int i, n = 0;
  int num_children;
  char buf[5];
  Dimension width, max_width;
  Arg args[8];
  Widget label, radio, seperator;
  Widget st_form, sd_form, hb_form, dc_form;
  Widget ok_button, cancel_button, help_button;
  Widget textfield;
  WidgetList children;
  String title = NULL;
  XmString xmstr1, xmstr2, xmstr3;
  XmString delays[NUM_DELAYS];

  if (snapDialogInfo->created && snapDialogInfo->dialog != NULL)
    {
      XtManageChild(snapDialogInfo->dialog);
      XtManageChild(snapDialogInfo->MainForm);
      return 0;
    }

  /* ------------------------------------------------------- */
  /*  Create the Dialog Shell of XmDialogShell Widget Class  */
  /* ------------------------------------------------------- */

  title = XtNewString(catgets(Dtb_project_catd, 2, 28,
                              "Image Viewer - Snapshot"));
  n = 0;
  XtSetArg(args[n], XmNallowShellResize, True); n++;
  XtSetArg(args[n], XmNmappedWhenManaged, False); n++;
  XtSetArg(args[n], XmNtitle, title); n++;

  snapDialogInfo->dialog = XmCreateDialogShell(parent, "SnapDialogShell", args, n);

  XtFree(title);

  if (snapDialogInfo->dialog == NULL)
    return -1;

  XtAddEventHandler(snapDialogInfo->dialog,
                    StructureNotifyMask,
                    False,
                    (XtEventHandler) SdtFixShellSize,
                    (XtPointer) NULL );

  /* ---------------------------------------------------- */
  /*  Allow for Editres to get its widget tree hierarchy  */
  /* ---------------------------------------------------- */

#ifdef HAVE_EDITRES
  XtAddEventHandler(snapDialogInfo->dialog,
                    0,
                    True,
                    (XtEventHandler) _XEditResCheckMessages,
                    (XtPointer) NULL);
#endif


  /* -------------------------------------------------------- */
  /*  Create the outer container form of XmForm Widget Class  */
  /* -------------------------------------------------------- */

  n = 0;
  XtSetArg(args[n], XmNresizePolicy, XmRESIZE_GROW); n++;
  XtSetArg(args[n], XmNspacing, 5); n++;
  XtSetArg(args[n], XmNmarginWidth, 5); n++;
  XtSetArg(args[n], XmNmarginHeight, 5); n++;

  snapDialogInfo->MainForm = XtCreateWidget("MainForm", xmFormWidgetClass,
                                            snapDialogInfo->dialog, args, n);

  XtAddCallback(snapDialogInfo->MainForm, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAPSHOT);


  /* -------------------------------------------- */
  /*  Create the Snap Type Container form widget  */
  /* -------------------------------------------- */

  st_form = XtVaCreateWidget("SnapTypeForm", xmFormWidgetClass,
                             snapDialogInfo->MainForm,
                             XmNmarginWidth,     5,
                             XmNmarginHeight,    5,
                             XmNleftAttachment,  XmATTACH_FORM,
                             XmNtopAttachment,   XmATTACH_FORM,
                             XmNrightAttachment, XmATTACH_FORM,
                             NULL);


  /* ---------------------------------------------- */
  /*  Create the snap type LABEL and radio buttons  */
  /* ---------------------------------------------- */

  xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 7, "Snap Type:"));

  label = XtVaCreateWidget("SnapTypeLabel", xmLabelWidgetClass, st_form,
                           XmNrecomputeSize,    True,
                           XmNlabelString,      xmstr1,
                           XmNleftAttachment,   XmATTACH_FORM,
                           XmNleftOffset,       10,
                           XmNtopAttachment,    XmATTACH_FORM,
                           XmNbottomAttachment, XmATTACH_FORM,
                           XmNalignment,        XmALIGNMENT_BEGINNING,
                           NULL);

  XmStringFree(xmstr1);
  XtManageChild(label);

  xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 9,  "Window"));
  xmstr2 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 10, "Region"));
  xmstr3 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 11, "Screen"));

  snapDialogInfo->SnapTypeRadio =
  XmVaCreateSimpleRadioBox(st_form, "SnapTypeRadioBox",
                           0,                  /* initial choice */
                           (XtCallbackProc)SnapTypeToggledCB,
                           XmVaRADIOBUTTON,     xmstr1, NULL, NULL, NULL,
                           XmVaRADIOBUTTON,     xmstr2, NULL, NULL, NULL,
                           XmVaRADIOBUTTON,     xmstr3, NULL, NULL, NULL,
                           XmNorientation,      XmHORIZONTAL,
                           XmNleftAttachment,   XmATTACH_WIDGET,
                           XmNleftWidget,       label,
                           XmNleftOffset,       10,
                           XmNtopAttachment,    XmATTACH_FORM,
                           XmNrightAttachment,  XmATTACH_FORM,
                           XmNbottomAttachment, XmATTACH_FORM,
                           NULL);

  XmStringFree(xmstr1);
  XmStringFree(xmstr2);
  XmStringFree(xmstr3);

  XtAddCallback(snapDialogInfo->SnapTypeRadio, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAPSHOT);

  /* --------------------------------------------------- */
  /*  Add HelpCallback for each individual radio button  */
  /* --------------------------------------------------- */

  n = 0;
  XtSetArg(args[n], XmNnumChildren, &num_children); n++;
  XtSetArg(args[n], XmNchildren, &children); n++;
  XtGetValues(snapDialogInfo->SnapTypeRadio, args, n);

  if (num_children > 0  && children != NULL)
    {
      if (children[0] != NULL)
        {
          XtAddCallback(children[0], XmNhelpCallback,
                        HelpItemCallback, (XtPointer) HELP_SNAP_WINDOW);

          n = 0;
          XtSetArg(args[n], XmNuserData, (XtPointer) snapDialogInfo); n++;
          XtSetValues(children[0], args, n);
        }

      if (children[1] != NULL)
        {
          XtAddCallback(children[1], XmNhelpCallback,
                        HelpItemCallback, (XtPointer) HELP_SNAP_REGION);
          n = 0;
          XtSetArg(args[n], XmNuserData, (XtPointer) snapDialogInfo); n++;
          XtSetValues(children[1], args, n);
        }

      if (children[2] != NULL)
        {
          XtAddCallback(children[2], XmNhelpCallback,
                        HelpItemCallback, (XtPointer) HELP_SNAP_SCREEN);
          n = 0;
          XtSetArg(args[n], XmNuserData, (XtPointer) snapDialogInfo); n++;
          XtSetValues(children[2], args, n);
        }
    }

  XtManageChild(snapDialogInfo->SnapTypeRadio);
  XtManageChild(st_form);


  /* ----------------------------------------------- */
  /*  Create the snap delay LABEL and optionsbutton  */
  /* ----------------------------------------------- */

  sd_form = XtVaCreateWidget("SnapDelayForm", xmFormWidgetClass,
                             snapDialogInfo->MainForm,
                             XmNmarginWidth,     5,
                             XmNmarginHeight,    5,
                             XmNleftAttachment,  XmATTACH_FORM,
                             XmNtopAttachment,   XmATTACH_WIDGET,
                             XmNtopWidget,       st_form,
                             XmNrightAttachment, XmATTACH_FORM,
                             NULL);

  xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 13, "Snap Delay:"));

  label = XtVaCreateWidget("SnapDelayLabel", xmLabelWidgetClass, sd_form,
                           XmNlabelString,      xmstr1,
                           XmNleftAttachment,   XmATTACH_FORM,
                           XmNleftOffset,       10,
                           XmNtopAttachment,    XmATTACH_FORM,
                           XmNbottomAttachment, XmATTACH_FORM,
                           XmNalignment,        XmALIGNMENT_BEGINNING,
                           NULL);

  XmStringFree(xmstr1);
  XtManageChild(label);

  snapDialogInfo->SnapDelay =
  XtVaCreateWidget("SnapDelayOptions",
                   dtComboBoxWidgetClass, sd_form,
                   DtNcomboBoxType,     DtDROP_DOWN_COMBO_BOX,
                   XmNleftAttachment,   XmATTACH_WIDGET,
                   XmNuserData,         (XtPointer) snapDialogInfo,
                   XmNcolumns,          3,
                   XmNmaxLength,        3,
                   XmNleftWidget,       label,
                   XmNleftOffset,       10,
                   XmNtopAttachment,    XmATTACH_FORM,
                   XmNbottomAttachment, XmATTACH_FORM,
                   NULL);

  for ( i = 0 ; i < NUM_DELAYS ; i++ )
    {
      sprintf(buf, "%d", delay_values[i]);
      xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2,
                                               delay_indices[i], buf));

      DtComboBoxAddItem(snapDialogInfo->SnapDelay, xmstr1, i+1, True);
      XmStringFree(xmstr1);
    }

  XtAddCallback(snapDialogInfo->SnapDelay, DtNselectionCallback,
                SnapDelayValueChangedCB, (XtPointer) snapDialogInfo);

  XtAddCallback(snapDialogInfo->SnapDelay, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAP_DELAY);

  /* ------------------------------------------------------------------ */
  /*  Allow only for 3 digit number of seconds, otherwise its too long  */
  /* ------------------------------------------------------------------ */

  XtVaGetValues(snapDialogInfo->SnapDelay, DtNtextField, &textfield, NULL);

  /*
   * Add ModifyVerify callback to make sure that all value entered in
   * the combobox textfield are digits.
   */

  XtAddCallback(textfield, XmNmodifyVerifyCallback,
                (XtCallbackProc)CheckDelayTime, snapDialogInfo);

  XtManageChild(snapDialogInfo->SnapDelay);

  xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 12, "Seconds"));
  label = XtVaCreateWidget("SecondsLabel", xmLabelWidgetClass, sd_form,
                           XmNrecomputeSize,    True,
                           XmNlabelString,      xmstr1,
                           XmNleftAttachment,   XmATTACH_WIDGET,
                           XmNleftWidget,       snapDialogInfo->SnapDelay,
                           XmNleftOffset,       10,
                           XmNtopAttachment,    XmATTACH_FORM,
                           XmNbottomAttachment, XmATTACH_FORM,
                           XmNalignment,        XmALIGNMENT_CENTER,
                           NULL);

  XmStringFree(xmstr1);
  XtManageChild(label);

  XtManageChild(sd_form);


  /* --------------------------------------------- */
  /*  Create the hide and beep radio buttons form  */
  /* --------------------------------------------- */

  hb_form = XtVaCreateWidget("HideBeepForm", xmFormWidgetClass,
                             snapDialogInfo->MainForm,
                             XmNmarginWidth,     5,
                             XmNmarginHeight,    5,
                             XmNleftAttachment,  XmATTACH_POSITION,
                             XmNleftPosition,    28,
                             XmNtopAttachment,   XmATTACH_WIDGET,
                             XmNtopWidget,       sd_form,
                             XmNrightAttachment, XmATTACH_FORM,
                             NULL);

  xmstr1 = XmStringCreateLocalized(
  catgets(Dtb_project_catd, 2, 4, "Beep During Countdown"));

  snapDialogInfo->BeepDuringCountDown =
  XtVaCreateManagedWidget("BeepDuringCountDown", xmToggleButtonWidgetClass,
                          hb_form,
                          XmNset,            False,
                          XmNsensitive,      False,
                          XmNlabelString,    xmstr1,
                          XmNuserData,       (XtPointer) snapDialogInfo,
                          XmNleftAttachment, XmATTACH_FORM,
                          XmNtopAttachment,  XmATTACH_FORM,
                          NULL);

  XmStringFree(xmstr1);
  XtManageChild(snapDialogInfo->BeepDuringCountDown);

  XtAddCallback(snapDialogInfo->BeepDuringCountDown, XmNvalueChangedCallback,
                BeepDuringCountDounCB, (XtPointer) snapDialogInfo);

  XtAddCallback(snapDialogInfo->BeepDuringCountDown, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAP_DELAY);


  xmstr1 = XmStringCreateLocalized(
  catgets(Dtb_project_catd, 2, 6, "Hide Window During Capture"));

  snapDialogInfo->HideDuringCapture =
  XtVaCreateManagedWidget("HideWindowDuringCapture", xmToggleButtonWidgetClass,
                          hb_form,
                          XmNset,            False,
                          XmNlabelString,    xmstr1,
                          XmNuserData,       (XtPointer) snapDialogInfo,
                          XmNleftAttachment, XmATTACH_FORM,
                          XmNtopAttachment,  XmATTACH_WIDGET,
                          XmNtopWidget,      snapDialogInfo->BeepDuringCountDown,
                          XmNtopOffset,      10,
                          NULL);

  XmStringFree(xmstr1);
  XtManageChild(snapDialogInfo->HideDuringCapture);

  XtAddCallback(snapDialogInfo->HideDuringCapture, XmNvalueChangedCallback,
                HideDuringCaptureCB, (XtPointer) snapDialogInfo);

  XtAddCallback(snapDialogInfo->HideDuringCapture, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAP_HIDE);

  XtManageChild(hb_form);


  /* --------------------------------------------------------- */
  /*  Create the Seperator widget of XmSeperator Widget Class  */
  /* --------------------------------------------------------- */

  seperator = XtVaCreateWidget("Separator", xmSeparatorWidgetClass,
                               snapDialogInfo->MainForm,
                               XmNseparatorType,   XmSHADOW_ETCHED_IN,
                               XmNorientation,     XmHORIZONTAL,
                               XmNleftAttachment,  XmATTACH_FORM,
                               XmNleftOffset,      0,
                               XmNrightAttachment, XmATTACH_FORM,
                               XmNrightOffset,     0,
                               XmNtopAttachment,   XmATTACH_WIDGET,
                               XmNtopWidget,       hb_form,
                               XmNtopOffset,       10,
                               NULL);
  XtManageChild(seperator);

  /* ----------------------------------------------------------------- */
  /*  Create the dialogcontrols container form of XmForm Widget Class  */
  /* ----------------------------------------------------------------- */

  dc_form = XtVaCreateWidget("ControlsForm", xmFormWidgetClass,
                             snapDialogInfo->MainForm,
                             XmNleftAttachment,   XmATTACH_FORM,
                             XmNtopAttachment,    XmATTACH_WIDGET,
                             XmNtopWidget,        seperator,
                             XmNtopOffset,        10,
                             XmNrightAttachment,  XmATTACH_FORM,
                             NULL);

  xmstr1 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 21, "Snap"));

  ok_button = XtVaCreateWidget("Snap", xmPushButtonWidgetClass, dc_form,
                               XmNuserData,       (XtPointer) snapDialogInfo,
                               XmNleftAttachment, XmATTACH_POSITION,
                               XmNleftPosition,   14,
                               XmNlabelString,    xmstr1,
                               NULL);

  XtAddCallback(ok_button, XmNactivateCallback, SnapOkCB, (XtPointer) snapDialogInfo);

  XtAddCallback(ok_button, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAPSHOT);

  xmstr2 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 23, "Cancel"));

  cancel_button = XtVaCreateWidget("Cancel", xmPushButtonWidgetClass, dc_form,
                                   XmNuserData,       (XtPointer) snapDialogInfo,
                                   XmNleftAttachment, XmATTACH_POSITION,
                                   XmNleftPosition,   42,
                                   XmNlabelString,    xmstr2,
                                   NULL);

  XtAddCallback(cancel_button, XmNactivateCallback,
                SnapCancelCB, (XtPointer) snapDialogInfo);

  XtAddCallback(cancel_button, XmNhelpCallback,
		  HelpItemCallback, (XtPointer) HELP_SNAPSHOT);


  xmstr3 = XmStringCreateLocalized(catgets(Dtb_project_catd, 2, 25, "Help"));

  help_button = XtVaCreateWidget("Help", xmPushButtonWidgetClass, dc_form,
                                 XmNuserData,       (XtPointer) snapDialogInfo,
                                 XmNleftAttachment, XmATTACH_POSITION,
                                 XmNleftPosition,   70,
                                 XmNlabelString,    xmstr3,
                                 NULL);

  XtAddCallback(help_button, XmNactivateCallback,
                HelpItemCallback, (XtPointer) HELP_SNAPSHOT);

  XtAddCallback(help_button, XmNhelpCallback,
                HelpItemCallback, (XtPointer) HELP_SNAPSHOT);


  XmStringFree(xmstr1);
  XmStringFree(xmstr3);
  XmStringFree(xmstr2);

  /* ----------------------------------------------------------- */
  /*  Make all dialog controls buttons of the same largest size  */
  /* ----------------------------------------------------------- */

  n = 0;
  XtSetArg(args[n], XmNwidth, &width); n++;

  max_width = 0;

  XtGetValues(ok_button, args, n);
  max_width =  (max_width < width ? width: max_width);

  XtGetValues(cancel_button, args, n);
  max_width = (max_width < width ? width: max_width);

  XtGetValues(help_button, args, n);
  max_width = (max_width < width ? width: max_width);

  n = 0;
  XtSetArg(args[n], XmNwidth, max_width + 2); n++;

  XtSetValues(ok_button, args, n);
  XtSetValues(cancel_button, args, n);
  XtSetValues(help_button, args, n);


  XtManageChild(ok_button);
  XtManageChild(cancel_button);
  XtManageChild(help_button);
  XtManageChild(dc_form);
  snapDialogInfo->OkSnapButton = ok_button;
  snapDialogInfo->CancelSnapButton = cancel_button;
  snapDialogInfo->HelpSnapButton = help_button;


  /* --------------------------------------- */
  /*  Create the status report label Widget  */
  /* --------------------------------------- */

  xmstr1 = XmStringCreateLocalized("");

  snapDialogInfo->StatusReport =
  XtVaCreateWidget("StatusReportLabel", xmLabelWidgetClass,
                   snapDialogInfo->MainForm,
                   XmNrecomputeSize,    True,
                   XmNlabelString,      xmstr1,
                   XmNuserData,        (XtPointer) snapDialogInfo,
                   XmNalignment,        XmALIGNMENT_BEGINNING,
                   XmNleftAttachment,   XmATTACH_FORM,
                   XmNtopAttachment,    XmATTACH_WIDGET,
                   XmNtopWidget,        dc_form,
                   XmNtopOffset,        10,
                   XmNrightAttachment,  XmATTACH_FORM,
                   XmNrightOffset,      15,
                   XmNbottomAttachment, XmATTACH_FORM,
                   XmNbottomOffset,     10,
                   NULL);

  XmStringFree(xmstr1);
  XtManageChild(snapDialogInfo->StatusReport);

  /* --------------------------------------------------------------------- */
  /*  Manage the container form and map the whole dialog after geometry    */
  /*  management has been done. This avoids visible growth/shrink behavior */
  /* --------------------------------------------------------------------- */

  XtManageChild(snapDialogInfo->MainForm);

  XtSetMappedWhenManaged(snapDialogInfo->dialog, True);
  XtManageChild(snapDialogInfo->dialog);

  XtVaSetValues(snapDialogInfo->MainForm,
                XmNdefaultButton, snapDialogInfo->OkSnapButton,
                XmNcancelButton,  snapDialogInfo->CancelSnapButton,
                NULL);

  snapDialogInfo->created = True;
  snapDialogInfo->snap_type = WindowRegion;
  snapDialogInfo->actual_delay = 0;
  snapDialogInfo->delay_manually_set = False;
  snapDialogInfo->snap_in_progress = False;
  snapDialogInfo->snap_cancelled = False;
  snapDialogInfo->snap_needs_save = False;

  SdtBindDeleteToCancelCallback(snapDialogInfo->dialog,
                                SnapCancelCB, (XtPointer) snapDialogInfo);

  return 0;
}


void
BeepDuringCountDounCB(Widget w, XtPointer clientData, XtPointer callData)
{
  DtbSnapDlogDialogInfo snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  beep_during = XmToggleButtonGetState(snapDialogInfo->BeepDuringCountDown);

  return;
}


void
HideDuringCaptureCB(Widget w, XtPointer clientData, XtPointer callData)
{
  int current_delay;
  static int reset_delay;
  char *seconds = NULL;
  static Boolean got_reset = False;

  Widget textfield;
  DtbSnapDlogDialogInfo snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  XtVaGetValues(snapDialogInfo->SnapDelay, DtNtextField, &textfield, NULL);
  seconds = XmTextFieldGetString(textfield);
  current_delay = atoi(seconds);

  /* ----------------------------------------------------------------- */
  /*  Change the Snap Delay to 8 seconds only if it is less than that  */
  /* ----------------------------------------------------------------- */

  hide_window = XmToggleButtonGetState(snapDialogInfo->HideDuringCapture);
  if (hide_window == True)
    {
      if (current_delay < delay_values[3])
        {
          char buf[10];
          XmString xmstr;
          sprintf(buf, "%d", delay_values[3]);
          xmstr = XmStringCreateLocalized(catgets(Dtb_project_catd, 2,
                                               delay_indices[3], buf));

          DtComboBoxSelectItem(snapDialogInfo->SnapDelay, xmstr);
          XmStringFree(xmstr);

          XtVaSetValues(snapDialogInfo->BeepDuringCountDown,
                        XmNsensitive, True, NULL);

          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 463,
                         "Timer adjusted to guarantee correct operation."));

          XBell(XtDisplayOfObject(w), 0);
          got_reset = True;
        }
      else
        got_reset = False;

      reset_delay = current_delay;
    }
  else
    DisplayStatusReport(snapDialogInfo->StatusReport, " ");

  if (current_delay > delay_values[3])
    reset_delay = current_delay;


  /* ------------------------------------------------------ */
  /*  Value was set manually while the Hide Toggle was on.  */
  /*  Can only change to a value larger than reset value.   */
  /* ------------------------------------------------------ */

  if (got_reset == True && hide_window == False)
    {
      char buf[10];
      XmString xmstr;
      sprintf(buf, "%d", reset_delay);
      xmstr = XmStringCreateLocalized(buf);
      XmTextFieldSetString(textfield, buf);
      XmStringFree(xmstr);

      got_reset = False;

      if (reset_delay == 0)
        XtVaSetValues(snapDialogInfo->BeepDuringCountDown,
                      XmNsensitive, False,
                      NULL);
    }

  XtFree(seconds);

  return;
}

void SnapOkCB(Widget w, XtPointer clientData, XtPointer callData)
{
  static Boolean first = True;
  static XWindowAttributes win_attr;

  XWindowAttributes win_attr2;
  Position x1, y1;
  Position x2, y2;
  Dimension width, height;
  int i, tmp;
  int newx, newy, num_children;
  Widget lw;
  WidgetList children;
  Window newwindow;
  DtbSnapDlogDialogInfo snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  /* ---------------------------------------------------------- */
  /*  Check to see if we need to save previous successful snap  */
  /* ---------------------------------------------------------- */

  if (dtb_snap_dlog_dialog.snap_needs_save)
    {
      Boolean cont = SaveUnsavedSnapshot();
      if (cont == False)
        return;
    }

  /* ---------------------------------------------------------------------- */
  /*  Register the Button Press, Release, Motion event, and Keyboard Press  */
  /*  handlers. Make sure they are registered against that Ok button widget */
  /* ---------------------------------------------------------------------- */

  snapDialogInfo->snap_in_progress = True;

  lw = snapDialogInfo->OkSnapButton;
  XtSetKeyboardFocus(snapDialogInfo->dialog, lw);

  XtAddEventHandler(lw, KeyPressMask, False, SnapKeyPress, NULL);
  XtAddEventHandler(lw, ButtonPressMask, False, SnapButtonPress, NULL);
  XtAddEventHandler(lw, ButtonReleaseMask, False, SnapButtonRelease, NULL);
  XtAddEventHandler(lw, ButtonMotionMask, False, SnapButtonMotion, NULL);

  /* -------------------------------------------------------------- */
  /*  Get the attributes of the root window. We need these so that  */
  /*  we can calculate the width and height of the root window to   */
  /*  make sure we don't attempt to use XGetImage off the screen    */
  /* -------------------------------------------------------------- */

  if (first)
    {
      rootWindow = RootWindowOfScreen(XtScreen(lw));
      XGetWindowAttributes(XtDisplay(snapDialogInfo->MainForm),
                           rootWindow, &win_attr);
      first = False;
    }

  /*
   * If the user manually typed in the delay time then we need
   * to verify the new value and update actual_delay variable.
   */

  SnapDelayValueChangedCB(snapDialogInfo->SnapDelay,
                          (XtPointer) snapDialogInfo, NULL);

  /*
   * Now do some real work getting the image
   */

  SnapOnCrosshairCursor(snapDialogInfo->MainForm);

  snapDialogInfo->snap_cancelled = button_pressed = button_released = False;
  x1 = x2 = y1 = y2 = 0;

  switch (snapDialogInfo->snap_type) {
    case WindowRegion:
      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 454, "Taking Snapshot..."));

      /*
       * We are getting just this window
       * Grap the pointer and the keyboard
       */

      XGrabKeyboard(XtDisplay(w), XtWindow(w), False,
                    GrabModeAsync, GrabModeAsync, CurrentTime);

      XGrabPointer(XtDisplay(w), XtWindow(w), False, ButtonPressMask,
                   GrabModeAsync, GrabModeAsync, None, None, CurrentTime);

      DisplayStatusReport(snapDialogInfo->StatusReport, catgets(prog->catd, 1, 455,
                            "Use Button 1 to select the window, Esc to cancel"));

      /*
       * Loop until the button or cancel key is pressed
       */
      while ((button_pressed == False) && (snapDialogInfo->snap_cancelled == False))
        XtAppProcessEvent(XtWidgetToApplicationContext(w), XtIMAll);

      XUngrabKeyboard(XtDisplay(w), CurrentTime);
      XUngrabPointer(XtDisplay(w), CurrentTime);

      if (snapDialogInfo->snap_cancelled)
	{
          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 461, "Snap cancelled."));
          SnapOffCrosshairCursor(snapDialogInfo->MainForm);
          snapDialogInfo->snap_in_progress = False;
          return;
	}

      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 456, "Bringing image into Image Viewer..."));

      /*
       * Now ungrab the pointer and get the window ID of the
       * window that the user just clicked on
       */

      XTranslateCoordinates(XtDisplay(w), XtWindow(w), rootWindow,
                            pressX, pressY, &newx, &newy, &newwindow);

      /*
       * The windw the user snapped is "newwindow"
       * Get the attributes of the snapped window
       * and get its window attributes
       */

      XGetWindowAttributes(XtDisplay(snapDialogInfo->MainForm), newwindow, &win_attr2);

      XTranslateCoordinates(XtDisplay(w), newwindow, rootWindow,
                            0, 0, &newx, &newy, &newwindow);

      /*
       * The x and y coordinates and the width and
       * height of the window are now available.
       */

      x1 = newx;
      y1 = newy;
      width = win_attr2.width;
      height = win_attr2.height;

      /*
       * Make sure the window does not exceed the edge of the screen
       */

      if((int)(x1 + width) > win_attr.width)
        width = win_attr.width - x1;
      if((int)(y1 + height) > win_attr.height)
        height = win_attr.height - y1;
      if(x1 < 0)
        x1 = 0;
      if(y1 < 0)
        y1 = 0;
      break;

    case RegionRegion:
      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 454, "Taking Snapshot..."));

      XGrabKeyboard(XtDisplay(w), XtWindow(w), False,
                    GrabModeAsync, GrabModeAsync, CurrentTime);

      XGrabPointer(XtDisplay(w), XtWindow(w), False,
                   ButtonPressMask|ButtonReleaseMask|ButtonMotionMask,
                   GrabModeAsync, GrabModeAsync, None, None, CurrentTime);

      DisplayStatusReport(snapDialogInfo->StatusReport, catgets(prog->catd, 1, 457,
                            "Use Button 1 to drag out a region, Esc to cancel"));

      /*
       * Loop until the button is pressed
       * This gives us one of the corners of the region
       */

      while ((button_pressed == False) && (snapDialogInfo->snap_cancelled == False))
        XtAppProcessEvent(XtWidgetToApplicationContext(w), XtIMAll);

      if (snapDialogInfo->snap_cancelled)
	{
          XUngrabPointer(XtDisplay(w), CurrentTime);
          XUngrabKeyboard(XtDisplay(w), CurrentTime);
          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 461, "Snap cancelled."));
          SnapOffCrosshairCursor(snapDialogInfo->MainForm);
          snapDialogInfo->snap_in_progress = False;
          return;
	}

      XTranslateCoordinates(XtDisplay(w), XtWindow(w), rootWindow,
                            pressX, pressY, &newx, &newy, &newwindow);

      x1 = newx;
      y1 = newy;

      /*
       * For some reason, this call to XAllowEvent is necessary
       * other wise we never get the button release event
       */

      XAllowEvents(XtDisplay(w), AsyncPointer, CurrentTime);

      DisplayStatusReport(snapDialogInfo->StatusReport, catgets(prog->catd,1,458,
                            "Release Button 1 to select region, Esc to cancel"));

      /*
       * Loop until the button is released
       * This gives us the other corner of the region
       * Then ungrab the pointer
       */

      while ((button_released == False) && (snapDialogInfo->snap_cancelled == False))
        XtAppProcessEvent(XtWidgetToApplicationContext(w), XtIMAll);

      XUngrabPointer(XtDisplay(w), CurrentTime);
      XUngrabKeyboard(XtDisplay(w), CurrentTime);

      if (snapDialogInfo->snap_cancelled)
	{
          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 461, "Snap cancelled."));
          SnapOffCrosshairCursor(snapDialogInfo->MainForm);
          snapDialogInfo->snap_in_progress = False;
          return;
	}

      DisplayStatusReport(snapDialogInfo->StatusReport, catgets(prog->catd, 1, 456,
                          "Bringing image into Image Viewer..."));

      XTranslateCoordinates(XtDisplay(w), XtWindow(w), rootWindow,
                            releaseX, releaseY, &newx, &newy, &newwindow);

      x2 = newx;
      y2 = newy;

      /*
       * We want x1, y1 to be the upper left corner Swap them if necessary
       */

      if(x1 > x2)
	{
          tmp = x1;
          x1 = x2;
          x2 = tmp;
	}
      if(y1 > y2)
	{
          tmp = y1;
          y1 = y2;
          y2 = tmp;
	}
      width = x2 - x1;
      height = y2 - y1;
      break;

    case ScreenRegion:
      /*
       * We are getting the entire screen, just use the
       * width and height from the root window attributes
       */

      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 462, "Capturing screen..."));
      x1 = y1 = 0;
      width = win_attr.width;
      height = win_attr.height;
      break;
  }

  SnapOffCrosshairCursor(snapDialogInfo->MainForm);

    /*
     * Coordinate of the top left in Root Space and size of the
     * requested rectangle
     */

  inputX = x1; inputY = y1, inputWidth = width, inputHeight = height;

  if (hide_window)
    unmapWindow();

  if (snapDialogInfo->actual_delay-- > 0)
    XtAppAddTimeOut(XtWidgetToApplicationContext(w), 1000L, DelayTheSnap, w);
  else
    XtAppAddTimeOut(XtWidgetToApplicationContext(w), 0L, ReallySnap, w);

  snapDialogInfo->snap_in_progress = False;
  return;
}


void
SnapCancelCB(Widget w, XtPointer clientData, XtPointer callData)
{
  DtbSnapDlogDialogInfo	snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  /* -------------------------------------------------------------- */
  /*  In case snap is in progress, don't do anything. SnapKeyPress  */
  /*  takes care of the undo of snapping. ESCAPE key was pressed.   */
  /* -------------------------------------------------------------- */

  if (!snapDialogInfo->snap_in_progress)
    XtUnmanageChild(snapDialogInfo->dialog);

  return;
}

void DelayTheSnap(XtPointer closure, XtIntervalId *id)
{
  int n;
  Arg args[5];
  DtbSnapDlogDialogInfo	snapDialogInfo;
  Widget w = (Widget)closure;
  static struct timeval stall = { 0, 50000 } ;

  int bells = 5;

  XtVaGetValues(w, XmNuserData, &snapDialogInfo, NULL);

  if (snapDialogInfo->actual_delay-- > 0)
    {
      if (beep_during)
        XBell(XtDisplayOfObject(w), 0);
      XtAppAddTimeOut(XtWidgetToApplicationContext(w), 1000L,
                      DelayTheSnap, w);
    }
  else
    {
      while (bells-- > 0)
        {
          select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &stall);
          if (beep_during)
            XBell(XtDisplayOfObject(w), 0);
        }

      n = 0;
      XtSetArg(args[n], XmNuserData, &snapDialogInfo); n++;
      XtGetValues(w, args, n);

      if (OpenNewImage() == 0)
        {
          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 459, "Snap succeeded."));

          snapDialogInfo->snap_needs_save = True;
        }
      else
        {
          DisplayStatusReport(snapDialogInfo->StatusReport,
                              catgets(prog->catd, 1, 460, "Snap failed."));

          snapDialogInfo->snap_needs_save = False;
        }


      /*
       * For some reason, mapping the toplevel widget doesn't map all
       * of it's children, so we have to map the snap dialog ourself.
       */

      if (hide_window)
        mapWindow();
    }
}

void ReallySnap(XtPointer closure, XtIntervalId *id)
{
  int n;
  Arg args[5];
  Widget w = (Widget)closure;
  DtbSnapDlogDialogInfo	snapDialogInfo;

  n = 0;
  XtSetArg(args[n], XmNuserData, &snapDialogInfo); n++;
  XtGetValues(w, args, n);

  if (OpenNewImage() == 0)
    {
      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 459, "Snap succeeded."));

      snapDialogInfo->snap_needs_save = True;
    }
  else
    {
      DisplayStatusReport(snapDialogInfo->StatusReport,
                          catgets(prog->catd, 1, 460, "Snap failed."));

      snapDialogInfo->snap_needs_save = False;
    }

  if (hide_window)
    XtMapWidget(snapDialogInfo->dialog);
}

void DisplayStatusReport(Widget Label, char *Report)
{
  int n;
  Arg args[5];
  XmString xmstr;
  Dimension width, height;
  DtbSnapDlogDialogInfo	snapDialogInfo;

  xmstr = XmStringCreateLocalized(Report);
  XtVaSetValues(Label, XmNlabelString, xmstr, NULL);
  XmStringFree(xmstr);
  XmUpdateDisplay(Label);

  /* --------------------------------------------------- */
  /*  Allow the dialog to grow only - no rubberbanding   */
  /*  effect when the report in the footer is displayed  */
  /* --------------------------------------------------- */

  n = 0;
  XtSetArg(args[n], XmNuserData, &snapDialogInfo); n++;
  XtGetValues(Label, args, n);

  n = 0;
  XtSetArg(args[n], XmNwidth, &width); n++;
  XtSetArg(args[n], XmNheight, &height); n++;
  XtGetValues(snapDialogInfo->dialog, args, n);

  n = 0;
  XtSetArg(args[n], XmNminWidth, width); n++;
  XtSetArg(args[n], XmNminHeight, height); n++;
  XtSetValues(snapDialogInfo->dialog, args, n);
  return;
}

void
SnapKeyPress(
    Widget      w,
    XtPointer   client_data,
    XEvent      *event,
    Boolean     *ctd)
{
  int n;
  Arg args[5];
  DtbSnapDlogDialogInfo	snapDialogInfo;

  KeySym sym = XKeycodeToKeysym(XtDisplay(w), event->xkey.keycode, 0);

  n = 0;
  XtSetArg(args[n], XmNuserData, &snapDialogInfo); n++;
  XtGetValues(w, args, n);

  /* ------------------------------------------ */
  /*  Check to see if the key is Esc or Cancel  */
  /* ------------------------------------------ */

  if ((sym == XK_Cancel) || (sym == XK_Escape))
    snapDialogInfo->snap_cancelled = True;

  XtRemoveEventHandler(w, KeyPressMask, False, SnapKeyPress, NULL);

  return;
}


void
SnapButtonPress(Widget	w,
                XtPointer	client_data,
                XEvent	*event,
                Boolean	*ctd)
{
  /*
   * Just return if not Button1
   */
  if (event->xbutton.button != Button1)
    return;

  /*
   * Set pressX and pressY with respect to the root window
   */
  pressX = event->xbutton.x;
  pressY = event->xbutton.y;

  button_pressed = True;

  XtRemoveEventHandler(w, ButtonPressMask, False, SnapButtonPress, NULL);
}


void
SnapButtonRelease(Widget w,
                  XtPointer	client_data,
                  XEvent	*event,
                  Boolean	*ctd)
{
  /*
   * Just return if not Button1
   */
  if (event->xbutton.button != Button1)
    return;

  /*
   * Set pressX and pressY with respect to the root window
   */
  releaseX = event->xbutton.x;
  releaseY = event->xbutton.y;

  button_released = True;

  if(motion_width != 0 && motion_height != 0)
    XDrawRectangle(XtDisplay(w), rootWindow, gc,
                   motion_x1, motion_y1, motion_width, motion_height);

  motion_width = motion_height = motion_x1 = motion_y1 = 0;

  XtRemoveEventHandler(w, ButtonReleaseMask, False, SnapButtonRelease, NULL);

  return;
}


void
SnapButtonMotion(Widget	    w,
                 XtPointer  client_data,
                 XEvent	   *event,
                 Boolean   *ctd)
{
  static Boolean first = True;
  Window newwindow;
  XGCValues values;
  int x2, y2, tmp;

  /*
   * Just return if not Button1
   */
  if (event->xbutton.button != Button1)
    return;

  if (first)
    {
      first = False;
      values.foreground = ~((~0L) << DefaultDepthOfScreen(XtScreen(w)));
      values.subwindow_mode = IncludeInferiors;
      values.function = GXxor;
      gc = XtGetGC(w, GCForeground | GCSubwindowMode | GCFunction,
                   &values);
    }
  else
    XDrawRectangle(XtDisplay(w), rootWindow, gc,
                   motion_x1, motion_y1, motion_width, motion_height);

  /*
   * Set pressX and pressY with respect to the root window
   */
  motionX = event->xbutton.x;
  motionY = event->xbutton.y;

  XTranslateCoordinates(XtDisplay(w), XtWindow(w), rootWindow,
                        pressX, pressY, &motion_x1, &motion_y1, &newwindow);

  XTranslateCoordinates(XtDisplay(w), XtWindow(w), rootWindow,
                        motionX, motionY, &x2, &y2, &newwindow);

  if(motion_x1 > x2)
    {
      tmp = motion_x1;
      motion_x1 = x2;
      x2 = tmp;
    }

  if(motion_y1 > y2)
    {
      tmp = motion_y1;
      motion_y1 = y2;
      y2 = tmp;
    }

  motion_width = x2 - motion_x1;
  motion_height = y2 - motion_y1;

  XDrawRectangle(XtDisplay(w), rootWindow, gc,
                 motion_x1, motion_y1, motion_width, motion_height);

  XtRemoveEventHandler(w, ButtonMotionMask, False, SnapButtonMotion, NULL);

  return;
}


/*
 * Set the type: Window Region Screen
 */

void SnapTypeToggledCB(Widget w, XtPointer clientData, XtPointer callData)
{
  DtbSnapDlogDialogInfo	snapDialogInfo;
  int n = 0;
  Arg args[5];
  XtSetArg(args[n], XmNuserData, (XtPointer) &snapDialogInfo); n++;
  XtGetValues(w, args, n);

  snapDialogInfo->snap_type = (SnapRegionType) clientData;
  return;
}

void
SnapDelayValueChangedCB(Widget w, XtPointer clientData, XtPointer callData)
{
  char *seconds;
  Widget textfield;
  DtbSnapDlogDialogInfo snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  XtVaGetValues(snapDialogInfo->SnapDelay, DtNtextField, &textfield, NULL);
  seconds = XmTextFieldGetString(textfield);
  snapDialogInfo->actual_delay = atoi(seconds);

  /* -------------------------------------------------------------------------- */
  /*  Force delay to be 8 sec, if application is to be hidden. Save reset value */
  /* -------------------------------------------------------------------------- */

  if (hide_window == True)
    {
      if (snapDialogInfo->actual_delay < delay_values[3])
        {
          char buf[10];
          XmString xmstr;
          sprintf(buf, "%d", delay_values[3]);
          xmstr = XmStringCreateLocalized(catgets(Dtb_project_catd, 2,
                                               delay_indices[3], buf));

          DtComboBoxSelectItem(snapDialogInfo->SnapDelay, xmstr);
          XmStringFree(xmstr);

          snapDialogInfo->actual_delay = delay_values[3];

          XBell(XtDisplayOfObject(w), 0);

          DisplayStatusReport(snapDialogInfo->StatusReport,
           catgets(prog->catd, 1, 464, "8 sec. delay required for Hide option."));

          snapDialogInfo->delay_manually_set = False;

        }
      else
        snapDialogInfo->delay_manually_set = True;
    }

  if (snapDialogInfo->actual_delay > 0)   /* then enable the countdown beep CB */
    XtVaSetValues(snapDialogInfo->BeepDuringCountDown, XmNsensitive, True, NULL);
  else
    XtVaSetValues(snapDialogInfo->BeepDuringCountDown, XmNsensitive, False, NULL);

  XtFree(seconds);

  return;
}

void CheckDelayTime(Widget widget, XtPointer clientData, XtPointer callData)
{
  register int len;
  XmTextVerifyCallbackStruct *cbs = (XmTextVerifyCallbackStruct *)callData;

  DtbSnapDlogDialogInfo snapDialogInfo = (DtbSnapDlogDialogInfo)clientData;

  if (cbs->startPos < cbs->currInsert)	/* backspace */
    return;

  /* Make sure all additions are digits. */
  for (len = 0; len < cbs->text->length; len++)
    {
      /* Not a digit, move all chars down one and decrement text->length */
      if (!isdigit(cbs->text->ptr[len]))
	{
          register int i;
          for (i = len; (i+1) < cbs->text->length; i++)
            cbs->text->ptr[i] = cbs->text->ptr[i+1];
          cbs->text->length--;
          len--;
	}
    }

  if (cbs->text->length == 0)
    cbs->doit = False;

  return;
}

void
SnapOnCrosshairCursor(Widget w)
{
  static Cursor crosshairCursor = 0;

  if ( crosshairCursor == 0 )
    crosshairCursor = XCreateFontCursor(XtDisplay(w), XC_crosshair);

  XDefineCursor(XtDisplay(w), XtWindow(w), crosshairCursor);
  XFlush(XtDisplay(w));
}

void
SnapOffCrosshairCursor(Widget w)
{
  XUndefineCursor(XtDisplay(w), XtWindow(w));
  XFlush(XtDisplay(w));
  return;
}

/*
 * Create an XImage from a 24 bit image data returned from
 * multivis routine CreateImageFromImg().
 */

XImage * GenerateXimage(ImageInfo *image, unsigned char* data)
{
  XImage *ximage = NULL;
  unsigned char *newdata = NULL;
  unsigned char *dptr = NULL;
  unsigned char *optr = NULL;
  register int i, j, k;

  newdata = (unsigned char *)malloc((size_t) image->width*image->height*4);
  dptr = newdata;
  optr = data;
  for (i = 0; i < image->height ; i++)
    {
      for (j = 0; j < image->width ; j++)
        {
          *dptr++ = 0;
          for (k = 0 ; k < 3 ; k++)
            *dptr++ = *optr++;
        }

      for (j = 0; j < (image->bytes_per_line - (image->width * 3)); j++)
        optr++;
    }

  free(data);

  image->bytes_per_line = image->width * 4;
  image->depth = 32;

  ximage = XCreateImage(current_display->xdisplay, current_display->visual,
                        image->depth, ZPixmap, 0, (char *)newdata,
                        image->width, image->height, 32, 0) ;

  if (ximage != NULL)
    ximage->byte_order = MSBFirst;

  return(ximage);
}


int
CreateImageFromScreen(ImageInfo *image)
{
    XWindowAttributes	 win_attrs;
    XImage		*ximage;
    XilImage		 xilimage;
    XilDataType		 datatype;
    XilMemoryStorage	 storage;
    unsigned int	 pixel_stride, xpixel_stride, scanline_stride;
    unsigned char	*startlineptr, *xstartlineptr;
    unsigned char	*lineptr, *xlineptr;
    unsigned char	*image_data = NULL, *tmp_data = NULL;
    register int	 x_index, xil_index, row, col;
    Boolean		 get_ximage = True;
    int			 multiVis, current_depth;

    /*
     * Create the image and get the pointer to the data.
     */

    if(inputWidth == 0 || inputHeight == 0) /* we have no image! */
      {
	fprintf(stderr,	"Image height or width must be greater than 0\n",
		  prog->name);
	return(-1);
      }

    image->width   = inputWidth;
    image->height  = inputHeight;
    image->depth   = 24;

    tmp_data = (unsigned char *)create_data(image, &pixel_stride,
                   &scanline_stride);

    image->bytes_per_line = scanline_stride;

    /*
     * Initialize padding info...
     */
    init_pad();

    /*
     * Check for the number of visual.
     */
    if (init_multivis() > 1)
    {

        /*
         * Reset multivisual variables.
         */
        mvReset();

        /*
         * Get a list of intersecting windows, with their visual details.
         */
        mvWalkTree(rootWindow, 0, 0, inputX, inputY, inputWidth, inputHeight);

        /*
         * Check if we have a multiVis on our hands.
         */
        multiVis = IsMultiVis(mvIsMultiVis());

        if (multiVis)
        {
            /*
             * Create an Image where mvDoWindows.. will operate.
             */
            if (!mvCreatImg(inputWidth, inputHeight, inputX, inputY))
            {
                fprintf(stderr,
			catgets(prog->catd, 1, 452,
				"%s: mvCreatImg failed\n"),
			prog->name);
                return(-1);
            }

            mvDoWindowsFrontToBack();

            /*
             * Convert the map into an XImage.
             */
            image_data = CreateImageFromImg(image);

            if ((ximage = GenerateXimage(image, image_data)) == NULL)
            {
                fprintf(stderr, catgets(prog->catd, 1, 453,
					"%s: XCreateImage failed\n"),
		  prog->name);
                return(-1);
            }

            get_ximage = False;
        }

        /*
         * We don't have a multivisual problem on our hands. Although we
         * have a system that supports multiple visuals, the
         * region/screen/windows snapped only uses one of the visuals,
         * so we can use XGetImage to get the pixels values for that region.
         */
        else
        {
            current_depth = mvDepth();
            image->cmap = mvColormap();
        }
    }

    /*
     * Our system only supports one visual, so we can use XGetImage.
     */
    else
        current_depth = current_display->depth;

    if (get_ximage == True)
    {
        ximage = (XImage *)XGetImage(current_display->xdisplay, rootWindow,
                     inputX, inputY, inputWidth, inputHeight, AllPlanes,
                     ((current_depth == 1) ? XYPixmap : ZPixmap));

	/* If XGetImage() failed, then return. */
	if (ximage == (XImage *) NULL)
		return(-1);

        set_current_pad(ximage->depth, ximage->bitmap_pad);

        if (ximage->depth == 4)
            set_current_pad(8, ximage->bitmap_pad);

        /*
         * Image depth should be set to depth returned from XGetImage, not the
         * depth of the window (may be different) - this is where we need to
         * add support for images that cross visual boundaries.
         */
        image->depth          = ximage->depth;
        image->bytes_per_line = ximage->bytes_per_line;

        XGetWindowAttributes(current_display->xdisplay, rootWindow, &win_attrs);
        image->cmap = win_attrs.colormap;

        /*
         * If the depth is 4 or 8, then we need to get pixel values from
         * the colormap. If it's 24, then we have the rgb values.
         */
        if ((image->depth == 4) || (image->depth == 8))
        {
            register int i;
            int cmap_size = 256;
            XColor xcolors[256];
	    XVisualInfo vinfo_tmpl;
	    XVisualInfo *return_vinfo = NULL;
	    long vinfo_mask = VisualIDMask;
	    int num_vinfos;

	    /*
	     * need to make sure we get the correct number of colors
	     *
	     * we cannot be sure how many colors have been allocated in a visual...
	     */
	    vinfo_tmpl.visualid = XVisualIDFromVisual(win_attrs.visual);
	    return_vinfo = XGetVisualInfo(current_display->xdisplay,
					  vinfo_mask,
					  &vinfo_tmpl,
					  &num_vinfos);

	    cmap_size = return_vinfo->colormap_size;


	    for (i = 0; i <= cmap_size - 1; i++)
                xcolors[i].pixel = (unsigned long)i;

            XQueryColors(current_display->xdisplay, image->cmap,
                xcolors, cmap_size) ;

            image->colors = cmap_size;
            image->red    = (unsigned char *)malloc(cmap_size) ;
            image->green  = (unsigned char *)malloc(cmap_size) ;
            image->blue   = (unsigned char *)malloc(cmap_size) ;

            for (i = 0; i <= cmap_size - 1; i++)
            {
                image->red[i]   = xcolors[i].red   >> 8 ;
                image->green[i] = xcolors[i].green >> 8 ;
                image->blue[i]  = xcolors[i].blue  >> 8 ;
            }
        }
    }

    /*
     * Now, convert an XImage to an XilImage.
     */

    datatype = (current_display->depth == 1) ? XIL_BIT : XIL_BYTE;

    xilimage = (*xil->create)(image_display->state, inputWidth, inputHeight,
        ((image->depth >= 24) ? 3 : 1), datatype);

    (*xil->export_ptr)(xilimage);

    if (((*xil->get_memory_storage)(xilimage, &storage)) == False)
    {
       if (prog->verbose)
          fprintf (stderr,
	      catgets(prog->catd, 1, 269,
	      "%s.create_image_from_screen: xil_get_memory_storage_failed\n"),
	      prog->name);

       XDestroyImage(ximage);
       return(-1);
    }

    if (datatype == XIL_BYTE)
    {
        image->bytes_per_line = storage.byte.scanline_stride;
        pixel_stride = storage.byte.pixel_stride;
    }
    else
	image->bytes_per_line = storage.bit.scanline_stride;

    xpixel_stride = ximage->bytes_per_line / ximage->width;

    /*
     * Copy data to new image. Now, image->bytes_per_line should be
     * correct for all depths, so we should be able to copy the correct
     * number of bytes from the ximage to the xil image in a standard way.
     */

    xil_index = 0;
    x_index = 0;
    if(image->depth < 24)
	{
	    for (row = 0; row < ximage->height; row++) {
		memcpy (&storage.byte.data[xil_index], &ximage->data[x_index],
			image->bytes_per_line);
		xil_index += image->bytes_per_line;
		x_index += ximage->bytes_per_line;
	    }
	}
    else
	{
	    startlineptr = storage.byte.data;
	    xstartlineptr = (unsigned char *)ximage->data;

	    lineptr = startlineptr;
	    xlineptr = xstartlineptr + 1;

	    for (row = 0; row < ximage->height; row++)
		{
		    for (col = 0; col < ximage->width; col++)
			{
			    memcpy(lineptr, xlineptr, 3);
			    lineptr += pixel_stride;
			    xlineptr += xpixel_stride;
			}

		    startlineptr += image->bytes_per_line;
		    lineptr = startlineptr;
		    xstartlineptr += ximage->bytes_per_line;
		    xlineptr = xstartlineptr + 1;
		}
	}
    image->rgborder = 0;

    /*
     * Read the file directly into the data pointer.
     */
    image->orig_image =  xilimage;

    (*xil->import_ptr)(image->orig_image, True);

    /*
     * Free the ximage.
     */
    XDestroyImage(ximage);

    return(0);
}

int
OpenNewImage()
{
    static TypeInfo	 file_type = { NO_TYPE, "", "", NULL, NULL, NULL, NULL};
    DisplayInfo		*prev_display;
    ImageInfo		*new_image, *prev_image;
    StateInfo		*new_state;
    Boolean		 retry = False;
    Boolean		 prev_null_image = False;
    Boolean		 manage_overview = False;
    char		 error[MAXPATHLEN];

    setbusy();

    /*
     * Clear footer
     */
    SetFooter(base->left_footer, "");

    /*
     * If Page Overview showing, umap the buttons.
     */
    if (pg_overview && pg_overview->showing == True)
    {
        XtUnmanageChild(pg_overview->scrolledw);
        XFlush(ps_display->xdisplay);
        manage_overview = True;  /* If error, manage these again */
    }

    /*
     * Init image objects if not already done so and not a PS file.
     */
    if (prog->xil_opened == False)
    {
        BaseImageCanvasObjectsCreate(base);
        if (prog->xil_opened == False)
        {
            setactive();
            return(-1);
        }
    }

    /*
     * If we were reading a PostScript file, we can stop now...
     */
    if ((current_image != (ImageInfo *) NULL) &&
        (current_display != (DisplayInfo *) NULL) &&
        (current_display == ps_display))
       close_ps(True, False);

    /*
     * At this point, it looks like we probably will read in the file,
     * so create a new ImageInfo structure, and pass to appropriate
     * load function.
     */
    new_image = init_image(NULL, NULL, 0, &file_type, NULL);

    /*
     * We need a new state.. mainly for postscript files. Create one here.
     */
    new_state = init_state(( *new_image->type_info).type);

    if (CreateImageFromScreen(new_image) != 0)
    {
        free(new_state);
        destroy_image(new_image);
        setactive();
        return(-1);
    }

    set_tool_options(current_image, new_image);

    /*
     * Set the new image, but don't destroy old one until
     * assign_display_func is successful.
     */
    if (current_image != NULL)
        prev_null_image = True;

    prev_image = current_image;
    current_image = new_image;
    prev_display = current_display;

    set_current_display();

    /*
     * Make image available for XIL processing.
     * Dither image for current depth.
     */
    if (current_state != (StateInfo *) NULL)
        free(current_state);

    current_state = new_state;

    if (assign_display_func(new_image, image_display->depth) == -1)
    {
        if (manage_overview == True)
            XtManageChild(pg_overview->scrolledw);

        current_display = prev_display;
        current_image = prev_image;

        if ((current_image != (ImageInfo *) NULL) &&
            (current_display != (DisplayInfo *) NULL) &&
            (current_display == ps_display))
            restart_ps ();

        set_tool_options(NULL, prev_image);

        destroy_image(new_image);
        setactive();
        return(-1);
    }

    if (prev_null_image == True)
        destroy_image(prev_image);

    (current_image->revert_func)();

    XmScrolledWindowSetAreas (base->scrolledw, base->hscroll,
        base->vscroll, base->canvas);

    check_canvas(current_image->width, current_image->height, current_display);

    /*
     * Fit frame to image then re-position palette if showing.
     */
    fit_frame_to_image(current_image);
    resize_canvas();
    CanvasRepaintCallback(NULL, NULL, NULL);

    /*
     * Check which popups should be showing with
     * this newly loaded image.
     */
    check_popups(prev_null_image);

    setactive();

    return (0);
}

void
mapWindow()
{
    if (open_dialog && dialog_showing_status.open_d)
        XtPopup(XtParent(open_dialog), XtGrabNone);
    if (openas && dialog_showing_status.openas_d)
        XtPopup(XtParent(openas->dialog), XtGrabNone);
    if (save_dialog && dialog_showing_status.save_d)
        XtPopup(XtParent(save_dialog), XtGrabNone);
    if (saveas && dialog_showing_status.saveas_d)
        XtPopup(XtParent(saveas->dialog), XtGrabNone);
    if (palette && dialog_showing_status.palette_d)
        XtPopup(XtParent(palette->dialog), XtGrabNone);
    if (info && dialog_showing_status.info_d)
        XtPopup(XtParent(info->dialog), XtGrabNone);
    if (pg_overview && dialog_showing_status.pg_overview_d)
        XtPopup(XtParent(pg_overview->dialog), XtGrabNone);
    if (pg_controls && dialog_showing_status.pg_controls_d)
        XtPopup(XtParent(pg_controls->dialog), XtGrabNone);
    if (properties && dialog_showing_status.properties_d)
        XtPopup(XtParent(properties->dialog), XtGrabNone);
    if (print && dialog_showing_status.print_d)
        XtPopup(XtParent(print->dialog), XtGrabNone);
    if (print_prev && dialog_showing_status.print_prev_d)
        XtPopup(XtParent(print_prev->dialog), XtGrabNone);
    if (about && dialog_showing_status.about_d)
        XtPopup(XtParent(about->dialog), XtGrabNone);

    /* Now we map the toplevel and the snap dialog */
    XMapWindow(current_display->xdisplay, XtWindow(base->top_level));
    XMapRaised(current_display->xdisplay, XtWindow(dtb_snap_dlog_dialog.dialog));
    XSync(current_display->xdisplay, False);

    return;
}


void unmapWindow()
{
    if (open_dialog && open_showing)
    {
        dialog_showing_status.open_d = True;
        XtPopdown(XtParent(open_dialog));
    }
    if (openas && openas->showing)
    {
        dialog_showing_status.openas_d = True;
        XtPopdown(XtParent(openas->dialog));
    }
    if (save_dialog && save_dialog)
    {
        dialog_showing_status.save_d = True;
        XtPopdown(XtParent(save_dialog));
    }
    if (saveas && saveas->showing)
    {
        dialog_showing_status.saveas_d = True;
        XtPopdown(XtParent(saveas->dialog));
    }
    if (palette && palette->showing)
    {
        dialog_showing_status.palette_d = True;
        XtPopdown(XtParent(palette->dialog));
    }
    if (info && info->showing)
    {
        dialog_showing_status.info_d = True;
        XtPopdown(XtParent(info->dialog));
    }
    if (pg_overview && pg_overview->showing)
    {
        dialog_showing_status.pg_overview_d = True;
        XtPopdown(XtParent(pg_overview->dialog));
    }
    if (pg_controls && pg_controls->showing)
    {
        dialog_showing_status.pg_controls_d = True;
        XtPopdown(XtParent(pg_controls->dialog));
    }
    if (properties && properties->showing)
    {
        dialog_showing_status.properties_d = True;
        XtPopdown(XtParent(properties->dialog));
    }
    if (print && print->showing)
    {
        dialog_showing_status.print_d = True;
        XtPopdown(XtParent(print->dialog));
    }
    if (print_prev && print_prev->showing)
    {
        dialog_showing_status.print_prev_d = True;
        XtPopdown(XtParent(print_prev->dialog));
    }
    if (about && about->showing)
    {
        dialog_showing_status.about_d = True;
        XtPopdown(XtParent(about->dialog));
    }

    /* Now we unmap the toplevel */
    XUnmapWindow(current_display->xdisplay, XtWindow(dtb_snap_dlog_dialog.dialog));
    XUnmapWindow(current_display->xdisplay, XtWindow(base->top_level));

    XSync(current_display->xdisplay, False);

    return;
}

static void
SdtFixShellSize(Widget SdtDialogShell, XtPointer data, XConfigureEvent *event)
{
  if (event->type == ConfigureNotify)
    XtVaSetValues(SdtDialogShell,
                  XmNminWidth,  event->width,
                  XmNminHeight, event->height,
                  NULL );
  return;
}

void SdtBindDeleteToCancelCallback(Widget SomeVendorShell,
                                   void (*CancelFunction)(),
                                   XtPointer Closure)
{
  static Atom wm_delete_win;

  if (!wm_delete_win)
    wm_delete_win = XmInternAtom(XtDisplay(SomeVendorShell), "WM_DELETE_WINDOW", False);

  XmAddWMProtocolCallback(SomeVendorShell, wm_delete_win, CancelFunction, Closure);

  return;
}


Boolean SaveUnsavedSnapshot()
{

  typedef enum {YES_SAVE = 0, NO_SAVE = 1, CANCEL_SAVE = 2} SaveSnapShot;

  SaveSnapShot save =
  AlertPrompt(base->top_level,
              DIALOG_TYPE, XmDIALOG_WARNING,
              DIALOG_STYLE, XmDIALOG_FULL_APPLICATION_MODAL,
              DIALOG_TITLE, catgets (Dtb_project_catd, 2, 29,
                                     "Image Viewer - Save Snapshot?"),
              DIALOG_TEXT, catgets (Dtb_project_catd, 2, 30,
              "Snapshot image not saved. Do you want to\nsave the image?"),
              BUTTON_IDENT, YES_SAVE, catgets (prog->catd, 1, 305, "Yes"),
              BUTTON_IDENT, NO_SAVE, catgets (prog->catd, 1, 306, "No"),
              BUTTON_IDENT, CANCEL_SAVE, catgets (prog->catd, 1, 230, "Cancel"),
              NULL);

  if (save == CANCEL_SAVE)
    return(False);
  else if (save == NO_SAVE)
    return(True);
  else
    {
      XtAppContext app_context = XtWidgetToApplicationContext(base->top_level);
      /*
       * Create File Selection Box if not already created.
       */
      if (!saveas)
        {
          saveas = SaveAsObjectsInitialize (base->top_level);
          set_saveas_list (saveas->format_list);
        }

      SaveAsCallback(base->top_level, (XtPointer) SAVEAS, NULL);

      /* ------------------------------------------------------------------ */
      /*  button_selected is changed by the callbacks of the SaveAs Dialog  */
      /* ------------------------------------------------------------------ */

      saveas->button_selected = SAVE_UNDEFINED;
      while(saveas->button_selected == SAVE_UNDEFINED)
        XtAppProcessEvent(app_context, XtIMXEvent | XtIMAll);

      if (saveas->button_selected == SAVE_OK_BUTTON)
        return(True);
      else
        return (False);
    }
}
