#ifndef lint
static char sccsid[] = "@(#)ps_optionsui.c 1.11 96/03/07";
#endif

/*
 * Copyright 1993 Sun Microsystems, Inc.  All rights reserved.
 */

/*
 * ps_optionsui.c - User interface object initialization functions
 * for image info pop up.
 * This file was generated by `gxv' from `imagetool.G'.
 */
#include <sys/param.h>

#include <Xm/Xm.h>
#include <Xm/DialogS.h>
#include <Xm/Form.h>
#include <Xm/Label.h>
#include <Xm/List.h>
#include <Xm/PushB.h>
#include <Xm/PushBG.h>
#include <Xm/MessageB.h>
#include <Xm/RowColumn.h>
#include <Xm/ToggleBG.h>
#include <Dt/SpinBox.h>

#include "display.h"
#include "help.h"
#include "image.h"
#include "imagetool.h"
#include "state.h"
#include "ui_imagetool.h"

#include "degrees.xbm"

extern  int pages_rendered;

float	page_widths [6] = { 8.5, 8.5, 11.0, 11.6875, 8.25, 6.929 };
float	page_heights [6] = { 11.0, 14.0, 17.0, 16.5625, 11.75, 9.843 };

PgControlsObjects *
PgControlsObjectsInitialize(parent)
     Widget  parent;
{
     Widget        children[6];      /* Children to manage */
     Arg           al[64];           /* Arg List */
     register int  ac = 0;           /* Arg Count */
     XmString      xmstrings[16];    /* temporary storage for XmStrings */
     PgControlsObjects  *p;
     Widget        form, longest_label, scrolledw, menu;
     Dimension     width1, width2, width3, longest, margin;
     XmString     *list_items;        /* For list items */
     int           list_item;         /* Index for list_items */
     Dimension     height;
     Pixel         fg, bg;
     int           depth;
     Pixmap        degrees_pixmap;
     Widget        degrees_label;
     
     extern void   PopupEventHandler();
     extern void   PgControlsOKCallback();
     extern void   PgControlsCancelCallback();
     
     p = (PgControlsObjects *) calloc (1, sizeof (PgControlsObjects));
/*
 * Create Shell, Dialog, Forms.
 */	
     ac = 0;
     XtSetArg(al[ac], XmNallowShellResize, TRUE); ac++;
     XtSetArg(al[ac], XmNtitle, catgets (prog->catd, 1, 271, 
				"Image Viewer - Page Viewing Controls")); ac++;
     p->shell = XmCreateDialogShell ( parent, "PgControlsShell", al, ac );
/*
 * Create Message Dialog Box
 */
     ac = 0;
     XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
     XtSetArg(al[ac], XmNdialogType, XmDIALOG_TEMPLATE); ac++;	
     XtSetArg(al[ac], XmNnoResize, FALSE); ac++;
     p->dialog = XmCreateMessageBox (p->shell, "PgControlsDialog", al, ac );
/*
 * Add event handler to catch Maps/Unmaps.
 */
     XtAddEventHandler (p->shell, StructureNotifyMask, False,
			PopupEventHandler, p->dialog);
/*
 * Create Form
 */
     ac = 0;
     XtSetArg(al[ac], XmNautoUnmanage, FALSE); ac++;
     XtSetArg(al[ac], XmNfractionBase, 60); ac++;
     form = XmCreateForm ( p->dialog, "PgControlsForm", al, ac );
/*
 * Create the Rotate label
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 441,
					     "Rotate:"));
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 0); ac++; 
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->rotate_label = XmCreateLabel ( form, "RotateLabel", al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create the Order label
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 273, 
					     "Order:"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 22); ac++; 
     p->order_label = XmCreateLabel ( form, "OrderLabel", al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create the Size label
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 274,
						      "Size:"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 44); ac++; 
     p->pgsize_label = XmCreateLabel ( form, "PageSizeLabel", al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Find the longest label
 */
     XtVaGetValues (p->rotate_label, XmNwidth, &width1, NULL);
     XtVaGetValues (p->order_label, XmNwidth, &width2, NULL);
     XtVaGetValues (p->pgsize_label, XmNwidth, &width3, NULL);
     
     longest = width1;
     longest_label = p->rotate_label;						
     if (width2 > longest) {
       longest = width2;
       longest_label = p->order_label;
     }
     if (width3 > longest){
       longest = width3;
       longest_label = p->pgsize_label;
     }
/*
 * Now that we know which label is the longest,
 * align the other labels with this label.
 */
     if (p->rotate_label != longest_label) 
       XtVaSetValues (p->rotate_label, 
		      XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET,
		      XmNrightWidget, longest_label, 
		      NULL);
     if (p->order_label != longest_label) 
       XtVaSetValues (p->order_label, 
		      XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET,
		      XmNrightWidget, longest_label, 
		      NULL);
     if (p->pgsize_label != longest_label)
       XtVaSetValues (p->pgsize_label, 
		      XmNrightAttachment, XmATTACH_OPPOSITE_WIDGET,
		      XmNrightWidget, longest_label, 
		      NULL);
/*
 * Create Rotate Degrees menu
 */
     ac = 0;
     XtSetArg (al[ac], XmNpacking, XmPACK_COLUMN); ac++;
     XtSetArg (al[ac], XmNorientation, XmVERTICAL); ac++;
     XtSetArg (al[ac], XmNnumColumns, 1); ac++;
     menu = XmCreatePulldownMenu (form, "DegreesPulldownMenu", al, ac);

     ac = 0;
     XtSetArg (al[ac], XmNsubMenuId, menu); ac++;
     XtSetArg (al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg (al[ac], XmNleftWidget, p->rotate_label); ac++;
     XtSetArg (al[ac], XmNleftOffset, 10); ac++;
     XtSetArg (al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg (al[ac], XmNtopPosition, 0); ac++;
     p->degrees_menu = XmCreateOptionMenu (form, "DegreesOptionMenu", al, ac);

     XtVaSetValues (XmOptionButtonGadget (p->degrees_menu),
                    XmNuserData, "0", NULL);

     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 442, "0"));
     xmstrings[1] = XmStringCreateLocalized (catgets (prog->catd, 1, 443, "90"));
     xmstrings[2] = XmStringCreateLocalized (catgets (prog->catd, 1, 444, "180"));
     xmstrings[3] = XmStringCreateLocalized (catgets (prog->catd, 1, 445, "270"));
     p->degrees_0 = XtVaCreateWidget ("Degrees0Item", 
                                     xmPushButtonGadgetClass, menu,
                                     XmNlabelString, xmstrings[0],
                                     NULL);
     p->degrees_90 = XtVaCreateWidget ("Degrees90Item",
                                     xmPushButtonGadgetClass, menu,
                                     XmNlabelString, xmstrings[1],
                                     NULL);
     p->degrees_180 = XtVaCreateWidget ("Degrees180MenuItem",
                                     xmPushButtonGadgetClass, menu,
                                     XmNlabelString, xmstrings[2],
                                     NULL);
     p->degrees_270 = XtVaCreateWidget ("Degrees270MenuItem",
                                     xmPushButtonGadgetClass, menu,
                                     XmNlabelString, xmstrings[3],
                                     NULL);
     XmStringFree ( xmstrings [ 0 ] );
     XmStringFree ( xmstrings [ 1 ] );
     XmStringFree ( xmstrings [ 2 ] );
     XmStringFree ( xmstrings [ 3 ] );
/*
 * Need this for any depth.
 */
     XtVaGetValues (p->dialog, XmNforeground, &fg,
			       XmNbackground, &bg, 	
			       XmNdepth, &depth, NULL);
     degrees_pixmap = XCreatePixmapFromBitmapData 
                          (ps_display->xdisplay, 
			   DefaultRootWindow (ps_display->xdisplay), 
			   (char *)degrees_xbm_bits, degrees_xbm_width,
			   degrees_xbm_height, fg, bg, depth);
/*
 * Create Degrees Label
 */
     ac = 0;
     XtSetArg(al[ac], XmNlabelType, XmPIXMAP); ac++;
     XtSetArg(al[ac], XmNlabelPixmap, degrees_pixmap); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 0); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNleftWidget, p->degrees_menu); ac++;
     XtSetArg(al[ac], XmNleftOffset, 5); ac++;
     degrees_label = XmCreateLabel ( form, "DegreesLabel", al, ac );

/*
 * Create Rotate radio box
 */
     ac = 0;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 0); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNleftWidget, degrees_label); ac++;
     XtSetArg(al[ac], XmNleftOffset, 5); ac++;
     p->radio1 = XmCreateRadioBox ( form, "PgControlsRadio1", al, ac );
/*
 * Create Toggle Buttons for Rotate radio box.
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 446,
						      "Right"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNset, True); ac++; 
     XtSetArg(al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
     p->right_toggle = XmCreateToggleButtonGadget (p->radio1, "RightButton", al, ac );
     XmStringFree ( xmstrings [ 0 ] );

     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 447,
						      "Left"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNset, False); ac++; 
     XtSetArg(al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
     p->left_toggle = XmCreateToggleButtonGadget (p->radio1, "LeftButton", al, ac );
     XmStringFree ( xmstrings [ 0 ] );
     
/*
 * Create Order radio box
 */
     ac = 0;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 22); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNleftWidget, p->order_label); ac++;
     XtSetArg(al[ac], XmNleftOffset, 10); ac++;
     p->radio2 = XmCreateRadioBox ( form, "PgControlsRadio2", al, ac );

/* 
 * Create Toggle buttons for Order radio box.
 */
     ac = 0;						
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 277,
						      "First Page First"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     XtSetArg(al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
     p->fpf = XmCreateToggleButtonGadget (p->radio2, "FPFButton", al, ac );
     XmStringFree ( xmstrings [ 0 ] );
     
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 278,
						      "Last Page First"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++; 
     XtSetArg(al[ac], XmNnavigationType, XmTAB_GROUP); ac++;
     p->lpf = XmCreateToggleButtonGadget (p->radio2, "LPFButton", al, ac);
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Gray out Order fields if npages == 1.
 */
     if (current_image->pages == 1) {
       XtVaSetValues (p->order_label, XmNsensitive, False, NULL);
       XtVaSetValues (p->fpf, XmNsensitive, False, NULL);
       XtVaSetValues (p->lpf, XmNsensitive, False, NULL);
     }
/*
 * If this doc is reversed, set LastPageFirst and
 * unset FirstPageFirst.
 */
     if (current_state->reversed == TRUE) {
       XtVaSetValues (p->fpf, XmNset, False, NULL);
       XtVaSetValues (p->lpf, XmNset, True, NULL);
     }
     else {
       XtVaSetValues (p->fpf, XmNset, True, NULL);
       XtVaSetValues (p->lpf, XmNset, False, NULL);
     }

/*
 * Create Scrolled List Widget for page sizes
 */
     ac = 0;
     XtSetArg(al[ac], XmNvisibleItemCount, 3); ac++;
     XtSetArg(al[ac], XmNlistSizePolicy, XmRESIZE_IF_POSSIBLE); ac++;
     XtSetArg(al[ac], XmNitemCount, 6); ac++;
     
     list_items = (XmString *) XtMalloc ( sizeof (XmString) * 6 );
     list_items[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 279,
					      "8.5 x 11 in (Letter)"));
     list_items[1] = XmStringCreateLocalized (catgets (prog->catd, 1, 280,
					      "8.5 x 14 in (Legal)"));
     list_items[2] = XmStringCreateLocalized (catgets (prog->catd, 1, 281,
					      "11 x 17 in (Ledger)"));
     list_items[3] = XmStringCreateLocalized (catgets (prog->catd, 1, 282,
					      "29.7 x 42 cm (A3)"));
     list_items[4] = XmStringCreateLocalized (catgets (prog->catd, 1, 283,
					      "21 x 29.7 cm (A4)"));
     list_items[5] = XmStringCreateLocalized (catgets (prog->catd, 1, 284,
					      "17.6 x 25 cm (B5)"));
     XtSetArg(al[ac], XmNitems, list_items); ac++;
     XtSetArg(al[ac], XmNtopAttachment, XmATTACH_POSITION); ac++;
     XtSetArg(al[ac], XmNtopPosition, 44); ac++;
     XtSetArg(al[ac], XmNleftAttachment, XmATTACH_WIDGET); ac++;
     XtSetArg(al[ac], XmNleftWidget, p->pgsize_label); ac++;
     XtSetArg(al[ac], XmNleftOffset, 10); ac++;
     XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
     p->size_list = XmCreateScrolledList ( form, "PageSizeList", al, ac );
     
     for (list_item = 0; list_item < 6; list_item++ )
       XmStringFree (list_items [list_item]);
     XtFree ( (char *) list_items ); 
/*
 * Select first item on list.
 */
     XmListSelectPos (p->size_list, 1, False);

/*
 * Create OK Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 285, 
						      "OK"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->ok_button = XmCreatePushButton (p->dialog, "PgControlsOKButton", 
					al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create Apply Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 228, 
						      "Apply"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->apply_button = XmCreatePushButton (p->dialog, "PgControlsApplyButton", 
					   al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create Cancel Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 2, 
						      "Close"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->cancel_button = XmCreatePushButton (p->dialog, "PgControlsCloseButton", 
					    al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Create Help Button
 */
     ac = 0;
     xmstrings[0] = XmStringCreateLocalized (catgets (prog->catd, 1, 287, 
						      "Help"));
     XtSetArg(al[ac], XmNlabelString, xmstrings[0]); ac++;
     p->help_button = XmCreatePushButton ( p->dialog, "PgControlsHelpButton", 
					  al, ac );
     XmStringFree ( xmstrings [ 0 ] );
/*
 * Adjust the labels to align with toggle button, not radio boxes.
 */
     XtVaGetValues (p->right_toggle, XmNheight, &height, NULL);
     XtVaSetValues (p->rotate_label, XmNtopOffset, (int) (height / 5), NULL);
     XtVaSetValues (p->order_label, XmNtopOffset, (int) (height / 5), NULL);
/*
 * Set OK to be default button
 */
     XtVaSetValues (p->dialog, XmNdefaultButton, p->ok_button, NULL);

     p->showing = False;

/*
 * Set help callback on dialog
 */
     XtAddCallback (p->dialog, XmNhelpCallback, HelpItemCallback, 
		    HELP_CONTROLS_ITEM);
/*
 * Set callbacks on buttons
 */
     XtAddCallback (p->ok_button, XmNactivateCallback, 
		    PgControlsOKCallback, p);
     XtAddCallback (p->apply_button, XmNactivateCallback, 
		    PgControlsOKCallback, p);
     XtAddCallback (p->cancel_button, XmNactivateCallback, 
		    PgControlsCancelCallback, p);
     XtAddCallback (p->help_button, XmNactivateCallback, HelpItemCallback, 
		    HELP_CONTROLS_ITEM);
/*
 * Manage the children
 */
     ac = 0;
     children[ac++] = p->degrees_0;
     children[ac++] = p->degrees_90;
     children[ac++] = p->degrees_180;
     children[ac++] = p->degrees_270;
     XtManageChildren(children, ac);
     ac = 0;
     children[ac++] = p->right_toggle;
     children[ac++] = p->left_toggle;
     XtManageChildren(children, ac);
     ac = 0;
     children[ac++] = p->fpf;
     children[ac++] = p->lpf;
     XtManageChildren(children, ac);
     ac = 0;
     XtManageChild(p->size_list);
     children[ac++] = p->rotate_label;
     children[ac++] = p->degrees_menu;
     children[ac++] = degrees_label;
     children[ac++] = p->order_label;
     children[ac++] = p->pgsize_label;
     children[ac++] = p->radio1;
     children[ac++] = p->radio2;
     XtManageChildren(children, ac);
     ac = 0;
     children[ac++] = form;
     children[ac++] = p->ok_button;
     children[ac++] = p->apply_button;
     children[ac++] = p->cancel_button;
     children[ac++] = p->help_button;
     XtManageChildren(children, ac);
     
     return p;
}

void
PSDefaultScale ()
{
   int        display_height = DisplayHeight (ps_display->xdisplay,
				       DefaultScreen (ps_display->xdisplay));
   int        view_height, pix_height;

   view_height = display_height - base->extra_height;
   pix_height = ps_display->pageheight * (int) ps_display->res_y;

/*
 * Change scale only if we can make it larger than 100%.
 */
   if (view_height > pix_height) {
      prog->def_ps_zoom = (int) (((float) view_height / (float) pix_height) * 100);
      if ((current_state != NULL) && (current_state->zoom == 1.0))
       current_state->zoom = (float) prog->def_ps_zoom / 100.0;
   }
   else 
      prog->def_ps_zoom = 100;

}

void
PgControlsCancelCallback (w, client_data, call_data)
     Widget     w;
     XtPointer  client_data;
     XtPointer  call_data;
{
     PgControlsObjects *p = (PgControlsObjects *)client_data;

     XtPopdown (XtParent (p->dialog));
}


void
PgControlsOKCallback (w, client_data, call_data)
     Widget     w;
     XtPointer  client_data;
     XtPointer  call_data;
{
    int		row, degrees;
    int		old_angle = current_state->angle;
    int 	old_reversed = current_state->reversed;
    float 	old_width = ps_display->pagewidth;
    float	old_height = ps_display->pageheight;
    float	old_zoom;
    Boolean     set, rotate_right;
    XmString    xmstring;
    char        degrees_str[MAXNAMELEN];

    setbusy ();
    
    current_state->reversed = FALSE;
    XtVaGetValues (pg_controls->lpf, XmNset, &set, NULL);
    if (set == True)
       current_state->reversed = TRUE;

/*
 * Get the degrees.
 */
    XtVaGetValues (XmOptionButtonGadget (pg_controls->degrees_menu),
		   XmNlabelString, &xmstring, NULL);
    ConvertCompoundToChar (xmstring, &degrees_str);
    XmStringFree (xmstring);
    degrees = atoi (degrees_str);
    if (degrees != 0 && degrees != 90 && degrees != 180 && degrees != 270)
      degrees = 0;
/*
 * Check which way we're rotating to set current angle
 */
    XtVaGetValues (pg_controls->right_toggle, XmNset, &rotate_right, NULL);

    if (rotate_right == True)
       current_state->angle = (old_angle + degrees) % 360;
    else 
       current_state->angle = (old_angle + (360 - degrees)) % 360;

    row = GetListSelection (pg_controls->size_list);
    ps_display->pageheight = page_heights [row];
    ps_display->pagewidth = page_widths [row];
  
    old_zoom = current_state->zoom;
    PSDefaultScale ();
    if ((old_zoom != current_state->zoom) && (palette != NULL)) 
      XtVaSetValues (palette->zoom_value, 
		     DtNposition, (int) (current_state->zoom * 100.0), NULL);

    if ((old_width != ps_display->pagewidth) ||
	(old_height != ps_display->pageheight) ||
	(old_angle != current_state->angle)) {
       reset_ps (((old_width != ps_display->pagewidth) ||
		  (old_height != ps_display->pageheight)),
		 ((old_angle != current_state->angle) ||
		  (old_width != ps_display->pagewidth) ||
		  (old_height != ps_display->pageheight))) ;
       if (old_reversed != current_state->reversed)
	  if ((pg_overview != NULL) && (pages_rendered == TRUE))
	     ReversePgOverviewPages (pg_overview, current_image->pages,
				     current_state->reversed);
       }
    else {
       if (old_reversed != current_state->reversed) {

	  goto_page (current_state->current_page, TRUE, FALSE);
	  if ((pg_overview != NULL) && (pages_rendered == TRUE))
	     ReversePgOverviewPages (pg_overview, current_image->pages,
				     current_state->reversed);
	  }
       }

/*
 * If we changed the angle, and undo is on, and the undo op is
 * a rotation, we should figure out how to get it back to where 
 * it was.
 */

    if ((old_angle != current_state->angle) &&
        (((current_state->undo).op == ROTATE_L) ||
         ((current_state->undo).op == ROTATE_R))) {

/*
 * If we are now LANDSCAPE, and old angle was 0-89 or 270-359, then
 *    we did a rotate right. If the angle was 91-269 then we did a 
 *    rotate left.
 */

       if (current_state->angle == 90) {
	  if ((old_angle >= 91) && (old_angle <= 269)) {
	     (current_state->undo).op = ROTATE_R;
	     current_state->rotate_amt = old_angle - current_state->angle;
	     }
	  else {
	     (current_state->undo).op = ROTATE_L;
	     if ((old_angle >= 0) && (old_angle <= 89))
	        current_state->rotate_amt = current_state->angle - old_angle;
	     else
	        current_state->rotate_amt = current_state->angle +
					    (360 - old_angle);
	     }
	  }

/*
 * If we are now PORTRAIT, and old angle was 1-180, then we did a
 *    rotate left. If the angle was 181-359, then we did a rotate
 *    right.
 */

       else {
	  if ((old_angle >= 1) && (old_angle <= 180)) {
	     (current_state->undo).op = ROTATE_R;
	     current_state->rotate_amt = old_angle; 
	     }
	  else {
	     (current_state->undo).op = ROTATE_L;
	     current_state->rotate_amt = 360 - old_angle;
	     }
	  }
       }
/*
 * Dismiss only if OK, not apply button
 */      
    if (w == pg_controls->ok_button)
      DismissDialog (pg_controls->dialog);

    setactive ();
}

